Generated: 2025-10-02 23:30:53

aios_start.py:
#!/usr/bin/env python3
import subprocess, sys, socket, webbrowser
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
commands = {
    "start": lambda: (
        Path.home().joinpath(".aios").mkdir(exist_ok=True),
        (lambda ports: (
            aios_db.write("ports", {"web": ports[0], "api": ports[1]}),
            aios_db.write("aios_pids", {}),
            (lambda sock: (
                [sock.setsockopt(socket.SOL_SOCKET, opt, 1) for opt in [socket.SO_REUSEADDR, socket.SO_REUSEPORT]],
                sock.bind(('', ports[0])),
                sock.listen(5),
                (lambda procs: (
                    sock.close(),
                    aios_db.write("aios_pids", {"api": procs[0].pid, "web": procs[1].pid}),
                    print(f"AIOS started: http://localhost:{ports[0]}"),
                    webbrowser.open(f"http://localhost:{ports[0]}"),
                    subprocess.Popen(["python3", "-c", "from services import context_generator; context_generator.generate()"], cwd="/home/seanpatten/projects/AIOS")
                ))([
                    subprocess.Popen(["python3", "core/aios_api.py", str(ports[1])], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL),
                    subprocess.Popen(["python3", "services/web/web.py", str(sock.fileno()), str(ports[0]), str(ports[1])], pass_fds=[sock.fileno()])
                ])
            ))(socket.socket(socket.AF_INET, socket.SOCK_STREAM))
        ))([
            (lambda sk: (sk.bind(('', 0)), sk.getsockname()[1], sk.close())[1])(socket.socket()),
            (lambda sk: (sk.bind(('', 0)), sk.getsockname()[1], sk.close())[1])(socket.socket())
        ])
    )[-1],
    "stop": lambda: (
        subprocess.run(["pkill", "-9", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL),
        subprocess.run(["pkill", "-9", "-f", "services/web/web.py"], stderr=subprocess.DEVNULL),
        aios_db.write("aios_pids", {}),
        print("AIOS stopped")
    )[-1],
    "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")
}
commands[(sys.argv + ["start"])[1]]()

core/aios_runner.py:
#!/usr/bin/env python3
import subprocess, sys, signal, os

cmd_str = ' '.join(sys.argv[1:]).lower()

timeout_map = {
    'web.py': 999999, 'aios_api.py': 999999, 'scheduler.py': 999999,
    'poll': 999999, 'watch': 999999, 'serve': 999999,
    'autollm': 999999, 'claude': 999999, 'codex': 999999,
    'wiki_fetcher': 5.0, 'scraper': 5.0, 'gdrive': 5.0,
    'curl': 5.0, 'wget': 5.0, 'git': 5.0, 'npm': 5.0, 'pip': 5.0
}

matches = [timeout_map.get(p, 0) * (p in cmd_str) for p in timeout_map.keys()]
timeout = float(os.getenv('AIOS_TIMEOUT', str(max(matches + [0.1]))))

signal.signal(signal.SIGALRM, lambda *_: sys.exit(1))
signal.setitimer(signal.ITIMER_REAL, timeout)

result = subprocess.run(sys.argv[1:], capture_output=True, text=True)

signal.alarm(0)
sys.stdout.write(result.stdout)
sys.stderr.write(result.stderr)
sys.exit(result.returncode)


core/aios_db.py:
import json, sqlite3, pathlib

# Database connection
db_path = pathlib.Path(__file__).parent.parent / "data/aios.db"
d = sqlite3.connect(str(db_path), isolation_level=None, check_same_thread=False)

# Set pragmas for performance
[d.execute(p) for p in ["PRAGMA synchronous=0", "PRAGMA journal_mode=MEMORY"]]

# Create tables
tables = [
    """CREATE TABLE IF NOT EXISTS kv(
        k TEXT PRIMARY KEY,
        v TEXT
    )""",
    """CREATE TABLE IF NOT EXISTS jobs(
        id INTEGER PRIMARY KEY,
        name TEXT,
        status TEXT,
        output TEXT,
        created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )""",
    """CREATE TABLE IF NOT EXISTS messages(
        id INTEGER PRIMARY KEY,
        content TEXT,
        timestamp TEXT,
        source TEXT,
        priority INTEGER DEFAULT 0
    )""",
    """CREATE TABLE IF NOT EXISTS worktrees(
        id INTEGER PRIMARY KEY,
        repo TEXT,
        branch TEXT,
        path TEXT,
        job_id INTEGER,
        model TEXT,
        task TEXT,
        status TEXT,
        output TEXT,
        created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )""",
    """CREATE TABLE IF NOT EXISTS events(
        id INTEGER PRIMARY KEY,
        target TEXT,
        data TEXT,
        created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )"""
]
d.executescript(";".join(tables))

# Database functions
read = lambda n: json.loads(d.execute("SELECT v FROM kv WHERE k=?", (n,)).fetchone()[0])
write = lambda n, x: (d.execute("INSERT OR REPLACE INTO kv VALUES(?,?)", (n, json.dumps(x, indent=2))), x)[1]
query = lambda _, s, p=(): d.execute(s, p).fetchall()
execute = lambda _, s, p=(): d.execute(s, p)


core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db, uvicorn
app = FastAPI()
@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)
@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())
@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)", (target, (await request.body()).decode()))
    return {"status": "ok"}
@app.get("/status")
async def status():
    aios_db.write("services", {})
    aios_db.write("tasks", [])
    aios_db.write("schedule", {})
    return {"services": aios_db.read("services"), "tasks": aios_db.read("tasks"), "schedule": aios_db.read("schedule")}

api_port = int((sys.argv + ["8000"])[1])
uvicorn.run(app, host="0.0.0.0", port=api_port)

services/backup.py:
#!/usr/bin/env python3
import sys, shutil
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
from pathlib import Path
import aios_db
from datetime import datetime
[aios_db.write(*x) for x in [("backup", {"source": str(Path.home()), "dest": "/tmp/backup"}), ("backup_log", [])]]
c = aios_db.read("backup")
n = datetime.now()
dest = Path(c.get("dest", "/tmp/backup")) / f"{n:%Y%m%d_%H%M%S}"
[dest.parent.mkdir(parents=True, exist_ok=True), shutil.copytree(Path(c.get("source", str(Path.home()))), dest, dirs_exist_ok=True), aios_db.write("backup_log", aios_db.read("backup_log") + [{"time": n.isoformat(), "dest": str(dest)}]), print(f"Backed up to {dest}")]

services/terminal_manager.py:
#!/usr/bin/env python3
import sys, os, pty, termios, struct, fcntl, signal
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

_pty_sessions = {}

def create_session(worktree_id, worktree_path):
    master, slave = pty.openpty()
    fcntl.ioctl(slave, termios.TIOCSWINSZ, struct.pack('HHHH', 24, 80, 0, 0))
    pid = os.fork()
    if pid == 0:
        [os.dup2(slave, fd) for fd in [0, 1, 2]]
        [os.close(fd) for fd in [master, slave]]
        os.setsid()
        os.chdir(worktree_path)
        os.execv('/bin/bash', ['bash'])
    os.close(slave)
    os.set_blocking(master, False)
    _pty_sessions[worktree_id] = {"master": master, "pid": pid, "path": worktree_path}
    sessions = aios_db.read("terminal_sessions") or {}
    sessions[worktree_id] = {"pid": pid, "path": worktree_path, "created": __import__('time').time()}
    aios_db.write("terminal_sessions", sessions)
    return master

get_session = lambda wt_id: _pty_sessions.get(wt_id)
send_data = lambda wt_id, data: os.write(_pty_sessions[wt_id]["master"], data) if wt_id in _pty_sessions else None
read_data = lambda wt_id, size=65536: (lambda s: os.read(s["master"], size) if s else b'')(_pty_sessions.get(wt_id))
kill_session = lambda wt_id: (os.kill(_pty_sessions[wt_id]["pid"], signal.SIGTERM), os.close(_pty_sessions[wt_id]["master"]), _pty_sessions.pop(wt_id)) if wt_id in _pty_sessions else None

if __name__ == "__main__":
    cmd, wt_id, wt_path = (sys.argv + ["list", "default", str(Path.cwd())])[:3]
    {"create": lambda: (create_session(wt_id, wt_path), print(f"Created: {wt_id}")),
     "list": lambda: [print(f"{k}: pid={v['pid']} -> {v['path']}") for k, v in (aios_db.read("terminal_sessions") or {}).items()]}.get(cmd, lambda: None)()


services/service.py:
#!/usr/bin/env python3
import sys
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db

aios_db.write("services", {})
s = aios_db.read("services")
c = (sys.argv + ["list"])[1]
n = (sys.argv + ["", ""])[2]

commands = {
    "list": lambda: list(map(print, [f"{k}: {v.get('status', 'unknown')}" for k, v in s.items()])),
    "start": lambda: aios_db.write("services", {**s, n: {**s.get(n, {}), "status": "running"}}),
    "stop": lambda: aios_db.write("services", {**s, n: {**s.get(n, {}), "status": "stopped"}}),
    "status": lambda: print(s.get(n, {}).get("status", "unknown") or "specify service")
}

commands[c]()

services/scraper.py:
#!/usr/bin/env python3
import sys, requests
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from bs4 import BeautifulSoup
from datetime import datetime
aios_db.write("scraper", {"urls": ["https://news.ycombinator.com"]})
get_title = lambda u: (lambda s: s.title.string or "No title")(BeautifulSoup(requests.get(u, timeout=0.01).text, 'html.parser'))
results = [{"url": u, "title": get_title(u), "time": datetime.now().isoformat()} for u in aios_db.read("scraper").get("urls", [])]
[aios_db.write("scraper_results", results), list(map(lambda r: print(f"{r['url']}: {r['title']}"), results))]

services/workflow_executor.py:
#!/usr/bin/env python3
import sys, subprocess
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

def parse_workflow_md(md_path):
    steps, in_code, current = [], False, []
    for line in Path(md_path).read_text().split('\n'):
        if line.strip().startswith('```bash') or line.strip().startswith('```sh'):
            in_code, current = True, []
        elif in_code and line.strip().startswith('```'):
            steps.append('\n'.join(current))
            in_code = False
        elif in_code:
            current.append(line)
    return steps

def execute_workflow(worktree_id, workflow_path):
    steps = parse_workflow_md(workflow_path)
    try:
        workflows = aios_db.read("active_workflows")
    except:
        workflows = {}
    workflows[worktree_id] = {"steps": steps, "current_step": 0, "results": [], "status": "ready", "workflow_path": workflow_path}
    aios_db.write("active_workflows", workflows)

    results = []
    for i, step in enumerate(steps):
        workflows[worktree_id].update({"current_step": i, "status": "executing"})
        aios_db.write("active_workflows", workflows)

        try:
            result = subprocess.run(step, shell=True, capture_output=True, text=True, timeout=300, cwd=Path.home() / ".aios")
            output = result.stdout + result.stderr
        except subprocess.TimeoutExpired:
            output = "Timeout"
        except Exception as e:
            output = f"Error: {e}"

        results.append({"step": i, "command": step, "output": output[-500:]})
        workflows[worktree_id]["results"] = results
        aios_db.write("active_workflows", workflows)

    workflows[worktree_id]["status"] = "completed"
    aios_db.write("active_workflows", workflows)
    return {"status": "completed", "results": results}

if __name__ == "__main__":
    import json
    cmd = (sys.argv + ["execute"])[1]
    if cmd == "execute":
        wt_id = (sys.argv + ["", "default"])[2]
        wf_path = (sys.argv + ["", "", "workflow.md"])[3]
        try:
            result = execute_workflow(wt_id, wf_path)
            print(json.dumps(result))
        except Exception as e:
            print(json.dumps({"status": "error", "error": str(e)}))
    elif cmd == "parse":
        wf_path = (sys.argv + ["", "", "workflow.md"])[2]
        steps = parse_workflow_md(wf_path)
        for i, step in enumerate(steps):
            print(f"{i+1}. {step}")


services/context_generator.py:
from pathlib import Path
from datetime import datetime
def generate():
    root = Path(__file__).parent.parent
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    files = list(root.rglob("*.py"))
    readme = root / "README.md"

    code_files = [f for f in files if "testing" not in str(f)]
    test_files = [f for f in files if "testing" in str(f)]

    base_content = f"Generated: {timestamp}\n\n"
    base_content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in code_files])
    base_content += (lambda r: f"\nREADME.md:\n{r.read_text()}\n" * r.exists())(readme)

    full_content = base_content + "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in test_files])

    (root / "projectContext.txt").write_text(base_content)
    (root / "projectContextWithTests.txt").write_text(full_content)

    return str(root / "projectContext.txt")

services/jobs.py:
#!/usr/bin/env python3
import sys, subprocess
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
c, jid, j = (sys.argv + ["list"])[1], (sys.argv + ["", "0"])[2], aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")
pj = lambda x: print(f"{x[0]}: {x[1]} - {x[2]} - {((x[3] or 'No output')[:50]) * (x[3] != None) or 'No output'}...")
pr = lambda x: print(f'<div class="job-item">{x[1]} <span class="status running">Running...</span></div>')
prv = lambda x: [print(f'<div class="job-item">{x[1]} <span class="output">{((x[3] or "")[:50] + "...") * (x[3] != None)}</span>'), print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{x[0]}"><button class="action-btn">Accept</button></form>'), print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{x[0]}"><button class="action-btn">Redo</button></form></div>')]
pd = lambda x: print(f'<div class="job-item">{x[1]} <span class="output">{((x[3] or "")[:50] + "...") * (x[3] != None)}</span></div>')
print_summary = lambda: (lambda r, rv, d, s: (list(map(s.extend, [[f"RUN {x[1]}" for x in r[:2]], [f"? {x[1]}" for x in rv[:1]], [f"DONE {x[1]}" for x in d[:1]]])), list(map(print, s[:4]))))((list(filter(lambda x: x[2] == "running", j))), (list(filter(lambda x: x[2] == "review", j))), (list(filter(lambda x: x[2] == "done", j))[:5]), [])[-1]
{"summary": print_summary, "running": lambda: list(map(pr, filter(lambda x: x[2] == "running", j[:10]))), "review": lambda: list(map(prv, filter(lambda x: x[2] == "review", j[:10]))), "done": lambda: list(map(pd, filter(lambda x: x[2] == "done", j[:50]))), "run_wiki": lambda: (aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')"), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0])]))[-1], "accept": lambda: aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(jid),)) or None, "redo": lambda: (aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(jid),)), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(jid)]))[-1] or None, "list": lambda: list(map(pj, j[:20]))}[c]()

services/processes.py:
#!/usr/bin/env python3
import sys, subprocess, json
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from pathlib import Path

c = (sys.argv + ["json"])[1]
n = (sys.argv + ["", ""])[2]

[aios_db.write(k, v) for k, v in [("schedule", {}), ("aios_pids", {})]]

get_procs = lambda: {
    "scheduled": sorted(
        [{"path": cmd, "type": "daily", "time": time, "status": "scheduled"} for time, cmd in aios_db.read("schedule").get("daily", {}).items()] +
        [{"path": cmd, "type": "hourly", "time": f":{int(m):02d}", "status": "scheduled"} for m, cmd in aios_db.read("schedule").get("hourly", {}).items()],
        key=lambda x: x["time"]
    ),
    "ongoing": [{"path": f"{k}_pid_{v}", "type": "running", "status": "active"} for k, v in aios_db.read("aios_pids").items()],
    "core": [{"path": str(f.relative_to(Path('/home/seanpatten/projects/AIOS'))), "type": "file", "status": "available"}
             for f in list(filter(lambda f: 'archive' not in f.parts and '__pycache__' not in f.parts, Path('/home/seanpatten/projects/AIOS').rglob('*.py')))]
}

print_proc = lambda p: print(f"{p['path']}: {p['status']}")

commands = {
    "json": lambda: print(json.dumps(get_procs())),
    "list": lambda: (list(map(print_proc, get_procs()["scheduled"])), list(map(print_proc, get_procs()["ongoing"])), list(map(print_proc, get_procs()["core"])))[0],
    "start": lambda: subprocess.Popen(['python3', n]) or None,
    "stop": lambda: subprocess.run(['pkill', '-f', n], timeout=5) or None
}

commands[c]()

services/feed.py:
#!/usr/bin/env python3
import sys
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from datetime import datetime

c = (sys.argv + ["list"])[1]

print_msg = lambda r: print({True: f"{r[2].split('T')[1][:5]} {r[1]}", False: f"{r[2].split('T')[0]} {r[2].split('T')[1][:5]} {r[1]}"}[datetime.fromisoformat(r[2]).date() == datetime.now().date()])

commands = {
    "add": lambda: aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (" ".join(sys.argv[2:]), datetime.now().isoformat(), "manual")),
    "list": lambda: list(map(print_msg, aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50"))),
    "view": lambda: list(map(print_msg, aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50"))),
    "clear": lambda: aios_db.execute("feed", "DELETE FROM messages WHERE timestamp < datetime('now', '-7 days')")
}

commands[c]()

programs/job_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import subprocess

command = sys.argv[1] if len(sys.argv) > 1 else "summary"
job_id = sys.argv[2] if len(sys.argv) > 2 else None

jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")

if command == "summary":
    running = [j for j in jobs if j[2] == "running"]
    review = [j for j in jobs if j[2] == "review"]
    done = [j for j in jobs if j[2] == "done"][:5]

    summary = []
    summary.extend([f"RUN {j[1]}" for j in running[:2]])
    summary.extend([f"? {j[1]}" for j in review[:1]])
    summary.extend([f"DONE {j[1]}" for j in done[:1]])

    for line in summary[:4]:
        print(line)

elif command == "running":
    running = [j for j in jobs if j[2] == "running"]
    for j in running[:10]:
        print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')

elif command == "review":
    review = [j for j in jobs if j[2] == "review"]
    for j in review[:10]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
        print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
        print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')

elif command == "done":
    done = [j for j in jobs if j[2] == "done"]
    for j in done[:50]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')

elif command == "run_wiki":
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

elif command == "accept" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))

elif command == "redo" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),))
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("ideas", [])
ideas, command = aios_db.read("ideas"), (sys.argv + ["list"])[1]
score = lambda i: len(i.get('description', '')) * i.get('impact', 1) / max(i.get('effort', 1), 1)
commands = {
    "add": lambda: aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}]),
    "rank": lambda: list(map(lambda x: print(f"{x[0]+1}. [{score(x[1]):.1f}] {x[1]['description']}"), enumerate(sorted(ideas, key=score, reverse=True)))),
    "list": lambda: list(map(lambda x: print(f"{x[0]+1}. {x[1]['description']}"), enumerate(ideas))),
    "pick": lambda: print(f"Best: {sorted(ideas, key=lambda x: score(x)/x.get('effort', 5), reverse=True)[0]['description']}") if ideas else None
}
commands.get(command, commands["list"])()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys, subprocess, concurrent.futures
from pathlib import Path
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
components, build_dir = sys.argv[1:] or [], Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)
build_component = lambda n: ((build_dir / f"{n}.build").write_text(f"Built at {datetime.now()}"), {"name": n, "status": {0: "success"}.get(subprocess.run(['echo', f'Building {n}'], capture_output=True, timeout=10).returncode, "failed"), "time": datetime.now().isoformat()})[1]
results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components))
list(map(lambda r: print(f"{r['name']}: {r['status']}"), results))
aios_db.write("build_log", [])
aios_db.write("build_log", aios_db.read("build_log") + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys, subprocess, schedule as sched
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
schedules = aios_db.read("schedule")
run_cmd = lambda cmd: subprocess.run(cmd, shell=True, timeout=300)
list(map(lambda item: sched.every().day.at(item[0]).do(run_cmd, item[1]), schedules.get("daily", {}).items()))
list(map(lambda item: sched.every().hour.at(f":{int(item[0]):02d}").do(run_cmd, item[1]), schedules.get("hourly", {}).items()))
sched.run_pending()

programs/wiki_fetcher/wiki_fetcher.py:
#!/usr/bin/env python3
import sys, json, urllib.request
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
data = json.loads(urllib.request.urlopen(urllib.request.Request("https://en.wikipedia.org/api/rest_v1/page/random/summary", headers={'User-Agent': 'Mozilla/5.0'})).read().decode())
output, job_id = f"{data.get('title', 'Unknown')}: {data.get('extract', 'No extract available')[:200]}...", (sys.argv + [None])[1]
(job_id and aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?", (output, job_id))) or print(output)

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("tasks", []) or aios_db.write("daily_plan", {})
tasks, today, plan = aios_db.read("tasks"), str(datetime.now().date()), aios_db.read("daily_plan")
pending = [t for t in tasks if not (t.startswith("[x]") or t.startswith("[!]"))][:10]
plan[today] = pending
aios_db.write("daily_plan", plan)
list(map(lambda t: print(f"- {t}"), pending))

programs/settings/settings.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
command, key, value, settings = (sys.argv + ["set"])[1], (sys.argv + ["set", "theme"])[2], (sys.argv + ["set", "theme", ""])[3], aios_db.read("settings") or {}
{"set": lambda: aios_db.write("settings", {**settings, key: value}), "get": lambda: print(settings.get(key, ""))}[command]()


programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = (sys.argv + ["list"])[1]
question = ' '.join(sys.argv[2:])

client = anthropic.Anthropic(api_key=(aios_db.read("api_keys") or {}).get("anthropic", ""))

def ask():
    response = client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text
    cache[question] = {"response": response, "time": datetime.now().isoformat()}
    aios_db.write("llm_cache", cache)
    print(response)
    return cache

def print_item(item):
    q, a = item
    print(f"Q: {q[:50]}... A: {a['response'][:50]}...")

def list_cache():
    list(map(print_item, cache.items()))
    return cache

def clear():
    return aios_db.write("llm_cache", {})

def stats():
    print(f"Cached queries: {len(cache)}")
    return len(cache)

actions = {"ask": ask, "list": list_cache, "clear": clear, "stats": stats}
actions.get(command, list_cache)()

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
command, get_tasks = (sys.argv + ["list"])[1], lambda: aios_db.read("tasks") or []
tasks = get_tasks()
commands = {
    "add": lambda: (aios_db.write("tasks", get_tasks() + [f"[ ] {datetime.now():%Y-%m-%d %H:%M} {' '.join(sys.argv[2:]).split('@')[0].strip()}"]),
                   aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Task: {' '.join(sys.argv[2:]).split('@')[0].strip()}", datetime.now().isoformat(), "todo"))),
    "done": lambda: (lambda ts, tid, t: (aios_db.write("tasks", ts[:tid] + [t.replace("[ ]", "[x]")] + ts[tid+1:]),
                                          aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Completed: {' '.join(t.split()[3:])}", datetime.now().isoformat(), "todo"))))(get_tasks(), int((sys.argv + ["0", "1"])[2])-1, get_tasks()[int((sys.argv + ["0", "1"])[2])-1]),
    "list": lambda: list(map(lambda x: print(f"{x[0]+1}. {x[1]}"), enumerate(tasks))),
    "clear": lambda: aios_db.write("tasks", list(filter(lambda t: t.startswith("[ ]"), tasks)))
}
commands[command]()

programs/autollm/view_output.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file, db_output = (sys.argv + [""])[1], Path.home() / ".aios" / f"autollm_output_{(sys.argv + [''])[1]}.txt", aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", ((sys.argv + [""])[1],))
print(output_file.read_text() if output_file.exists() else (db_output[0][0] or "No output yet") if db_output else "No output yet")

programs/autollm/capture_output.py:
#!/usr/bin/env python3
import subprocess, sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file, cmd_type, model, task = sys.argv[1], Path.home() / ".aios" / f"autollm_output_{sys.argv[1]}.txt", sys.argv[2], sys.argv[3], " ".join(sys.argv[4:])
result = subprocess.run({"claude": ["claude", task], "claude-dangerous": ["claude", "--dangerously-skip-permissions", task], "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]}.get(cmd_type, ["echo", "Invalid command"]), capture_output=True, text=True, timeout=999999)
output = result.stdout + result.stderr
output_file.write_text(output)
list(map(lambda q: aios_db.execute(q[0], q[1], (output, job_id)), [("autollm", "UPDATE worktrees SET output=?, status='review' WHERE job_id=?"), ("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?")]))

programs/autollm/output_page.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file = (sys.argv + [""])[1], Path.home() / ".aios" / f"autollm_output_{(sys.argv + [''])[1]}.txt"
worktree = aios_db.query("autollm", "SELECT branch, task, model, status, output FROM worktrees WHERE job_id=?", (job_id,))
info = worktree[0] if worktree else ["unknown", "unknown", "unknown", "unknown", ""]
file_output = output_file.read_text() if output_file.exists() else (info[4] or "No output yet") if worktree else "No output yet"
list(map(print, [f"Branch: {info[0]}", f"Task: {info[1]}", f"Model: {info[2]}", f"Status: {info[3]}", f"Output:\n{file_output}"]))

programs/autollm/llm.py:
#!/usr/bin/env python3
import subprocess, sys
command, model, task = (sys.argv + ["claude"])[1], (sys.argv + ["", "claude-3-5-sonnet-20241022"])[2], " ".join(sys.argv[3:]) or "Improve this code"
subprocess.run({"claude": ["claude", "--dangerously-skip-permissions", task], "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]}.get(command, ["claude", "--dangerously-skip-permissions", task]), timeout=999999)

programs/autollm/llm_test.py:
#!/usr/bin/env python3
import sys
print(f"LLM called with: command={sys.argv[1]}, model={sys.argv[2]}, task={' '.join(sys.argv[3:])}")

programs/autollm/autollm.py:
#!/usr/bin/env python3
import subprocess, sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
command = (sys.argv + ["run"])[1]
create_and_launch = lambda repo, branch, model, task: (
    subprocess.run(["git", "worktree", "add", "-b", branch, str(Path(repo).parent / f"{Path(repo).name}-{branch}")], cwd=repo, capture_output=True, timeout=5),
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES (?, 'running')", (branch,)),
    aios_db.execute("autollm", "INSERT INTO worktrees(repo, branch, path, job_id, model, task, status) VALUES (?, ?, ?, ?, ?, ?, 'running')",
                    (repo, branch, str(Path(repo).parent / f"{Path(repo).name}-{branch}"), aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0], model, task)),
    subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_runner.py", "python3", "/home/seanpatten/projects/AIOS/programs/autollm/capture_output.py",
                     str(aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]),
                     {"claude-dangerous": "claude-dangerous"}.get(model, {True: "claude", False: "codex"}[model.startswith("claude")]), model, task],
                    cwd=str(Path(repo).parent / f"{Path(repo).name}-{branch}"), env={**subprocess.os.environ, "AIOS_TIMEOUT": "999999"})
)
commands = {
    "run": lambda: list(map(lambda i: create_and_launch((sys.argv + ["", "/home/seanpatten/projects/testRepoPrivate"])[2], f"autollm-{Path((sys.argv + ['', '/home/seanpatten/projects/testRepoPrivate'])[2]).name}-{i}", (sys.argv + ["", "", "", "claude-3-5-sonnet-20241022"])[4], " ".join(sys.argv[5:]) or "Improve code"), range(int((sys.argv + ["", "", "1"])[3])))),
    "status": lambda: list(map(lambda w: print(f"{w[0]}: {w[1]}"), aios_db.query("autollm", "SELECT branch, status FROM worktrees"))),
    "clean": lambda: (list(map(lambda w: subprocess.run(["git", "worktree", "remove", w[2]], cwd=w[0], capture_output=True, timeout=5), aios_db.query("autollm", "SELECT repo, branch, path FROM worktrees WHERE status='done'"))), aios_db.execute("autollm", "DELETE FROM worktrees WHERE status='done'")),
    "output": lambda: print((lambda r: r and r[0][0] or "")(aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", ((sys.argv + ["", ""])[2],)))),
    "accept": lambda: (aios_db.execute("autollm", "UPDATE worktrees SET status='done' WHERE job_id=?", ((sys.argv + ["", ""])[2],)), aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", ((sys.argv + ["", ""])[2],)))
}
commands[command]()

programs/autollm/reset.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

aios_db.execute("autollm", "DROP TABLE IF EXISTS worktrees")
aios_db.execute("autollm", "CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY, repo TEXT, branch TEXT, path TEXT, job_id INTEGER, model TEXT, task TEXT, status TEXT, output TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
print("Reset autollm database")

programs/autollm/terminal.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
worktree = aios_db.query("autollm", "SELECT path, output FROM worktrees WHERE job_id=?", (job_id,))
path = worktree[0][0]

output_file = Path(path) / ".autollm_output"
subprocess.run(["tail", "-f", str(output_file)], timeout=999999)

programs/autollm/monitor.py:
#!/usr/bin/env python3
import sys
import subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, model, task FROM worktrees")
list(map(lambda w: print(f"{w[0]}: {w[3]} | {w[4]} | {w[5][:30]}"), worktrees))

programs/workflow/workflow.py:
#!/usr/bin/env python3
import sys, json, subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
from pathlib import Path
from datetime import datetime

cmd = (sys.argv + ["list"])[1]

def get_workflows():
    try:
        return aios_db.read("workflows")
    except:
        aios_db.write("workflows", {})
        return {}

def get_nodes():
    try:
        return aios_db.read("workflow_nodes")
    except:
        aios_db.write("workflow_nodes", [])
        return []

def add_node():
    nodes = get_nodes()
    col = int((sys.argv + ["", "0"])[2])
    args = sys.argv[3:]
    folder = str(Path.cwd())
    text = " ".join(args)
    for i, arg in enumerate(args):
        if arg.startswith("/") and Path(arg).exists():
            folder = arg
            text = " ".join(args[:i] + args[i+1:])
            break
    node = {"id": len(nodes), "col": col, "text": text, "folder": folder, "parent": None, "children": [], "branch": None, "created": datetime.now().isoformat()}
    aios_db.write("workflow_nodes", nodes + [node])
    print(f"{node['id']}")

def list_nodes():
    cols = {}
    for n in get_nodes():
        cols.setdefault(n["col"], []).append(n)
    for c in sorted(cols.keys()):
        print(f"Column {c}:")
        list(map(lambda n: print(f"  {n['id']}: {n['text'][:50]}"), cols[c]))

def expand():
    nid = int((sys.argv + ["", "0"])[2])
    instruction = " ".join(sys.argv[3:])
    nodes = get_nodes()
    parent = nodes[nid]
    new_text = f"{parent['text']}\n{instruction}" if instruction else parent['text']
    child = {"id": len(nodes), "col": parent["col"] + 1, "text": new_text, "folder": parent["folder"], "parent": nid, "children": [], "branch": None, "created": datetime.now().isoformat()}
    nodes[nid]["children"].append(child["id"])
    aios_db.write("workflow_nodes", nodes + [child])
    print(f"{child['id']}")

def branch():
    nid = int((sys.argv + ["", "0"])[2])
    btype = (sys.argv + ["", "", "folder"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    folder = node["folder"]
    if btype == "worktree":
        branch_name = f"workflow-{nid}-{datetime.now():%Y%m%d%H%M%S}"
        path = f"{folder}-{branch_name}"
        subprocess.run(["git", "worktree", "add", "-b", branch_name, path], cwd=folder, capture_output=True, timeout=5)
        nodes[nid]["branch"] = {"type": "worktree", "path": path, "branch": branch_name}
    elif btype == "subfolder":
        path = f"{folder}/workflow-{nid}"
        Path(path).mkdir(parents=True, exist_ok=True)
        nodes[nid]["branch"] = {"type": "subfolder", "path": path}
    else:
        nodes[nid]["branch"] = {"type": "main", "path": folder}
    aios_db.write("workflow_nodes", nodes)
    print(nodes[nid]["branch"]["path"])

def worktree_with_terminal():
    """Create a worktree and return terminal session info for PTY"""
    repo = (sys.argv + ["", "/home/seanpatten/projects/AIOS"])[2]
    branch_name = (sys.argv + ["", ""])[3]

    # Generate branch name if empty or not provided
    if not branch_name or branch_name.strip() == "":
        branch_name = f"worktree_{datetime.now():%Y%m%d_%H%M%S}"

    # Create worktree path
    parent = Path(repo).parent
    worktree_path = parent / f"{Path(repo).name}_{branch_name}"

    # Create the worktree
    result = subprocess.run(
        ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
        cwd=repo,
        capture_output=True,
        text=True,
        timeout=10
    )

    if result.returncode != 0:
        print(json.dumps({"error": f"Failed to create worktree: {result.stderr}"}))
        return

    # Store worktree info
    try:
        worktrees = aios_db.read("worktrees_list")
    except:
        worktrees = []

    worktree_info = {
        "repo": str(repo),
        "branch": branch_name,
        "path": str(worktree_path),
        "created": datetime.now().isoformat()
    }
    worktrees.append(worktree_info)
    aios_db.write("worktrees_list", worktrees)

    # Return info for terminal creation
    print(json.dumps({
        "success": True,
        "branch": branch_name,
        "path": str(worktree_path),
        "message": f"Worktree created at {worktree_path}"
    }))

def execute():
    nid = int((sys.argv + ["", "0"])[2])
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    full_prompt = node["text"]
    parent_id = node.get("parent")
    while parent_id is not None:
        parent = nodes[parent_id]
        full_prompt = f"{parent['text']}\n{full_prompt}"
        parent_id = parent.get("parent")
    aios_db.execute("jobs", "INSERT INTO jobs(name, status, output) VALUES (?, 'running', ?)", (f"workflow-{nid}", node["text"]))
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["claude", "--dangerously-skip-permissions", full_prompt], cwd=path, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print(f"{job_id}")

def save_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    workflows[name] = {"nodes": get_nodes(), "saved": datetime.now().isoformat()}
    aios_db.write("workflows", workflows)
    print(f"Saved: {name}")

def load_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    aios_db.write("workflow_nodes", workflows.get(name, {}).get("nodes", []))
    print(f"Loaded: {name}")

def git_push():
    nid = int((sys.argv + ["", "0"])[2])
    msg = " ".join(sys.argv[3:]) or "workflow update"
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.run(["git", "add", "."], cwd=path, timeout=5)
    subprocess.run(["git", "commit", "-m", msg], cwd=path, timeout=5, capture_output=True)
    result = subprocess.run(["git", "push"], cwd=path, timeout=5, capture_output=True, text=True)
    if "no upstream branch" in result.stderr:
        branch_name = subprocess.run(["git", "branch", "--show-current"], cwd=path, capture_output=True, text=True, timeout=5).stdout.strip()
        subprocess.run(["git", "push", "--set-upstream", "origin", branch_name], cwd=path, timeout=5)
    print(f"Pushed: {path}")

def terminal():
    nid = int((sys.argv + ["", "0"])[2])
    term = (sys.argv + ["", "", "gnome-terminal"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.Popen([term, "--working-directory", path])
    print(f"Terminal: {path}")

def comment():
    nid = int((sys.argv + ["", "0"])[2])
    text = " ".join(sys.argv[3:])
    nodes = get_nodes()
    nodes[nid].setdefault("comments", []).append({"text": text, "time": datetime.now().isoformat(), "author": "human"})
    aios_db.write("workflow_nodes", nodes)
    print(f"Comment added to {nid}")

{"add": add_node, "list": list_nodes, "expand": expand, "branch": branch, "exec": execute, "save": save_workflow, "load": load_workflow, "push": git_push, "term": terminal, "comment": comment, "worktree_terminal": worktree_with_terminal}.get(cmd, list_nodes)()


programs/worktree/worktree_manager.py:
#!/usr/bin/env python3
import sys
import subprocess
import os
from pathlib import Path
from datetime import datetime
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

def create_worktree_with_terminal(repo_path=None, branch_name=None):
    """Create a new git worktree and open a terminal in it"""

    # Default to AIOS project if no repo specified
    if not repo_path or repo_path == '':
        repo_path = '/home/seanpatten/projects/AIOS'

    # Check if it's a git repository
    try:
        subprocess.run(["git", "status"], cwd=repo_path, capture_output=True, check=True)
    except:
        return {"error": "Not a git repository", "path": repo_path}

    # Generate branch name if not provided
    if not branch_name:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        branch_name = f"worktree_{timestamp}"

    # Create worktree path
    parent = Path(repo_path).parent
    worktree_path = parent / f"{Path(repo_path).name}_{branch_name}"

    # Create the worktree
    try:
        result = subprocess.run(
            ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
            cwd=repo_path,
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode != 0:
            return {"error": f"Failed to create worktree: {result.stderr}", "branch": branch_name}

        # Store worktree info in database
        try:
            worktrees = aios_db.read("worktrees_list")
        except:
            worktrees = []
        worktrees.append({
            "repo": str(repo_path),
            "branch": branch_name,
            "path": str(worktree_path),
            "created": datetime.now().isoformat()
        })
        aios_db.write("worktrees_list", worktrees)

        # Try to open terminal (different commands for different environments)
        terminal_opened = False
        terminal_commands = [
            ["gnome-terminal", "--working-directory", str(worktree_path)],
            ["xterm", "-e", f"cd {worktree_path} && bash"],
            ["konsole", "--workdir", str(worktree_path)],
            ["xfce4-terminal", "--working-directory", str(worktree_path)]
        ]

        for cmd in terminal_commands:
            try:
                subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                terminal_opened = True
                break
            except:
                continue

        return {
            "success": True,
            "branch": branch_name,
            "path": str(worktree_path),
            "terminal": terminal_opened
        }

    except Exception as e:
        return {"error": str(e)}

def list_worktrees():
    """List all worktrees"""
    try:
        result = subprocess.run(
            ["git", "worktree", "list"],
            capture_output=True,
            text=True
        )
        return result.stdout
    except:
        return "Not a git repository"

def remove_worktree(path):
    """Remove a worktree"""
    try:
        subprocess.run(["git", "worktree", "remove", path], check=True)
        return f"Removed worktree: {path}"
    except Exception as e:
        return f"Error removing worktree: {e}"

if __name__ == "__main__":
    command = sys.argv[1] if len(sys.argv) > 1 else "create"

    if command == "create":
        repo = sys.argv[2] if len(sys.argv) > 2 else None
        branch = sys.argv[3] if len(sys.argv) > 3 else None
        result = create_worktree_with_terminal(repo, branch)
        if "success" in result and result["success"]:
            print(f"Created worktree: {result['path']}")
            print(f"Branch: {result['branch']}")
            if result["terminal"]:
                print("Terminal opened in worktree")
        else:
            print(f"Error: {result.get('error', 'Unknown error')}")

    elif command == "list":
        print(list_worktrees())

    elif command == "remove":
        path = sys.argv[2] if len(sys.argv) > 2 else None
        if path:
            print(remove_worktree(path))
        else:
            print("Please specify path to remove")

services/web/web.py:
#!/usr/bin/env python3
import sys
sys.path.extend(['/home/seanpatten/projects/AIOS', '/home/seanpatten/projects/AIOS/core'])
from http.server import HTTPServer, BaseHTTPRequestHandler
import json, aios_db, subprocess, os, asyncio, websockets, pty, struct, fcntl, termios, signal
from urllib.parse import parse_qs, urlparse
from datetime import datetime
from pathlib import Path
from threading import Thread

TEMPLATE_DIR = Path(__file__).parent / 'templates'
WEB_PORT = int(sys.argv[2]) if len(sys.argv) > 2 else 8080

# Load templates
T = {}
template_files = {
    'index': 'index.html',
    'todo': 'todo.html',
    'jobs': 'jobs.html',
    'feed': 'feed.html',
    'autollm': 'autollm.html',
    'autollm_output': 'autollm_output.html',
    'terminal': 'terminal.html',
    'terminal_emulator': 'terminal-emulator.html',
    'terminal_xterm': 'terminal-xterm.html',
    'settings': 'settings.html',
    'workflow': 'workflow.html',
    'workflow_manager': 'workflow_manager.html'
}
for k, v in template_files.items():
    T[k] = (TEMPLATE_DIR / v).read_text()

class Handler(BaseHTTPRequestHandler):
    def _ctx(self):
        s = aios_db.read("settings") or {}
        c = {}
        c.update({
            'bg': {'light': '#fff'}.get(s.get('theme'), '#000'),
            'fg': {'light': '#000'}.get(s.get('theme'), '#fff'),
            'bg2': {'light': '#f0f0f0'}.get(s.get('theme'), '#1a1a1a')
        })
        return s, c

    def _get_todo_html(self, c):
        cmd = ["python3", "core/aios_runner.py", "python3", "programs/todo/todo.py", "list"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        tasks = result.stdout.strip().split('\n') if result.stdout.strip() else []

        task_html = []
        for i, t in enumerate(tasks):
            done_class = "done" if "[x]" in t else ""
            task_id = t.split(".")[0] if "." in t else str(i+1)
            html = f'''<div class="task {done_class}">{t}
                <form style="display:inline" action="/todo/done" method="POST">
                    <input type="hidden" name="id" value="{task_id}">
                    <button>Done</button>
                </form>
            </div>'''
            task_html.append(html)

        tasks_content = "".join(task_html) or '<div style="color:#888">No tasks yet</div>'
        return T['todo'].format(**c, tasks=tasks_content)

    def _get_feed_html(self, s, c):
        messages = aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp DESC LIMIT 100")

        if not messages:
            feed_content = "<div style='color:#888'>No messages yet</div>"
        else:
            seen_dates = []
            feed_items = []
            time_fmt = "12h" if s.get("time_format", "12h") == "12h" else "24h"

            for content, timestamp in messages:
                msg_date = datetime.fromisoformat(timestamp).date()

                # Add date header if new date
                if msg_date not in seen_dates:
                    seen_dates.append(msg_date)
                    date_html = f'<div style="color:#888;font-weight:bold;margin:15px 0 5px">{msg_date}</div>'
                    feed_items.append(date_html)

                # Format time
                dt = datetime.fromisoformat(timestamp)
                if time_fmt == "12h":
                    time_str = dt.strftime("%I:%M %p")
                else:
                    time_str = dt.strftime("%H:%M")

                # Add message
                msg_html = f'<div style="padding:8px;margin:2px 0">{time_str} - {content}</div>'
                feed_items.append(msg_html)

            feed_content = "".join(feed_items)

        return T['feed'].format(**c, feed_content=feed_content)

    def _get_settings_html(self, s, c):
        styles = {
            'theme_dark_style': 'style="font-weight:bold"' if s.get('theme', 'dark') == 'dark' else '',
            'theme_light_style': 'style="font-weight:bold"' if s.get('theme') == 'light' else '',
            'time_12h_style': 'style="font-weight:bold"' if s.get('time_format', '12h') == '12h' else '',
            'time_24h_style': 'style="font-weight:bold"' if s.get('time_format') == '24h' else ''
        }
        return T['settings'].format(**c, **styles)

    def _get_jobs_html(self, c):
        job_types = {'running_jobs': 'running', 'review_jobs': 'review', 'done_jobs': 'done'}
        job_data = {}

        for key, job_type in job_types.items():
            cmd = f"python3 services/jobs.py {job_type}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
            content = result.stdout.strip()
            job_data[key] = content or f'<div style="color:#888;padding:10px">No {job_type} jobs</div>'

        return T['jobs'].format(**c, **job_data)

    def _get_autollm_html(self, c):
        def format_running(w):
            branch, path, job_id, status, task, model = w
            output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
            if output_file.exists():
                output_text = output_file.read_text()[-200:]
            else:
                output_text = "Waiting for output..."

            return f'''<div class="worktree">
                <span class="status running">{branch}</span><br>
                {model}: {task[:30]}<br>
                <pre style="background:#000;padding:5px;margin:5px 0;max-height:100px;overflow-y:auto;font-size:10px">{output_text}</pre>
                <a href="/autollm/output?job_id={job_id}" style="padding:5px 10px;background:{c["fg"]};color:{c["bg"]};text-decoration:none;border-radius:3px">Full Output</a>
                <a href="/terminal?job_id={job_id}" style="padding:5px 10px;background:{c["fg"]};color:{c["bg"]};text-decoration:none;border-radius:3px;margin-left:5px">Terminal</a>
            </div>'''

        def format_review(w):
            branch, path, job_id, status, task, model, output = w
            output_preview = (output or "")[:50]
            return f'''<div class="worktree">
                <span class="status review">{branch}</span><br>
                {model}: {task[:30]}<br>
                Output: {output_preview}<br>
                <form action="/autollm/accept" method="POST" style="display:inline">
                    <input type="hidden" name="job_id" value="{job_id}">
                    <button>Accept</button>
                </form>
                <form action="/autollm/vscode" method="POST" style="display:inline">
                    <input type="hidden" name="path" value="{path}">
                    <button>VSCode</button>
                </form>
            </div>'''

        def format_done(w):
            branch = w[0]
            return f'<div class="worktree"><span class="status done">{branch}</span></div>'

        # Get worktrees
        all_worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, task, model, output FROM worktrees")

        # Filter and format
        running = [w for w in all_worktrees if len(w) > 3 and w[3] == 'running']
        review = [w for w in all_worktrees if len(w) > 3 and w[3] == 'review']
        done = [w for w in all_worktrees if len(w) > 3 and w[3] == 'done']

        worktree_data = {
            'running_worktrees': "".join([format_running(w[:6]) for w in running]) or '<div style="color:#888">No running worktrees</div>',
            'review_worktrees': "".join([format_review(w) for w in review]) or '<div style="color:#888">No review worktrees</div>',
            'done_worktrees': "".join([format_done(w) for w in done]) or '<div style="color:#888">No done worktrees</div>'
        }

        return T['autollm'].format(**c, **worktree_data)

    def _get_autollm_output(self, c, job_id):
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"

        if output_file.exists():
            output_content = output_file.read_text()
        else:
            result = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))
            output_content = result[0][0] if result else "No output yet"

        return T['autollm_output'].format(**c, output_content=output_content)

    def _get_terminal(self, c, job_id):
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
        terminal_content = output_file.read_text() if output_file.exists() else "Waiting for output..."
        return T['terminal'].format(**c, terminal_content=terminal_content, job_id=job_id)

    def _get_workflow_worktrees(self):
        cmd = ["git", "worktree", "list"]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
        lines = result.stdout.strip().split('\n') if result.stdout.strip() else []

        worktrees = []
        for line in lines:
            if line and len(line.split()) >= 3:
                parts = line.split()
                worktrees.append({
                    "path": parts[0],
                    "branch": parts[2].strip('[]')
                })

        return json.dumps(worktrees)

    def do_GET(self):
        p = urlparse(self.path)
        q = parse_qs(p.query)
        s, c = self._ctx()

        # Route handlers
        routes = {
            '/': lambda: (T['index'].format(**c), 'text/html'),
            '/api/jobs': lambda: (
                json.dumps([
                    {"id": j[0], "name": j[1], "status": j[2], "output": j[3]}
                    for j in aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")
                ]),
                'application/json'
            ),
            '/todo': lambda: (self._get_todo_html(c), 'text/html'),
            '/feed': lambda: (self._get_feed_html(s, c), 'text/html'),
            '/settings': lambda: (self._get_settings_html(s, c), 'text/html'),
            '/jobs': lambda: (self._get_jobs_html(c), 'text/html'),
            '/autollm': lambda: (self._get_autollm_html(c), 'text/html'),
            '/autollm/output': lambda: (
                self._get_autollm_output(c, q.get('job_id', [''])[0]),
                'text/html'
            ),
            '/terminal': lambda: (
                self._get_terminal(c, q.get('job_id', [''])[0]),
                'text/html'
            ),
            '/terminal-emulator': lambda: (
                T['terminal_emulator'].replace('ws://localhost:8766', f'ws://localhost:{WEB_PORT + 1000}'),
                'text/html'
            ),
            '/terminal-xterm': lambda: (
                T['terminal_xterm'].replace('ws://localhost:8766', f'ws://localhost:{WEB_PORT + 1000}'),
                'text/html'
            ),
            '/workflow': lambda: (T['workflow'].format(**c), 'text/html'),
            '/workflow-manager': lambda: (
                T['workflow_manager'].format(**c).replace('ws://localhost:8766', f'ws://localhost:{WEB_PORT + 1000}'),
                'text/html'
            ),
            '/workflow/list_worktrees': lambda: (self._get_workflow_worktrees(), 'application/json'),
            '/api/workflow/nodes': lambda: (
                json.dumps(aios_db.read("workflow_nodes") or []),
                'application/json'
            ),
            '/api/workflow/list': lambda: (
                json.dumps([str(f.relative_to('/home/seanpatten/projects/AIOS')) for f in Path('/home/seanpatten/projects/AIOS/workflows').glob('*.md')] if Path('/home/seanpatten/projects/AIOS/workflows').exists() else []),
                'application/json'
            ),
            '/api/terminal/sessions': lambda: (
                json.dumps(aios_db.read("terminal_sessions") or {}),
                'application/json'
            )
        }

        # Get handler or default to index
        handler = routes.get(p.path, lambda: (T['index'].format(**c), 'text/html'))
        content, content_type = handler()

        # Send response
        self.send_response(200)
        self.send_header('Content-type', content_type)
        self.end_headers()
        self.wfile.write(content.encode())

    def do_POST(self):
        p = urlparse(self.path).path
        content_length = int(self.headers.get('Content-Length', 0))
        b = self.rfile.read(content_length) if content_length else b''

        # Handle workflow routes
        if p.startswith('/workflow/'):
            d = json.loads(b.decode() or '{}')

            if p == '/workflow/worktree_terminal':
                cmd = ["python3", "programs/workflow/workflow.py", "worktree_terminal",
                       d.get('repo', '/home/seanpatten/projects/AIOS'), d.get('branch', '')]
                r = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                output = json.loads(r.stdout) if r.stdout else {"error": "No output"}
                self.wfile.write(json.dumps(output).encode())
                return

            if p == '/workflow/remove_worktree':
                subprocess.run(["git", "worktree", "remove", d.get('path', '')], check=True, timeout=5)
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"success":true}')
                return

            if p == '/workflow/execute':
                cmd = ["python3", "services/workflow_executor.py", "execute",
                       d.get('worktree_id', 'default'), d.get('workflow_path', '')]
                try:
                    r = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                    output = r.stdout if r.stdout else json.dumps({"status": "error", "error": "No output from workflow executor"})
                except subprocess.TimeoutExpired:
                    output = json.dumps({"status": "error", "error": "Workflow execution timed out"})
                except Exception as e:
                    output = json.dumps({"status": "error", "error": str(e)})
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(output.encode())
                return

            if p == '/workflow/open_vscode':
                path = d.get('path', '')
                subprocess.Popen(['code', path])
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"success":true}')
                return

            # Other workflow commands
            workflow_cmds = {
                '/workflow/add': f"python3 programs/workflow/workflow.py add {d.get('col', 0)} {d.get('text', '')}",
                '/workflow/expand': f"python3 programs/workflow/workflow.py expand {d.get('id', 0)} {d.get('text', '')}",
                '/workflow/branch': f"python3 programs/workflow/workflow.py branch {d.get('id', 0)}",
                '/workflow/exec': f"python3 programs/workflow/workflow.py exec {d.get('id', 0)}",
                '/workflow/push': f"python3 programs/workflow/workflow.py push {d.get('id', 0)}",
                '/workflow/term': f"python3 programs/workflow/workflow.py term {d.get('id', 0)}",
                '/workflow/comment': f"python3 programs/workflow/workflow.py comment {d.get('id', 0)} {d.get('text', '')}",
                '/workflow/save': f"python3 programs/workflow/workflow.py save {d.get('name', 'default')}",
                '/workflow/load': f"python3 programs/workflow/workflow.py load {d.get('name', 'default')}"
            }

            if p in workflow_cmds:
                subprocess.run(workflow_cmds[p], shell=True, timeout=5, capture_output=True)
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"status":"ok"}')
            return

        # Handle shutdown
        if p == '/shutdown':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            html = b'<html><body><h1>Shutting down AIOS...</h1>'
            html += b'<script>setTimeout(function(){window.close();}, 2000);</script></body></html>'
            self.wfile.write(html)

            pids = aios_db.read("aios_pids") or {}
            for pid in pids.values():
                os.kill(pid, signal.SIGTERM)
            os._exit(0)

        # Handle restart
        if p == '/restart':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            html = b'<html><body><h1>Restarting AIOS...</h1>'
            html += b'<script>setTimeout(function(){location.href="/";}, 3000);</script></body></html>'
            self.wfile.write(html)

            def restart_aios():
                __import__('time').sleep(0.5)
                subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/aios_start.py"])
                __import__('time').sleep(1)
                os._exit(0)

            Thread(target=restart_aios, daemon=True).start()
            return

        # Handle worktree creation
        if p == '/worktree/create':
            d = parse_qs(b.decode()) or {}
            cmd = ["python3", "/home/seanpatten/projects/AIOS/programs/worktree/worktree_manager.py",
                   "create", d.get('repo', [''])[0], d.get('branch', [''])[0]]
            r = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()

            if r.returncode == 0:
                output = r.stdout
            else:
                output = f"Error: {r.stderr}"

            html = f'<html><body><h2>Worktree Created</h2><pre>{output}</pre>'
            html += '<br><a href="/">Back to Control Center</a></body></html>'
            self.wfile.write(html.encode())
            return

        # Handle other commands
        d = parse_qs(b.decode()) or {}

        commands = {
            '/job/run': "python3 services/jobs.py run_wiki",
            '/job/accept': f"python3 services/jobs.py accept {d.get('id', [''])[0]}",
            '/job/redo': f"python3 services/jobs.py redo {d.get('id', [''])[0]}",
            '/run': d.get('cmd', [''])[0],
            '/todo/add': f"python3 programs/todo/todo.py add {d.get('task', [''])[0]}",
            '/todo/done': f"python3 programs/todo/todo.py done {d.get('id', [''])[0]}",
            '/todo/clear': "python3 programs/todo/todo.py clear",
            '/settings/theme': f"python3 programs/settings/settings.py set theme {d.get('theme', ['dark'])[0]}",
            '/settings/time': f"python3 programs/settings/settings.py set time_format {d.get('format', ['12h'])[0]}",
            '/autollm/run': f"python3 programs/autollm/autollm.py run {d.get('repo', [''])[0]} "
                           f"{d.get('branches', ['1'])[0]} {d.get('model', ['claude-3-5-sonnet-20241022'])[0]} "
                           f"{d.get('task', [''])[0]}",
            '/autollm/accept': f"python3 programs/autollm/autollm.py accept {d.get('job_id', [''])[0]}",
            '/autollm/vscode': f"code {d.get('path', [''])[0]}",
            '/autollm/clean': "python3 programs/autollm/autollm.py clean"
        }

        if p in commands:
            subprocess.run(commands[p], shell=True, timeout=5, capture_output=True)

        # Redirect based on path
        if 'autollm' in p:
            redirect = '/autollm'
        elif 'settings' in p:
            redirect = '/settings'
        else:
            redirect = p.replace('/add', '').replace('/done', '').replace('/clear', '')

        self.send_response(303)
        self.send_header('Location', redirect)
        self.end_headers()

    def log_message(self, *args):
        pass

# Global persistent terminal sessions
_terminal_sessions = {}

def get_or_create_terminal(worktree_id, worktree_path):
    if worktree_id not in _terminal_sessions:
        master, slave = pty.openpty()
        fcntl.ioctl(slave, termios.TIOCSWINSZ, struct.pack('HHHH', 24, 80, 0, 0))

        pid = os.fork()
        if pid == 0:
            os.setsid()
            os.dup2(slave, 0)
            os.dup2(slave, 1)
            os.dup2(slave, 2)
            os.close(master)
            os.close(slave)
            os.chdir(worktree_path)
            os.execv('/bin/bash', ['bash'])

        os.close(slave)
        os.set_blocking(master, False)
        _terminal_sessions[worktree_id] = {"master": master, "pid": pid, "path": worktree_path}

        sessions = aios_db.read("terminal_sessions") or {}
        sessions[worktree_id] = {"pid": pid, "path": worktree_path, "created": __import__('time').time()}
        aios_db.write("terminal_sessions", sessions)

    return _terminal_sessions[worktree_id]["master"]

async def client_handler(ws):
    worktree_id, master = None, None

    try:
        init_msg = await asyncio.wait_for(ws.recv(), timeout=5.0)
        if isinstance(init_msg, bytes):
            try:
                init_data = json.loads(init_msg.decode())
                worktree_id = init_data.get('worktree_id', 'default')
            except:
                worktree_id = 'default'

        sessions = aios_db.read("terminal_sessions") or {}
        wt_path = sessions.get(worktree_id, {}).get('path', '/home/seanpatten/projects/AIOS')
        master = get_or_create_terminal(worktree_id, wt_path)

        loop = asyncio.get_event_loop()

        def read_and_send():
            try:
                data = os.read(master, 65536)
                if data:
                    asyncio.create_task(ws.send(data))
            except:
                pass

        loop.add_reader(master, read_and_send)

        async for msg in ws:
            if isinstance(msg, bytes):
                if msg[0:1] == b'{':
                    try:
                        d = json.loads(msg.decode())
                        if 'resize' in d:
                            rows, cols = d['resize']['rows'], d['resize']['cols']
                            fcntl.ioctl(master, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))
                    except:
                        os.write(master, msg)
                else:
                    os.write(master, msg)
    finally:
        if master:
            try:
                loop.remove_reader(master)
            except:
                pass

def serve_http(sock=None):
    s = HTTPServer(('', WEB_PORT), Handler, bind_and_activate=(sock is None))
    s.socket = sock if sock else s.socket
    s.serve_forever()

async def main():
    import socket

    # Get socket from parent if provided
    if len(sys.argv) > 1:
        sock = socket.fromfd(int(sys.argv[1]), socket.AF_INET, socket.SOCK_STREAM)
    else:
        sock = None

    # Start HTTP server in thread
    Thread(target=serve_http, args=(sock,), daemon=True).start()

    # Start WebSocket server
    ws_port = WEB_PORT + 1000
    try:
        async with websockets.serve(client_handler, 'localhost', ws_port):
            await asyncio.Future()
    except OSError:
        # Try alternate port if primary is busy
        async with websockets.serve(client_handler, 'localhost', WEB_PORT + 2000):
            await asyncio.Future()

asyncio.run(main())

README.md:
# AIOS - AI Operating System

## Core Commands
- `aios start` - launch web interface
- `aios stop` - shutdown system
- `aios status` - show processes
- `aios <cmd>` - run any command

## Testing

### Automated Testing
```bash
# Test all programs automatically
python3 testing/test_programs.py

# Test programs with sample output for verification
python3 testing/test_with_examples.py

# Test web interface with Playwright
python3 testing/playwright/test_all.py

# Test interactions
python3 testing/playwright/test_interactions.py
```

### Individual Program Testing
```bash
# Todo Manager
python3 programs/todo/todo.py list
python3 programs/todo/todo.py add "New task"
python3 programs/todo/todo.py done 1
python3 programs/todo/todo.py clear

# Services
python3 services/service.py list
python3 services/service.py start service_name
python3 services/service.py stop service_name
python3 services/service.py status

# Feed Messages
python3 services/feed.py list
python3 services/feed.py add "Message text"
python3 services/feed.py view
python3 services/feed.py clear

# Jobs
python3 services/jobs.py list
python3 services/jobs.py summary
python3 services/jobs.py running
python3 services/jobs.py review
python3 services/jobs.py done

# Processes
python3 services/processes.py json
python3 services/processes.py list
python3 services/processes.py start script.py
python3 services/processes.py stop script.py

# Settings
python3 programs/settings/settings.py get theme
python3 programs/settings/settings.py set theme light
python3 programs/settings/settings.py set time_format 24h

# AutoLLM
python3 programs/autollm/autollm.py status
python3 programs/autollm/autollm.py run /path/to/repo 1 model "task"
python3 programs/autollm/autollm.py clean
python3 programs/autollm/autollm.py output job_id
python3 programs/autollm/autollm.py accept job_id

# Workflow
python3 programs/workflow/workflow.py list
python3 programs/workflow/workflow.py add 0 "Task text"
python3 programs/workflow/workflow.py expand node_id "instruction"
python3 programs/workflow/workflow.py branch node_id
python3 programs/workflow/workflow.py exec node_id

# Worktree Manager
python3 programs/worktree/worktree_manager.py list
python3 programs/worktree/worktree_manager.py create /repo/path branch_name
python3 programs/worktree/worktree_manager.py remove /worktree/path
```

## Context Generation
```bash
# Generate project context (excludes testing folder)
python3 -c "from services import context_generator; context_generator.generate()"

# Files created:
# - projectContext.txt (production code only)
# - projectContextWithTests.txt (includes testing code)
```
testing/test_programs.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
from datetime import datetime

sys.path.append('/home/seanpatten/projects/AIOS')

test_configs = {
    "programs/todo/todo.py": ["list", "add 'Test task'", "list"],
    "services/service.py": ["list", "status"],
    "services/feed.py": ["list", "add 'Test message'", "view"],
    "services/scraper.py": [],
    "services/backup.py": [],
    "services/context_generator.py": [],
    "services/processes.py": ["json", "list"],
    "services/jobs.py": ["list", "summary"],
    "programs/ranker/ranker.py": ["list", "add 'Test idea'", "rank"],
    "programs/planner/planner.py": [],
    "programs/job_status.py": ["summary"],
    "programs/settings/settings.py": ["get theme", "set test_key test_value", "get test_key"],
    "programs/wiki_fetcher/wiki_fetcher.py": [],
    "programs/builder/builder.py": [],
    "programs/schedule/scheduler.py": [],
    "programs/autollm/autollm.py": ["status"],
    "programs/autollm/monitor.py": [],
    "programs/workflow/workflow.py": ["list"],
    "programs/worktree/worktree_manager.py": ["list"],
    "aios_start.py": ["status"],
    "core/aios_runner.py": ["echo 'test'"]
}

def run_test(script, commands):
    print(f"\n{'='*60}")
    print(f"Testing: {script}")
    print('='*60)

    results = []
    for cmd in commands:
        full_cmd = f"python3 {script} {cmd}"
        print(f"\n> {full_cmd}")
        print('-'*40)

        result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True, timeout=2)
        output = result.stdout or result.stderr or "(no output)"
        print(output[:500])
        results.append(result.returncode == 0)

    return all(results) if results else True

def main():
    root = Path('/home/seanpatten/projects/AIOS')
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    print("="*70)
    print("   MANUAL VERIFICATION REQUIRED")
    print("="*70)
    print(" This test runs programs but DOES NOT verify output correctness.")
    print(" A human or LLM must manually inspect each output to confirm:")
    print("   - Output format is correct")
    print("   - Data is properly displayed")
    print("   - Commands produce expected results")
    print("="*70)
    print()

    print(f"AIOS Program Test Suite - {timestamp}")
    print("="*60)

    passed, failed, skipped = 0, 0, 0

    for script, commands in test_configs.items():
        script_path = root / script

        if not script_path.exists():
            print(f"\n SKIPPED: {script} (not found)")
            skipped += 1
            continue

        if not commands:
            print(f"\n SKIPPED: {script} (no test commands)")
            skipped += 1
            continue

        success = run_test(script_path, commands)
        if success:
            print(f" PASSED")
            passed += 1
        else:
            print(f" FAILED")
            failed += 1

    print(f"\n{'='*60}")
    print(f"Results: {passed} passed, {failed} failed, {skipped} skipped")
    print('='*60)
    print("\n  REMEMBER: 'Passed' only means no errors occurred.")
    print("   Manual inspection of outputs above is required to confirm correctness!")

if __name__ == "__main__":
    main()

testing/test_with_examples.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path

sys.path.append('/home/seanpatten/projects/AIOS')

examples = [
    {
        "name": "Todo Manager",
        "commands": [
            ("python3 programs/todo/todo.py list", "Shows list of tasks with numbers"),
            ("python3 programs/todo/todo.py add 'Example task'", "Adds a new task"),
            ("python3 programs/todo/todo.py done 1", "Marks task 1 as done"),
            ("python3 programs/todo/todo.py clear", "Removes completed tasks")
        ]
    },
    {
        "name": "Services",
        "commands": [
            ("python3 services/service.py list", "Lists all services and status"),
            ("python3 services/service.py start myapp", "Starts service 'myapp'"),
            ("python3 services/service.py stop myapp", "Stops service 'myapp'"),
            ("python3 services/service.py status myapp", "Shows status of 'myapp'")
        ]
    },
    {
        "name": "Feed/Messages",
        "commands": [
            ("python3 services/feed.py list", "Lists recent messages"),
            ("python3 services/feed.py add 'System update complete'", "Adds a message"),
            ("python3 services/feed.py clear", "Clears old messages (>7 days)")
        ]
    },
    {
        "name": "Jobs",
        "commands": [
            ("python3 services/jobs.py summary", "Shows job summary"),
            ("python3 services/jobs.py list", "Lists all jobs with status"),
            ("python3 services/jobs.py running", "Shows running jobs (HTML)"),
            ("python3 services/jobs.py accept 1", "Accepts job with ID 1")
        ]
    },
    {
        "name": "Processes",
        "commands": [
            ("python3 services/processes.py json", "Outputs process info as JSON"),
            ("python3 services/processes.py list", "Lists scheduled/ongoing/core processes")
        ]
    },
    {
        "name": "AIOS Control",
        "commands": [
            ("python3 aios_start.py status", "Shows AIOS PIDs"),
            ("python3 aios_start.py start", "Starts AIOS web interface"),
            ("python3 aios_start.py stop", "Stops AIOS")
        ]
    }
]

def test_example(example):
    print(f"\n{'='*70}")
    print(f" {example['name']}")
    print('='*70)

    for cmd, description in example['commands']:
        print(f"\nCommand: {cmd}")
        print(f"Purpose: {description}")
        print('-'*50)

        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=2)
        output = result.stdout or result.stderr or "(no output)"

        lines = output.strip().split('\n')[:5]
        for line in lines:
            print(f"  {line[:80]}")

        if len(output.strip().split('\n')) > 5:
            print("  ...")

        status = "" if result.returncode == 0 else ""
        print(f"Status: {status}")

def main():
    print("=" * 70)
    print("   MANUAL VERIFICATION REQUIRED")
    print("=" * 70)
    print(" This test shows command outputs but DOES NOT verify correctness.")
    print(" A human or LLM must manually review each output to confirm:")
    print("   - Output matches expected format")
    print("   - Data values are reasonable")
    print("   - Commands behave as documented")
    print("=" * 70)
    print()
    print(" AIOS Testing Guide - Sample Commands and Expected Output")
    print("=" * 70)
    print("\nThis shows what each command does and sample output.")
    print("Verify outputs match expected behavior.\n")

    for example in examples:
        test_example(example)

    print(f"\n{'='*70}")
    print(" Testing Complete - Review outputs above for correctness")
    print('='*70)
    print("\n  IMPORTANT: Status  only means no errors - verify output is correct!")

if __name__ == "__main__":
    main()

testing/playwright/test_workflow_manager.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent.parent / 'core'))
import aios_db
from playwright.sync_api import sync_playwright, expect

def test_workflow_manager():
    # Get port from database
    ports = aios_db.read("ports")
    port = ports.get("web", 8080)
    base_url = f"http://localhost:{port}"

    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()

        # Navigate to workflow manager
        page.goto(f"{base_url}/workflow-manager")
        page.wait_for_load_state("networkidle")

        # Take screenshot
        page.screenshot(path="testing/screenshots/workflow_manager_initial.png")

        # Check if workflow manager loaded
        page.wait_for_selector("h1", timeout=5000)
        title = page.locator("h1").text_content()
        assert "Workflow" in title, f"Expected 'Workflow' in title, got: {title}"

        # Check if workflow select is visible
        page.wait_for_selector("#workflow-select", timeout=5000)

        # Check if terminal container exists
        page.wait_for_selector("#terminal", timeout=5000)

        # Take final screenshot
        page.screenshot(path="testing/screenshots/workflow_manager_loaded.png")

        browser.close()

    print(" Workflow manager test passed!")

if __name__ == "__main__":
    test_workflow_manager()


testing/playwright/test_workflow_execution.py:
#!/usr/bin/env python3
import sys, time
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent.parent / 'core'))
import aios_db
from playwright.sync_api import sync_playwright

def test_workflow_execution():
    ports = aios_db.read("ports")
    port = ports.get("web", 8080)
    base_url = f"http://localhost:{port}"

    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        page.goto(f"{base_url}/workflow-manager")
        page.wait_for_load_state("networkidle")

        # Scroll down to see workflow section
        page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
        time.sleep(1)
        page.screenshot(path="testing/screenshots/workflow_section.png")

        # Check if workflow select exists
        page.wait_for_selector("#workflow-select", timeout=5000)

        # Get workflow options
        options = page.locator("#workflow-select option").all_text_contents()
        print(f"Available workflows: {options}")

        # Check if prime_factorization workflow is available
        if any('prime' in opt.lower() for opt in options):
            print(" Prime factorization workflow found!")

            # Select the workflow
            page.select_option("#workflow-select", label=[opt for opt in options if 'prime' in opt.lower()][0])
            time.sleep(0.5)
            page.screenshot(path="testing/screenshots/workflow_selected.png")

            print(" Workflow selected successfully!")
        else:
            print(f" Prime factorization workflow not found in: {options}")

        # Check Terminal and VSCode buttons work
        terminal_buttons = page.locator("button:has-text('Terminal')").count()
        vscode_buttons = page.locator("button:has-text('VSCode')").count()
        print(f"Found {terminal_buttons} Terminal buttons and {vscode_buttons} VSCode buttons")

        browser.close()

    print(" Workflow execution test completed!")

if __name__ == "__main__":
    test_workflow_execution()


testing/playwright/test_all.py:
#!/usr/bin/env python3
import asyncio
from playwright.async_api import async_playwright
from pathlib import Path
from datetime import datetime
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db

screenshot_dir = Path(__file__).parent / "screenshots"
screenshot_dir.mkdir(exist_ok=True)

async def test_all():
    print("="*70)
    print("   MANUAL INSPECTION REQUIRED")
    print("="*70)
    print(" This test captures screenshots but DOES NOT verify correctness.")
    print(" A human or LLM must manually inspect each screenshot to confirm:")
    print("   - UI elements are rendered correctly")
    print("   - No visual bugs or layout issues")
    print("   - All expected components are visible")
    print("="*70)
    print()

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page(viewport={'width': 1280, 'height': 720})

        port = aios_db.read('ports')['web']
        base = f"http://localhost:{port}"
        timestamp = datetime.now().strftime("%H%M%S")

        pages = [
            "index", "todo", "feed", "jobs", "settings",
            "autollm", "workflow", "workflow-manager",
            "terminal-emulator", "terminal-xterm"
        ]

        results = []
        for name in pages:
            url = f"{base}/" + ("" if name == "index" else name)
            await page.goto(url)
            await page.wait_for_timeout(500)
            path = screenshot_dir / f"{name}_{timestamp}.png"
            await page.screenshot(path=str(path))
            results.append(path.exists())
            print(f" {name}")

        await browser.close()
        print(f"\nSaved {sum(results)}/{len(pages)} screenshots to {screenshot_dir}")
        print("\n" + "="*70)
        print("   IMPORTANT: Manually inspect all screenshots to verify correctness")
        print("="*70)

asyncio.run(test_all())

testing/playwright/test_js.py:
#!/usr/bin/env python3
import asyncio
from playwright.async_api import async_playwright
from pathlib import Path
from datetime import datetime

screenshot_dir = Path(__file__).parent / "screenshots"
screenshot_dir.mkdir(exist_ok=True)

async def test_page(page, name, url, actions=None):
    await page.goto(url)
    await page.wait_for_load_state("networkidle")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    await page.screenshot(path=str(screenshot_dir / f"{name}_{timestamp}.png"))
    actions and await actions(page)

async def run_tests():
    print("="*70)
    print("   MANUAL INSPECTION REQUIRED")
    print("="*70)
    print(" This test captures page screenshots but DOES NOT verify:")
    print("   - JavaScript functions work correctly")
    print("   - Page content is accurate")
    print("   - All features are operational")
    print(" Screenshots must be manually reviewed for correctness.")
    print("="*70)
    print()

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        context = await browser.new_context(viewport={'width': 1280, 'height': 720})
        page = await context.new_page()

        import sys
        sys.path.append('/home/seanpatten/projects/AIOS')
        from core import aios_db
        port = aios_db.read('ports')['web']
        base_url = f"http://localhost:{port}"

        tests = [
            ("index", f"{base_url}/"),
            ("todo", f"{base_url}/todo"),
            ("feed", f"{base_url}/feed"),
            ("jobs", f"{base_url}/jobs"),
            ("settings", f"{base_url}/settings"),
            ("autollm", f"{base_url}/autollm"),
            ("workflow", f"{base_url}/workflow"),
            ("workflow_manager", f"{base_url}/workflow-manager"),
            ("terminal_emulator", f"{base_url}/terminal-emulator"),
            ("terminal_xterm", f"{base_url}/terminal-xterm")
        ]

        [await test_page(page, name, url) for name, url in tests]

        await browser.close()
        print(f"Screenshots saved to {screenshot_dir}")

asyncio.run(run_tests())

testing/playwright/test_interactions.py:
#!/usr/bin/env python3
import asyncio
from playwright.async_api import async_playwright
from pathlib import Path
from datetime import datetime

screenshot_dir = Path(__file__).parent / "screenshots"
screenshot_dir.mkdir(exist_ok=True)

async def screenshot(page, name):
    timestamp = datetime.now().strftime("%H%M%S")
    await page.screenshot(path=str(screenshot_dir / f"{name}_{timestamp}.png"))

async def test_interactions():
    print("="*70)
    print("   MANUAL INSPECTION REQUIRED")
    print("="*70)
    print(" This test captures interaction screenshots but DOES NOT verify:")
    print("   - Forms submit correctly")
    print("   - Data is saved properly")
    print("   - UI responds as expected")
    print(" Screenshots must be manually reviewed for correctness.")
    print("="*70)
    print()

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page(viewport={'width': 1280, 'height': 720})

        import sys
        sys.path.append('/home/seanpatten/projects/AIOS')
        from core import aios_db
        port = aios_db.read('ports')['web']
        base = f"http://localhost:{port}"

        await page.goto(f"{base}/")
        await screenshot(page, "home")

        await page.goto(f"{base}/todo")
        await screenshot(page, "todo_page")
        await page.fill('input[name="task"]', "Test Task")
        await page.press('input[name="task"]', "Enter")
        await page.wait_for_timeout(500)
        await screenshot(page, "todo_added")

        await page.goto(f"{base}/settings")
        await screenshot(page, "settings_page")
        (await page.click('button:has-text("Light")', timeout=2000)) or None
        await page.wait_for_timeout(500)
        await screenshot(page, "settings_light")

        await page.goto(f"{base}/workflow")
        await screenshot(page, "workflow_page")

        await page.goto(f"{base}/workflow-manager")
        await screenshot(page, "workflow_manager")

        await browser.close()
        print(f"Done: {len(list(screenshot_dir.glob('*.png')))} screenshots")

asyncio.run(test_interactions())
