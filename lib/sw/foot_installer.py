#!/usr/bin/env python3
"""Foot Installer - builds lowest-latency Wayland terminal from source.

Builds latest foot from Codeberg. Installs as 'foot-source' alongside
any system version so both can coexist.
  - Binary: /usr/local/bin/foot-source
  - Uses pixman (CPU rendering), no GPU pipeline, no vsync gate
  - tllist and fcft built automatically as meson subprojects
"""
import subprocess, os, shutil, sys, re
from pathlib import Path

BUILD_DIR = Path.home() / "foot-build"
INSTALL_PREFIX = "/usr/local"
BIN_PATH = f"{INSTALL_PREFIX}/bin/foot"
DESKTOP_FILE = f"{INSTALL_PREFIX}/share/applications/foot-source.desktop"

# clang perf-max: O3 + native + LTO + no safety overhead (terminal, not a server)
CFLAGS = "-O3 -march=native -mtune=native -flto -fomit-frame-pointer -fno-stack-protector -fno-common -fvisibility=hidden -ffast-math"
LDFLAGS = "-flto -fuse-ld=lld -Wl,-O2 -Wl,--as-needed -Wl,--gc-sections"

def _system_path():
    """Return PATH with system dirs first, avoiding conda/micromamba linker conflicts."""
    sys_dirs = ["/usr/local/sbin", "/usr/local/bin", "/usr/sbin", "/usr/bin", "/sbin", "/bin"]
    for p in os.environ.get("PATH", "").split(":"):
        if p and p not in sys_dirs:
            sys_dirs.append(p)
    return ":".join(sys_dirs)

def run(cmd, cwd=None, check=True, system_linker=False):
    print(f">>> {cmd}")
    env = None
    inp = None
    if cmd.strip().startswith("sudo ") and (pw := os.environ.get("SUDO_PW")):
        cmd = cmd.replace("sudo ", "sudo -S ", 1)
        inp = pw
    if system_linker:
        env = {**os.environ, "PATH": _system_path(), "CC": "clang", "CFLAGS": CFLAGS, "LDFLAGS": LDFLAGS}
    return subprocess.run(cmd, shell=True, cwd=cwd, check=check, input=inp, text=True if inp else None, env=env)

def get_version():
    r = subprocess.run(f"{BIN_PATH} --version", shell=True, capture_output=True, text=True)
    m = re.search(r'foot version: ([\d.]+)', r.stdout)
    return m.group(1) if m else None

def setup_config():
    """Create foot config with sane defaults if not present."""
    config_dir = Path.home() / ".config/foot"
    config_file = config_dir / "foot.ini"
    if config_file.exists():
        # Ensure font size is set (don't overwrite user config)
        content = config_file.read_text()
        if "\nfont=" not in content and "\nfont =" not in content:
            # No font line — add one after the [main] section header or at top
            content = "font=monospace:size=14\n" + content
            config_file.write_text(content)
            print("Updated font size in existing config")
        return
    config_dir.mkdir(parents=True, exist_ok=True)
    # Match system monospace font from gsettings, fall back to size 14
    font = "monospace"
    size = 14
    try:
        r = subprocess.run("gsettings get org.gnome.desktop.interface monospace-font-name",
                          shell=True, capture_output=True, text=True)
        if r.returncode == 0:
            parts = r.stdout.strip().strip("'").rsplit(" ", 1)
            if len(parts) == 2:
                font, size = parts[0], int(parts[1])
                # Bump up a bit — foot renders slightly smaller than GTK at same pt size
                size = max(size, 14)
    except Exception:
        pass
    config_file.write_text(f"""# foot config — auto-generated by foot_installer.py
font={font}:size={size}
pad=4x4
""")
    print(f"Created config: font={font}:size={size}")

def setup_desktop():
    """Install desktop file so GNOME search finds it."""
    src_desktop = BUILD_DIR / "foot.desktop"
    if not src_desktop.exists():
        # foot generates .desktop during build
        src_desktop = BUILD_DIR / "build/foot.desktop"
    if not src_desktop.exists():
        print("Desktop file not found in source tree"); return False
    content = src_desktop.read_text()
    content = re.sub(r'^Name=foot$', 'Name=foot (Source)', content, flags=re.MULTILINE, count=1)
    content = re.sub(r'Exec=foot', f'Exec={BIN_PATH}', content)
    tmp = Path("/tmp/foot-source.desktop")
    tmp.write_text(content)
    run(f"sudo cp {tmp} {DESKTOP_FILE}")
    run("sudo update-desktop-database /usr/local/share/applications", check=False)
    return True

def try_incremental():
    """Try incremental build. Returns True if successful, False to trigger full build."""
    if not (BUILD_DIR / ".git").exists() or not (BUILD_DIR / "build").exists():
        return False
    print("=== Trying incremental build ===\n")
    try:
        run("git fetch --depth 1 origin", cwd=BUILD_DIR)
        run("git fetch --tags --force", cwd=BUILD_DIR)
        r = subprocess.run("git tag -l '*.*.*' --sort=-version:refname | head -1", shell=True, cwd=BUILD_DIR, capture_output=True, text=True)
        latest_tag = r.stdout.strip()
        if not latest_tag:
            return False
        current = subprocess.run("git describe --tags --exact-match HEAD 2>/dev/null", shell=True, cwd=BUILD_DIR, capture_output=True, text=True)
        if current.stdout.strip() == latest_tag:
            print(f"Already at {latest_tag}.")
            if not Path(DESKTOP_FILE).exists(): setup_desktop()
            return True
        print(f"Updating to {latest_tag}...")
        run(f"git checkout {latest_tag}", cwd=BUILD_DIR)
        run("ninja -C build", cwd=BUILD_DIR, system_linker=True)
        run("sudo ninja -C build install", cwd=BUILD_DIR)
        setup_desktop()
        return True
    except Exception as e:
        print(f"Incremental build failed: {e}\nFalling back to full build...\n")
        return False

def install():
    print("=== Foot (Source) Installer ===\n")
    # Try incremental first
    if try_incremental():
        setup_config()
        if v := get_version(): print(f"\n✓ Updated: foot {v}"); return True
    # Dependencies
    if shutil.which("apt"):
        run("sudo apt update", check=False)
        run("sudo apt install -y meson ninja-build gcc libpixman-1-dev libwayland-dev wayland-protocols libxkbcommon-dev libfontconfig-dev libfreetype-dev libutf8proc-dev libsystemd-dev scdoc git")
    elif shutil.which("dnf"):
        run("sudo dnf install -y meson ninja-build gcc pixman-devel wayland-devel wayland-protocols-devel libxkbcommon-devel fontconfig-devel freetype-devel utf8proc-devel systemd-devel scdoc git")
    elif shutil.which("pacman"):
        run("sudo pacman -S --noconfirm meson ninja gcc pixman wayland wayland-protocols libxkbcommon fontconfig freetype2 libutf8proc scdoc git")
    else:
        print("Unknown package manager"); return False
    # Full clean build
    if BUILD_DIR.exists():
        shutil.rmtree(BUILD_DIR)
    run(f"git clone https://codeberg.org/dnkl/foot.git {BUILD_DIR}")
    # Checkout latest release tag
    r = subprocess.run("git tag -l '*.*.*' --sort=-version:refname | head -1", shell=True, cwd=BUILD_DIR, capture_output=True, text=True)
    latest_tag = r.stdout.strip()
    if latest_tag:
        print(f"Building {latest_tag}...")
        run(f"git checkout {latest_tag}", cwd=BUILD_DIR)
    run(f"meson setup build --buildtype=release --prefix={INSTALL_PREFIX}", cwd=BUILD_DIR, system_linker=True)
    run("ninja -C build", cwd=BUILD_DIR, system_linker=True)
    run("sudo ninja -C build install", cwd=BUILD_DIR)
    setup_desktop()
    setup_config()
    # Verify
    if v := get_version():
        print(f"\n✓ Installed: foot {v}")
        print(f"  Binary: {BIN_PATH}")
        print(f"  Desktop: foot (Source)")
        return True
    print("✗ Installation failed"); return False

if __name__ == "__main__":
    cmd = sys.argv[1] if len(sys.argv) > 1 else "status"
    if cmd == "install": sys.exit(0 if install() else 1)
    elif cmd in ("-h", "--help", "help"): print(f"Usage: {sys.argv[0]} [install|status]")
    else: print(f"Foot (Source): {get_version() or 'not installed'}\n  Binary: {BIN_PATH}\n\nCommands: install, status")
