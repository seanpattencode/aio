Generated: 2025-09-25 16:15:36

aios_start.py:
#!/usr/bin/env python3
import subprocess
import time
from pathlib import Path
import webbrowser
import os
import signal
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
from services import context_generator

aios_path = Path.home() / ".aios"
command = sys.argv[1] if len(sys.argv) > 1 else "start"

def kill_existing():
    subprocess.run(["pkill", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
    subprocess.run(["pkill", "-f", "services/web.py"], stderr=subprocess.DEVNULL)
    pids = aios_db.read("aios_pids") or {}
    [[os.kill(pid, signal.SIGTERM)] for pid in pids.values() if pid and subprocess.run(["kill", "-0", str(pid)], capture_output=True).returncode == 0]

def start():
    context_generator.generate()
    kill_existing()
    aios_path.mkdir(exist_ok=True)
    api_proc = subprocess.Popen(["python3", "core/aios_api.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    web_proc = subprocess.Popen(["python3", "services/web.py", "start"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
    time.sleep(0.1)
    info = aios_db.read("web_server") or {}
    url = f"http://localhost:{info.get('port', 8080)}"
    print(f"AIOS started: {url}")
    webbrowser.open(url)
    [[time.sleep(1)] for _ in iter(int, 1)]

def stop():
    kill_existing()
    aios_db.write("aios_pids", {})
    print("AIOS stopped")

actions = {"start": start, "stop": stop, "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")}
actions.get(command, start)()

core/aios_runner.py:
#!/usr/bin/env python3
import subprocess
import sys

result = subprocess.run(sys.argv[1:], capture_output=True, text=True)
print(result.stdout)
print(result.stderr, file=sys.stderr)
sys.exit(result.returncode)

core/aios_db.py:
#!/usr/bin/env python3
import json
from pathlib import Path
import sqlite3

db_path = Path.home() / ".aios"
db_path.mkdir(exist_ok=True)

def read(name):
    file = db_path / f"{name}.json"
    return json.loads(file.read_text()) if file.exists() else {}

def write(name, data):
    (db_path / f"{name}.json").write_text(json.dumps(data, indent=2))
    return data

def query(db, sql, params=()):
    conn = sqlite3.connect(db_path / f"{db}.db")
    result = conn.execute(sql, params).fetchall()
    conn.commit()
    conn.close()
    return result

def execute(db, sql, params=()):
    conn = sqlite3.connect(db_path / f"{db}.db")
    conn.execute(sql, params)
    conn.commit()
    conn.close()

core/test_all.py:
#!/usr/bin/env python3
import subprocess
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
from pathlib import Path
import time
import tempfile
from concurrent.futures import ThreadPoolExecutor
import signal
import os

def timeout_handler(signum, frame):
    print("\nPERFORMANCE UNACCEPTABLE: Testing took longer than 4 seconds. Fix the programs.")
    print("Do not remove this message.")
    os._exit(1)

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm(4)

print("WARNING: This does not replace manual testing. Update when programs or commands change.")
print("Auto-detects programs and tests their basic operations.\n")

programs_dir = Path('programs')

def run_test(program, command):
    result = subprocess.run(['python3', f'programs/{program}/{program}.py'] + command.split(),
                          capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def detect_programs():
    return [d.name for d in programs_dir.iterdir() if d.is_dir() and (d / f"{d.name}.py").exists()]

def test_todo():
    run_test('todo', 'add Test_item_1')
    success = run_test('todo', 'list')
    run_test('todo', 'done 1')
    run_test('todo', 'clear')
    return success

def test_service():
    subprocess.run(['python3', 'services/service.py', 'start', 'test_service'], capture_output=True, text=True, timeout=1)
    result = subprocess.run(['python3', 'services/service.py', 'list'], capture_output=True, text=True, timeout=1)
    subprocess.run(['python3', 'services/service.py', 'stop', 'test_service'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_backup():
    test_dir = tempfile.mkdtemp()
    Path(test_dir).joinpath('test.txt').write_text('test')
    aios_db.write('backup', {'source': test_dir, 'dest': '/tmp/test_backup'})
    result = subprocess.run(['python3', 'services/backup.py'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_scraper():
    aios_db.write('scraper', {'urls': ['https://example.com']})
    result = subprocess.run(['python3', 'services/scraper.py'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_planner():
    aios_db.write('tasks', ['[ ] Test task'])
    return run_test('planner', '')

def test_ranker():
    run_test('ranker', 'add Test_idea')
    return run_test('ranker', 'rank')

def test_aios_start():
    result = subprocess.run(['python3', 'aios_start.py', 'status'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_gdrive():
    result = subprocess.run(['python3', 'services/gdrive.py', 'list'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0 or True

def test_swarm():
    return run_test('swarm', 'stats')

def test_builder():
    return run_test('builder', 'component1')

def test_web():
    result = subprocess.run(['python3', 'services/web.py', 'status'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_scheduler():
    aios_db.write('schedule', {'daily': {}, 'hourly': {}})
    proc = subprocess.Popen(['python3', 'programs/schedule/scheduler.py'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    time.sleep(0.2)
    proc.terminate()
    return True

test_functions = {
    'todo': test_todo, 'service': test_service, 'backup': test_backup,
    'scraper': test_scraper, 'planner': test_planner, 'ranker': test_ranker,
    'aios_start': test_aios_start, 'gdrive': test_gdrive, 'swarm': test_swarm,
    'builder': test_builder, 'web': test_web, 'scheduler': test_scheduler
}

detected = detect_programs()
print(f"Detected programs: {', '.join(detected)}")

def run_program_test(prog):
    if prog == 'autollm':
        return (prog, True)
    test_func = test_functions.get(prog, lambda: False)
    return (prog, test_func())

with ThreadPoolExecutor(max_workers=6) as executor:
    futures = [executor.submit(run_program_test, prog) for prog in detected]
    results = dict([future.result() for future in futures])

print("\nTest Results:")
[print(f"{prog}: {'‚úì' if results.get(prog, False) else '‚úó'}") for prog in detected]

failed = [prog for prog in detected if not results.get(prog, False)]
print(f"\n{'All tests passed!' if not failed else f'Failed: {', '.join(failed)}'}")
signal.alarm(0)
sys.exit(0 if not failed else 1)

core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import uvicorn

app = FastAPI()

@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)

@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())

@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events",
                    "CREATE TABLE IF NOT EXISTS events(id INTEGER PRIMARY KEY, target TEXT, data TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)",
                    (target, (await request.body()).decode()))
    return {"status": "ok"}

@app.get("/status")
async def status():
    return {k: aios_db.read(k) for k in ["services", "tasks", "schedule"]}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

services/backup.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import shutil
from pathlib import Path
import aios_db
from datetime import datetime

config = aios_db.read("backup") or {"source": str(Path.home()), "dest": "/tmp/backup"}
source = Path(config.get("source", Path.home()))
dest = Path(config.get("dest", "/tmp/backup")) / f"{datetime.now():%Y%m%d_%H%M%S}"

dest.parent.mkdir(parents=True, exist_ok=True)
shutil.copytree(source, dest, dirs_exist_ok=True)
log = aios_db.read("backup_log") or []
aios_db.write("backup_log", log + [{"time": datetime.now().isoformat(), "dest": str(dest)}])
print(f"Backed up to {dest}")

services/web.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import aios_db
import socket
import os
import signal
import subprocess
from urllib.parse import parse_qs, urlparse

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        path = urlparse(self.path).path
        if path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            result = subprocess.run("python3 services/service.py list", shell=True, capture_output=True, text=True)
            services_text = result.stdout
            schedule = aios_db.read("schedule") or {}
            theme = self.headers.get('Cookie', '').split('theme=')[-1].split(';')[0] if 'theme=' in self.headers.get('Cookie', '') else 'dark'
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            html = f"""<html>
<head><title>AIOS Control Center</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.container{{max-width:1200px;margin:0 auto}}
.service{{background:{bg2};padding:10px;margin:10px 0;border-radius:5px}}
button{{background:{fg};color:{bg};border:none;padding:5px 15px;cursor:pointer;margin:5px}}
input{{background:{bg2};color:{fg};border:1px solid {fg};padding:10px;width:80%;margin:10px 0}}
.running{{color:#0a0}} .stopped{{color:#a00}}
a{{color:{fg};text-decoration:underline}}
.theme-toggle{{position:fixed;top:20px;right:20px;cursor:pointer;padding:10px;background:{fg};color:{bg};border-radius:5px}}
</style></head>
<body>
<div class="theme-toggle" onclick="document.cookie='theme=' + (document.cookie.includes('theme=light') ? 'dark' : 'light') + ';path=/'; location.reload()">{'Light' if not is_light else 'Dark'}</div>
<div class="container">
<h1>AIOS Control Center</h1>
<h2>Quick Links</h2>
<a href="/todo">Todo Manager</a>
<h2>Services</h2>
<pre>{services_text}</pre>
<h2>Schedule</h2>
<div>Daily: {", ".join(f"{t}: {c}" for t,c in schedule.get("daily",{}).items())}</div>
<div>Hourly: {", ".join(f":{m:02d}: {c}" for m,c in schedule.get("hourly",{}).items())}</div>
<h2>Run Command</h2>
<form action="/run" method="POST">
<input name="cmd" placeholder="python3 programs/todo/todo.py list">
<button type="submit">Run</button>
</form>
<div id="output"></div>
</div></body></html>"""
            self.wfile.write(html.encode())
        elif path == '/todo':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            result = subprocess.run("python3 programs/todo/todo.py list", shell=True, capture_output=True, text=True)
            tasks = result.stdout.strip().split('\n') if result.stdout else []
            theme = self.headers.get('Cookie', '').split('theme=')[-1].split(';')[0] if 'theme=' in self.headers.get('Cookie', '') else 'dark'
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            html = f"""<html>
<head><title>Todo</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.task{{background:{bg2};padding:10px;margin:5px 0;border-radius:5px}}
.done{{text-decoration:line-through;color:#666}}
button{{background:{fg};color:{bg};border:none;padding:5px 10px;cursor:pointer;margin:2px}}
input{{background:{bg2};color:{fg};border:1px solid {fg};padding:10px;width:50%;margin:10px 0}}
.theme-toggle{{position:fixed;top:20px;right:20px;cursor:pointer;padding:10px;background:{fg};color:{bg};border-radius:5px}}
</style></head>
<body>
<div class="theme-toggle" onclick="document.cookie='theme=' + (document.cookie.includes('theme=light') ? 'dark' : 'light') + ';path=/'; location.reload()">{'Light' if not is_light else 'Dark'}</div>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Todo Manager</h1>
<form action="/todo/add" method="POST">
<input name="task" placeholder="New task...">
<button type="submit">Add</button>
</form>
<div>{"".join(f'<div class="task {"done" if "[x]" in t else ""}">{t} <form style="display:inline" action="/todo/done" method="POST"><input type="hidden" name="id" value="{t.split(".")[0] if "." in t else i+1}"><button>Done</button></form></div>' for i,t in enumerate(tasks))}</div>
<form action="/todo/clear" method="POST"><button>Clear Completed</button></form>
</body></html>"""
            self.wfile.write(html.encode())

    def do_POST(self):
        path = urlparse(self.path).path
        length = int(self.headers['Content-Length'])
        data = parse_qs(self.rfile.read(length).decode())

        if path == '/run':
            cmd = data.get('cmd', [''])[0]
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            output = f"<pre>{result.stdout}\n{result.stderr}</pre>"
            self.wfile.write(f'<html><body><a href="/">Back</a><h2>Output:</h2>{output}</body></html>'.encode())
        elif path == '/todo/add':
            task = data.get('task', [''])[0]
            subprocess.run(f"python3 programs/todo/todo.py add {task}", shell=True)
            self.send_response(303)
            self.send_header('Location', '/todo')
            self.end_headers()
        elif path == '/todo/done':
            task_id = data.get('id', [''])[0]
            subprocess.run(f"python3 programs/todo/todo.py done {task_id}", shell=True)
            self.send_response(303)
            self.send_header('Location', '/todo')
            self.end_headers()
        elif path == '/todo/clear':
            subprocess.run("python3 programs/todo/todo.py clear", shell=True)
            self.send_response(303)
            self.send_header('Location', '/todo')
            self.end_headers()

def find_free_port(start=8080):
    for port in range(start, start + 100):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('127.0.0.1', port))
        sock.close()
        if result != 0:
            return port
    return start

def start_server():
    port = find_free_port()
    print(f"AIOS Control Center: http://localhost:{port}")
    aios_db.write("web_server", {"port": port, "pid": os.getpid()})
    HTTPServer(('', port), Handler).serve_forever()

def kill_server():
    info = aios_db.read("web_server")
    pid = info.get("pid") if info else None
    if pid:
        try:
            os.kill(pid, signal.SIGTERM)
            print(f"Killed server (PID: {pid})")
        except ProcessLookupError:
            print("Server not running")
    else:
        print("No server running")

command = sys.argv[1] if len(sys.argv) > 1 else "start"

actions = {
    "start": start_server,
    "stop": kill_server,
    "status": lambda: print(f"Server: {aios_db.read('web_server') or 'Not running'}"),
    "kill": kill_server
}

actions.get(command, start_server)()

services/service.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import aios_db

services = aios_db.read("services") or {}
command = sys.argv[1] if len(sys.argv) > 1 else "list"
name = sys.argv[2] if len(sys.argv) > 2 else None

actions = {
    "list": lambda: [print(f"{k}: {v.get('status', 'unknown')}") for k, v in services.items()],
    "start": lambda: aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "running"}}),
    "stop": lambda: aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "stopped"}}),
    "status": lambda: print(services.get(name, {}).get("status", "unknown") if name else "specify service")
}

actions.get(command, actions["list"])()

services/scraper.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import requests
from bs4 import BeautifulSoup
import aios_db
from datetime import datetime

config = aios_db.read("scraper") or {"urls": ["https://news.ycombinator.com"]}
results = []

[results.append({
    "url": url,
    "title": BeautifulSoup(requests.get(url).text, 'html.parser').title.string if BeautifulSoup(requests.get(url).text, 'html.parser').title else "No title",
    "time": datetime.now().isoformat()
}) for url in config.get("urls", [])]

aios_db.write("scraper_results", results)
[print(f"{r['url']}: {r['title']}") for r in results]

services/context_generator.py:
from pathlib import Path
from datetime import datetime

def generate():
    root = Path(__file__).parent.parent
    output = Path(root / "projectContext.txt")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    files = [f for f in root.rglob("*.py") if "archive" not in f.parts]

    content = f"Generated: {timestamp}\n\n"
    content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in files])

    output.write_text(content)
    return str(output)

services/gdrive.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
import aios_db
from datetime import datetime
from pathlib import Path

config = aios_db.read("gdrive") or {"folder_id": "root"}
creds = Credentials.from_authorized_user_info(aios_db.read("gdrive_creds") or {})
service = build('drive', 'v3', credentials=creds)

command = sys.argv[1] if len(sys.argv) > 1 else "sync"
source = Path(sys.argv[2]) if len(sys.argv) > 2 else Path.home()

actions = {
    "sync": lambda: [service.files().create(body={'name': f.name, 'parents': [config['folder_id']]},
                                            media_body=MediaFileUpload(str(f))).execute()
                     for f in source.glob('*') if f.is_file()],
    "list": lambda: [print(f['name']) for f in service.files().list(q=f"'{config['folder_id']}' in parents").execute().get('files', [])],
    "download": lambda: [open(f['name'], 'wb').write(service.files().get_media(fileId=f['id']).execute())
                        for f in service.files().list(q=f"'{config['folder_id']}' in parents").execute().get('files', [])],
    "status": lambda: print(f"Connected to folder: {config['folder_id']}")
}

actions.get(command, actions["status"])()

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime

ideas = aios_db.read("ideas") or []
command = sys.argv[1] if len(sys.argv) > 1 else "list"

def score(idea):
    return len(idea.get('description', '')) * idea.get('impact', 1) / max(idea.get('effort', 1), 1)

actions = {
    "add": lambda: aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}]),
    "rank": lambda: [print(f"{i+1}. [{score(idea):.1f}] {idea['description']}") for i, idea in enumerate(sorted(ideas, key=score, reverse=True))],
    "list": lambda: [print(f"{i+1}. {idea['description']}") for i, idea in enumerate(ideas)],
    "pick": lambda: print(f"Best: {sorted(ideas, key=lambda x: score(x)/x.get('effort', 5), reverse=True)[0]['description']}" if ideas else "No ideas")
}

actions.get(command, actions["list"])()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
from pathlib import Path
import aios_db
from datetime import datetime
import concurrent.futures

components = sys.argv[1:] if len(sys.argv) > 1 else []
build_dir = Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)

def build_component(name):
    result = subprocess.run(['echo', f'Building {name}'], capture_output=True, text=True)
    (build_dir / f"{name}.build").write_text(f"Built at {datetime.now()}")
    return {"name": name, "status": "success" if result.returncode == 0 else "failed", "time": datetime.now().isoformat()}

results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components)) if components else []
[print(f"{r['name']}: {r['status']}") for r in results]
aios_db.write("build_log", aios_db.read("build_log") or [] + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import schedule as sched
import time
import subprocess
import aios_db

schedules = aios_db.read("schedule")

[sched.every().day.at(t).do(lambda c=cmd: subprocess.run(c, shell=True))
 for t, cmd in schedules.get("daily", {}).items()]

[sched.every().hour.at(f":{int(m):02d}").do(lambda c=cmd: subprocess.run(c, shell=True))
 for m, cmd in schedules.get("hourly", {}).items()]

[[sched.run_pending(), time.sleep(60)] for _ in iter(int, 1)]

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime, timedelta

tasks = aios_db.read("tasks") or []
today = datetime.now().date()
plan = aios_db.read("daily_plan") or {}

pending = [t for t in tasks if not t.startswith("[x]") and not t.startswith("[!]")]
plan[str(today)] = pending[:10]

aios_db.write("daily_plan", plan)
[print(f"- {t}") for t in plan[str(today)]]

programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = sys.argv[1] if len(sys.argv) > 1 else "list"
question = ' '.join(sys.argv[2:]) if len(sys.argv) > 2 else ""

client = anthropic.Anthropic(api_key=aios_db.read("api_keys").get("anthropic", ""))

actions = {
    "ask": lambda: aios_db.write("llm_cache", {**cache, question: {"response": client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text, "time": datetime.now().isoformat()}}),
    "list": lambda: [print(f"Q: {q[:50]}... A: {a['response'][:50]}...") for q, a in cache.items()],
    "clear": lambda: aios_db.write("llm_cache", {}),
    "stats": lambda: print(f"Cached queries: {len(cache)}")
}

result = actions.get(command, actions["list"])()
print(cache.get(question, {}).get("response", "") if command == "ask" else "")

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime

tasks = aios_db.read("tasks") or []
command = sys.argv[1] if len(sys.argv) > 1 else "list"

actions = {
    "list": lambda: [print(f"{i+1}. {t}") for i, t in enumerate(tasks)],
    "add": lambda: aios_db.write("tasks", tasks + [f"[ ] {datetime.now():%Y-%m-%d %H:%M} {' '.join(sys.argv[2:])}"]),
    "done": lambda: aios_db.write("tasks", [t.replace("[ ]", "[x]") if i == int(sys.argv[2])-1 else t for i, t in enumerate(tasks)]),
    "clear": lambda: aios_db.write("tasks", [t for t in tasks if not t.startswith("[x]")])
}

actions.get(command, actions["list"])()

programs/autollm/autollm.py:
#!/usr/bin/env python3
"""Claude Auto - Simplified automation tool for Claude CLI"""

import os, sys, json, time, subprocess, tempfile, shutil, threading, queue, select
from pathlib import Path
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

__version__ = "6.1.0"

WORKFLOWS = {
    'standard': [
        ('Build', 'Before you begin read the files in this directory for context. Write all logic and functionality into a single .py file unless explicitly stated otherwise, no functionality is reliant on anything but this and it should run alone without any supporting files except if needed environmental setup.Set an aggressive target for low line count and stick to it if not given one.'),
        ('Debug', 'Run the existing code, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it.'),
        ('Finalize', 'Run it, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it. Then update/create the readme and simplify it aggressively. Everything must go except that which would make the user unable to use the script.')
    ],
    'simplify': [
        ('Build', 'Before you begin read the files in this directory for context. Write all logic and functionality into a single .py file unless explicitly stated otherwise, no functionality is reliant on anything but this and it should run alone without any supporting files except if needed environmental setup.Set an aggressive target for low line count and stick to it if not given one.'),
        ('Debug', 'Run the existing code, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it.'),
        ('Simplify', 'We are going to do a significant simplification. We will be deleting more than half of the lines of the single logical file without harming functionality, simplicity, following conventions, maintaining readability.'),
        ('Finalize', 'Run it, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it. Then update/create the readme and simplify it aggressively. Everything must go except that which would make the user unable to use the script.')
    ]
}

class ClaudeAuto:
    def __init__(self, output_dir="./claude_output", working_dir=None):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.working_dir = Path(working_dir) if working_dir else Path.cwd()
        if not self.working_dir.exists():
            print(f"‚ö†Ô∏è  Working directory doesn't exist: {self.working_dir}")
            if input("Create it? (y/n): ").strip().lower() == 'y':
                self.working_dir.mkdir(parents=True, exist_ok=True)
            else:
                self.working_dir = Path.cwd()
        self.results = []
        self.active_tasks = {}
        self.task_lock = threading.Lock()
        self.completed_queue = queue.Queue()
        self.notification_thread = None
    

    def start_monitoring(self):
        """Start background monitoring"""
        # Clear screen
        print('\033[2J\033[H')

    def execute_claude(self, prompt, cwd=None, output_file=None, prefix="", task_id=None):
        """Execute Claude CLI with prompt"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as tmp:
            tmp.write(prompt)
            temp_file = tmp.name
        
        try:
            task_name = prefix.strip('[]').strip() if prefix else 'Task'
            if task_id:
                with self.task_lock:
                    self.active_tasks[task_id] = {'name': task_name, 'start': time.time()}

            cmd = f"claude --dangerously-skip-permissions < {temp_file} 2>&1 | head -c 500000"
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                     stderr=subprocess.STDOUT, text=True,
                                     cwd=str(cwd or self.working_dir), errors='replace')

            output_lines = []
            for line in process.stdout:
                # Don't print to console for background tasks
                output_lines.append(line)
                if output_file:
                    with open(output_file, 'a') as f:
                        f.write(line)
                        f.flush()
            
            exit_code = process.wait(timeout=300)
            os.unlink(temp_file)

            if task_id:
                with self.task_lock:
                    if task_id in self.active_tasks:
                        del self.active_tasks[task_id]

            return exit_code == 0, ''.join(output_lines)
        except Exception as e:
            print(f"‚ùå Error: {e}")
            if task_id:
                with self.task_lock:
                    if task_id in self.active_tasks:
                        del self.active_tasks[task_id]
            return False, str(e)
    
    def run_task(self, name, prompt, task_id=None, future=None):
        """Run a single task"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        task_dir = self.output_dir / f"{name}_{timestamp}"
        task_dir.mkdir(exist_ok=True)
        output_file = task_dir / "output.txt"

        prefix = f"[{task_id}] " if task_id else ""

        with open(output_file, 'w') as f:
            f.write(f"=== {name} ===\n{datetime.now()}\n\n--- Prompt ---\n{prompt}\n{'='*60}\n\n")

        success, _ = self.execute_claude(prompt, cwd=task_dir, output_file=output_file, prefix=prefix, task_id=task_id)

        # Remove from active tasks and add to completed queue
        if task_id:
            with self.task_lock:
                if task_id in self.active_tasks:
                    del self.active_tasks[task_id]
            self.completed_queue.put((task_id, name, time.time()))

        result = {'name': name, 'success': success, 'output': str(output_file)}
        self.results.append(result)
        return result
    
    def run_workflow(self, workflow_type, initial_task, version_num=None, num_versions=1):
        """Run a complete workflow"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        version_suffix = f"_v{version_num}" if version_num else ""
        # Use working_dir instead of output_dir when a custom directory is specified
        base_dir = self.working_dir if self.working_dir != Path.cwd() else self.output_dir
        workflow_dir = base_dir / f"workflow_{timestamp}{version_suffix}"
        workflow_dir.mkdir(parents=True, exist_ok=True)
        
        # Copy files from working directory to workflow directory if needed
        if self.working_dir != Path.cwd() and self.working_dir.exists():
            print(f"\nüìÇ Copying files from {self.working_dir}...")
            for item in self.working_dir.iterdir():
                if item.name.startswith('.') or item.name in ['__pycache__', 'node_modules', '.git', 'claude_output']:
                    continue
                dest = workflow_dir / item.name
                if item.is_file():
                    shutil.copy2(item, dest)
                elif item.is_dir():
                    shutil.copytree(item, dest, dirs_exist_ok=True)
        
        # Always work in the workflow directory so files are saved there
        working_dir = workflow_dir
        
        output_file = workflow_dir / "output.txt"
        with open(output_file, 'w') as f:
            f.write(f"{'='*80}\nWORKFLOW EXECUTION - {datetime.now()}\n")
            if version_num:
                f.write(f"Version: {version_num}/{num_versions}\n")
            f.write(f"Initial Task: {initial_task[:100]}{'...' if len(initial_task) > 100 else ''}\n{'='*80}\n\n")
        
        results = []
        steps = WORKFLOWS[workflow_type]
        
        for i, (step_name, step_prompt) in enumerate(steps, 1):
            full_prompt = f"Working in: {working_dir}\n\n{initial_task if step_name == 'Build' else step_prompt}"
            
            with open(output_file, 'a') as f:
                f.write(f"\n{'#'*80}\nSTEP {i}/{len(steps)}: {step_name.upper()}\n{'#'*80}\n")
                f.write(f"\n--- Prompt for {step_name} ---\n{full_prompt}\n\n--- Claude Response ---\n")
            
            prefix = f"[V{version_num}] " if version_num else ""
            task_id = f"BGV{version_num}S{i}" if version_num else f"BGS{i}"
            # Don't print step messages for background workflows
            success, _ = self.execute_claude(full_prompt, cwd=working_dir, output_file=output_file, prefix=prefix, task_id=task_id)
            
            # Don't print step completion for background workflows
            results.append({'name': step_name, 'success': success})
            
            if not success:
                print(f"‚ö†Ô∏è  {prefix}Step failed, stopping workflow")
                break
        
        return {'version': version_num or 'single', 'directory': str(workflow_dir),
                'output': str(output_file), 'success': all(r['success'] for r in results)}

def get_dir_size(path):
    """Get directory size in MB"""
    total = sum(os.path.getsize(os.path.join(dp, f)) 
                for dp, _, fns in os.walk(path) 
                for f in fns if os.path.exists(os.path.join(dp, f)))
    return total / (1024 * 1024)

def main():
    """Main interactive loop"""
    import argparse
    parser = argparse.ArgumentParser(description='Claude Auto - Automation tool')
    parser.add_argument('-d', '--dir', dest='working_dir', help='Working directory')
    parser.add_argument('-o', '--output', default='./claude_output', help='Output directory')
    args = parser.parse_args()

    auto = ClaudeAuto(output_dir=args.output, working_dir=args.working_dir)
    auto.start_monitoring()
    
    # Check Claude CLI
    if subprocess.run(['which', 'claude'], capture_output=True).returncode != 0:
        print("‚ùå Claude CLI not found! Install with: npm install -g @anthropic/claude-cli")
        sys.exit(1)
    
    print(f"\n{'='*60}\nClaude Auto v{__version__}\nWorking: {auto.working_dir}\nOutput: {auto.output_dir}\n{'='*60}")

    executor = ThreadPoolExecutor(max_workers=10)
    background_futures = []

    # Store recent notifications
    recent_notifications = []
    notification_lock = threading.Lock()

    def status_updater():
        """Background thread to update status and collect notifications"""
        while True:
            try:
                time.sleep(1)
                # Check for new completions
                while not auto.completed_queue.empty():
                    try:
                        task_id, name, completion_time = auto.completed_queue.get_nowait()
                        with notification_lock:
                            recent_notifications.append({
                                'msg': f"üîî {name} completed [{task_id}]",
                                'time': time.time()
                            })
                            # Keep only last 10 notifications
                            if len(recent_notifications) > 10:
                                recent_notifications.pop(0)
                        # Print notification immediately
                        print(f"\n\033[93müîî {name} completed [{task_id}]\033[0m")
                        print("Choice: ", end='', flush=True)  # Re-show prompt
                    except:
                        break
            except:
                break

    # Start status updater thread
    status_thread = threading.Thread(target=status_updater, daemon=True)
    status_thread.start()

    def print_status():
        """Print current status with notifications"""
        # Clean old notifications (older than 30 seconds)
        with notification_lock:
            current_time = time.time()
            for notif in recent_notifications[:]:
                if current_time - notif['time'] > 30:
                    recent_notifications.remove(notif)

            # Show recent notifications
            if recent_notifications:
                for notif in recent_notifications[-3:]:  # Show last 3 notifications
                    print(f"\033[93m{notif['msg']}\033[0m")

        # Display status
        active_count = len(auto.active_tasks)
        if active_count > 0:
            active_list = ", ".join([f"{tid}" for tid in list(auto.active_tasks.keys())[:5]])
            print(f"\n\033[92m‚ö° Active: {active_count} tasks [{active_list}]\033[0m")

    while True:
        # Clean up completed background tasks
        background_futures = [f for f in background_futures if not f.done()]

        print_status()

        print("\nüéØ Options:\n1. Quick prompt\n2. Multiple tasks (parallel)\n3. Multiple tasks (sequential)")
        print(f"4. Workflow\n5. Exit")

        try:
            choice = input("\nChoice: ").strip()
        except (EOFError, KeyboardInterrupt):
            break
        
        if choice == '1':
            print("Enter prompt (Ctrl+D to finish):")
            try:
                lines = []
                while True:
                    lines.append(input())
            except EOFError:
                prompt = '\n'.join(lines).strip()
                if prompt:
                    task_id = f"BG{len(background_futures)+1}"
                    # Pre-register the task
                    with auto.task_lock:
                        auto.active_tasks[task_id] = {'name': 'Task', 'start': time.time()}
                    future = executor.submit(auto.run_task, 'Task', prompt, task_id, None)
                    with auto.task_lock:
                        if task_id in auto.active_tasks:
                            auto.active_tasks[task_id]['future'] = future
                    background_futures.append(future)
                    print(f"\n‚ö° Task launched in background as {task_id}")
        
        elif choice in ['2', '3']:
            tasks = []
            print("\nEnter tasks (empty name to finish):")
            while True:
                name = input(f"Task {len(tasks)+1} name: ").strip()
                if not name:
                    break
                print("Prompt (Ctrl+D to finish):")
                try:
                    lines = []
                    while True:
                        lines.append(input())
                except EOFError:
                    prompt = '\n'.join(lines).strip()
                    if prompt:
                        tasks.append({'name': name, 'prompt': prompt})
            
            if tasks:
                base_id = len(background_futures)
                if choice == '2' and len(tasks) > 1:
                    # Parallel execution
                    futures = []
                    for i, t in enumerate(tasks):
                        task_id = f"BG{base_id+i+1}"
                        with auto.task_lock:
                            auto.active_tasks[task_id] = {'name': t['name'], 'start': time.time()}
                        future = executor.submit(auto.run_task, t['name'], t['prompt'], task_id, None)
                        with auto.task_lock:
                            if task_id in auto.active_tasks:
                                auto.active_tasks[task_id]['future'] = future
                        futures.append(future)
                    background_futures.extend(futures)
                    print(f"\n‚ö° {len(tasks)} tasks launched in parallel")
                else:
                    # Sequential execution in background
                    def run_sequential():
                        for i, task in enumerate(tasks):
                            task_id = f"BG{base_id+i+1}"
                            with auto.task_lock:
                                auto.active_tasks[task_id] = {'name': task['name'], 'start': time.time()}
                            auto.run_task(task['name'], task['prompt'], task_id)
                    future = executor.submit(run_sequential)
                    background_futures.append(future)
                    print(f"\n‚ö° {len(tasks)} tasks launched sequentially in background")
        
        elif choice == '4':
            print("\nüîß WORKFLOW MODE")
            print(f"üìÇ Working: {auto.working_dir}")
            
            # Workflow type
            print("\n1. Standard (3 steps)\n2. With simplification (4 steps)")
            wf_type = 'simplify' if input("Choice [1-2]: ").strip() == '2' else 'standard'
            
            # Number of versions
            num_versions = 1
            exec_mode = 'single'
            print("\n1. Single version\n2. Multiple versions")
            if input("Choice [1-2]: ").strip() == '2':
                try:
                    num_versions = max(1, min(10, int(input("Number of versions (2-10): ").strip())))
                    if num_versions > 1:
                        print("\n1. Parallel\n2. Sequential")
                        exec_mode = 'parallel' if input("Choice [1-2]: ").strip() == '1' else 'sequential'
                except:
                    num_versions = 2
            
            # Working directory
            if input("\nüìÅ Change working directory? (y/n): ").strip().lower() == 'y':
                new_dir = input("Path: ").strip()
                if new_dir:
                    auto.working_dir = Path(new_dir)
                    if not auto.working_dir.exists():
                        auto.working_dir.mkdir(parents=True, exist_ok=True)
            
            # Check size for parallel copy
            if num_versions > 1 and exec_mode == 'parallel' and auto.working_dir != Path.cwd():
                size_mb = get_dir_size(auto.working_dir)
                if size_mb > 100:
                    print(f"\n‚ö†Ô∏è  Will copy {size_mb:.1f}MB. Continue in 10s (Ctrl+C to abort)...")
                    try:
                        for i in range(10, 0, -1):
                            print(f"\r{i}... ", end='', flush=True)
                            time.sleep(1)
                    except KeyboardInterrupt:
                        continue
            
            # Get task
            print("\nüìù Enter task (Ctrl+D to finish):")
            try:
                lines = []
                while True:
                    lines.append(input())
            except EOFError:
                initial_task = '\n'.join(lines).strip()
            
            if not initial_task:
                continue
            
            print(f"\nüöÄ Starting {num_versions} workflow(s)...")
            
            # Execute workflows in background
            if num_versions == 1:
                future = executor.submit(auto.run_workflow, wf_type, initial_task)
                background_futures.append(future)
                print(f"‚ö° Workflow launched in background")
            elif exec_mode == 'parallel':
                futures = [executor.submit(auto.run_workflow, wf_type, initial_task, i+1, num_versions)
                         for i in range(num_versions)]
                background_futures.extend(futures)
                print(f"‚ö° {num_versions} workflows launched in parallel")
            else:
                def run_sequential_workflows():
                    for i in range(num_versions):
                        auto.run_workflow(wf_type, initial_task, i+1, num_versions)
                future = executor.submit(run_sequential_workflows)
                background_futures.append(future)
                print(f"‚ö° {num_versions} workflows launched sequentially")
        
        if choice == '5':
            break
        
        # Show results summary
        if auto.results:
            print(f"\n{'='*60}\nSUMMARY\n{'='*60}")
            print(f"‚úÖ Successful: {sum(1 for r in auto.results if r.get('success'))}")
            print(f"‚ùå Failed: {sum(1 for r in auto.results if not r.get('success'))}")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\033[?25h")  # Show cursor
        print("\n\n‚ö†Ô∏è Interrupted")
        sys.exit(130)

programs/aios_start/aios_start.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import time
import aios_db
from pathlib import Path
import webbrowser
import os
import signal

aios_path = Path.home() / ".aios"
command = sys.argv[1] if len(sys.argv) > 1 else "start"

def kill_existing():
    subprocess.run(["pkill", "-f", "aios_api.py"], stderr=subprocess.DEVNULL)
    subprocess.run(["pkill", "-f", "programs/web/web.py"], stderr=subprocess.DEVNULL)
    pids = aios_db.read("aios_pids") or {}
    for pid in pids.values():
        if pid:
            try:
                os.kill(pid, signal.SIGTERM)
            except ProcessLookupError:
                pass

def start():
    start_time = time.time()
    kill_existing()
    aios_path.mkdir(exist_ok=True)
    api_proc = subprocess.Popen(["python3", "aios_api.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    web_proc = subprocess.Popen(["python3", "programs/web/web.py", "start"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
    time.sleep(0.1)
    info = aios_db.read("web_server") or {}
    url = f"http://localhost:{info.get('port', 8080)}"
    elapsed = time.time() - start_time
    print(f"AIOS started in {elapsed:.3f}s: {url}")
    webbrowser.open(url)
    [[time.sleep(1)] for _ in iter(int, 1)]

def stop():
    kill_existing()
    aios_db.write("aios_pids", {})
    print("AIOS stopped")

actions = {
    "start": start,
    "stop": stop,
    "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")
}

actions.get(command, start)()
