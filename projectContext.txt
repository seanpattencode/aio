Generated: 2025-10-02 17:18:10

aios_start.py:
#!/usr/bin/env python3
import subprocess, sys, socket, webbrowser
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
commands = {
    "start": lambda: (
        Path.home().joinpath(".aios").mkdir(exist_ok=True),
        (lambda ports: (
            aios_db.write("ports", {"web": ports[0], "api": ports[1]}),
            aios_db.write("aios_pids", {}),
            (lambda sock: (
                [sock.setsockopt(socket.SOL_SOCKET, opt, 1) for opt in [socket.SO_REUSEADDR, socket.SO_REUSEPORT]],
                sock.bind(('', ports[0])),
                sock.listen(5),
                (lambda procs: (
                    sock.close(),
                    aios_db.write("aios_pids", {"api": procs[0].pid, "web": procs[1].pid}),
                    print(f"AIOS started: http://localhost:{ports[0]}"),
                    webbrowser.open(f"http://localhost:{ports[0]}"),
                    subprocess.Popen(["python3", "-c", "from services import context_generator; context_generator.generate()"], cwd="/home/seanpatten/projects/AIOS")
                ))([
                    subprocess.Popen(["python3", "core/aios_api.py", str(ports[1])], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL),
                    subprocess.Popen(["python3", "services/web/web.py", str(sock.fileno()), str(ports[0]), str(ports[1])], pass_fds=[sock.fileno()])
                ])
            ))(socket.socket(socket.AF_INET, socket.SOCK_STREAM))
        ))([
            (lambda sk: (sk.bind(('', 0)), sk.getsockname()[1], sk.close())[1])(socket.socket()),
            (lambda sk: (sk.bind(('', 0)), sk.getsockname()[1], sk.close())[1])(socket.socket())
        ])
    )[-1],
    "stop": lambda: (
        subprocess.run(["pkill", "-9", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL),
        subprocess.run(["pkill", "-9", "-f", "services/web/web.py"], stderr=subprocess.DEVNULL),
        aios_db.write("aios_pids", {}),
        print("AIOS stopped")
    )[-1],
    "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")
}
commands.get((sys.argv + ["start"])[1], commands["start"])()

core/aios_runner.py:
#!/usr/bin/env python3
import subprocess, sys, signal, os, operator

cmd_str = ' '.join(sys.argv[1:]).lower()

# Determine timeout based on command
long_running_cmds = ['web.py', 'aios_api.py', 'scheduler.py', 'poll',
                     'watch', 'serve', 'autollm', 'claude', 'codex']
medium_cmds = ['wiki_fetcher', 'scraper', 'gdrive',
               'curl', 'wget', 'git', 'npm', 'pip']

# Check for long running commands (essentially infinite timeout)
timeout_values = []
for p in long_running_cmds:
    if cmd_str.find(p) >= 0:
        timeout_values.append(999999)

# Check for medium timeout commands
for p in medium_cmds:
    if cmd_str.find(p) >= 0:
        timeout_values.append(5.0)

# Default short timeout
timeout_values.append(0.1)

timeout = float(os.getenv('AIOS_TIMEOUT', max(timeout_values)))

# Set timeout signal handler
signal.signal(signal.SIGALRM, lambda *_: sys.exit(1))
signal.setitimer(signal.ITIMER_REAL, timeout)

# Run command
result = subprocess.run(sys.argv[1:], capture_output=True, text=True)

# Clear alarm and output results
signal.alarm(0)
sys.stdout.write(result.stdout)
sys.stderr.write(result.stderr)
sys.exit(result.returncode)


core/aios_db.py:
import json, sqlite3, pathlib

# Database connection
db_path = pathlib.Path(__file__).parent.parent / "data/aios.db"
d = sqlite3.connect(str(db_path), isolation_level=None, check_same_thread=False)

# Set pragmas for performance
[d.execute(p) for p in ["PRAGMA synchronous=0", "PRAGMA journal_mode=MEMORY"]]

# Create tables
tables = [
    """CREATE TABLE IF NOT EXISTS kv(
        k TEXT PRIMARY KEY,
        v TEXT
    )""",
    """CREATE TABLE IF NOT EXISTS jobs(
        id INTEGER PRIMARY KEY,
        name TEXT,
        status TEXT,
        output TEXT,
        created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )""",
    """CREATE TABLE IF NOT EXISTS messages(
        id INTEGER PRIMARY KEY,
        content TEXT,
        timestamp TEXT,
        source TEXT,
        priority INTEGER DEFAULT 0
    )""",
    """CREATE TABLE IF NOT EXISTS worktrees(
        id INTEGER PRIMARY KEY,
        repo TEXT,
        branch TEXT,
        path TEXT,
        job_id INTEGER,
        model TEXT,
        task TEXT,
        status TEXT,
        output TEXT,
        created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )""",
    """CREATE TABLE IF NOT EXISTS events(
        id INTEGER PRIMARY KEY,
        target TEXT,
        data TEXT,
        created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )"""
]
d.executescript(";".join(tables))

# Database functions
read = lambda n: json.loads(d.execute("SELECT v FROM kv WHERE k=?", (n,)).fetchone()[0])
write = lambda n, x: (d.execute("INSERT OR REPLACE INTO kv VALUES(?,?)", (n, json.dumps(x, indent=2))), x)[1]
query = lambda _, s, p=(): d.execute(s, p).fetchall()
execute = lambda _, s, p=(): d.execute(s, p)


core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db, uvicorn
app = FastAPI()
@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)
@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())
@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)", (target, (await request.body()).decode()))
    return {"status": "ok"}
@app.get("/status")
async def status():
    aios_db.write("services", {})
    aios_db.write("tasks", [])
    aios_db.write("schedule", {})
    return {"services": aios_db.read("services"), "tasks": aios_db.read("tasks"), "schedule": aios_db.read("schedule")}

# Get port from command line argument or default to 8000
api_port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
uvicorn.run(app, host="0.0.0.0", port=api_port)

services/backup.py:
#!/usr/bin/env python3
import sys, shutil
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
from pathlib import Path
import aios_db
from datetime import datetime
[aios_db.write(*x) for x in [("backup", {"source": str(Path.home()), "dest": "/tmp/backup"}), ("backup_log", [])]]
c = aios_db.read("backup")
n = datetime.now()
dest = Path(c.get("dest", "/tmp/backup")) / f"{n:%Y%m%d_%H%M%S}"
[dest.parent.mkdir(parents=True, exist_ok=True), shutil.copytree(Path(c.get("source", str(Path.home()))), dest, dirs_exist_ok=True), aios_db.write("backup_log", aios_db.read("backup_log") + [{"time": n.isoformat(), "dest": str(dest)}]), print(f"Backed up to {dest}")]

services/service.py:
#!/usr/bin/env python3
import sys
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db

# Initialize services
aios_db.write("services", {})

# Parse arguments
s = aios_db.read("services")
c = (sys.argv + ["list"])[1]
n = (sys.argv + ["", None])[2]

# Define commands
def list_services():
    return list(map(print, [f"{k}: {v.get('status', 'unknown')}" for k, v in s.items()]))

def start_service():
    updated = {**s, n: {**s.get(n, {}), "status": "running"}}
    return aios_db.write("services", updated)

def stop_service():
    updated = {**s, n: {**s.get(n, {}), "status": "stopped"}}
    return aios_db.write("services", updated)

def get_status():
    if n == None:
        return print("specify service")
    return print(s.get(n, {}).get("status", "unknown"))

# Execute command
commands = {
    "list": list_services,
    "start": start_service,
    "stop": stop_service,
    "status": get_status
}

handler = commands.get(c, list_services)
handler()

services/scraper.py:
#!/usr/bin/env python3
import sys, requests
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from bs4 import BeautifulSoup
from datetime import datetime
aios_db.write("scraper", {"urls": ["https://news.ycombinator.com"]})
get_title = lambda u: (lambda s: s.title.string or "No title")(BeautifulSoup(requests.get(u, timeout=0.01).text, 'html.parser'))
results = [{"url": u, "title": get_title(u), "time": datetime.now().isoformat()} for u in aios_db.read("scraper").get("urls", [])]
[aios_db.write("scraper_results", results), list(map(lambda r: print(f"{r['url']}: {r['title']}"), results))]

services/context_generator.py:
from pathlib import Path
from datetime import datetime
def generate():
    root = Path(__file__).parent.parent
    output = Path(root / "projectContext.txt")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    files = [f for f in root.rglob("*.py")]
    readme = root / "README.md"
    content = f"Generated: {timestamp}\n\n"
    content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in files])
    content += {True: "", False: f"\nREADME.md:\n{readme.read_text()}\n"}[readme.exists()]
    output.write_text(content)
    return str(output)

services/jobs.py:
#!/usr/bin/env python3
import sys, subprocess
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
c, jid, j = (sys.argv + ["list"])[1], (sys.argv + ["", None])[2], aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")
pj = lambda x: print(f"{x[0]}: {x[1]} - {x[2]} - {({True: (x[3] or 'No output')[:50], False: 'No output'}[x[3] != None])}...")
pr = lambda x: print(f'<div class="job-item">{x[1]} <span class="status running">Running...</span></div>')
prv = lambda x: [print(f'<div class="job-item">{x[1]} <span class="output">{({True: (x[3] or "")[:50] + "...", False: ""}[x[3] != None])}</span>'), print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{x[0]}"><button class="action-btn">Accept</button></form>'), print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{x[0]}"><button class="action-btn">Redo</button></form></div>')]
pd = lambda x: print(f'<div class="job-item">{x[1]} <span class="output">{({True: (x[3] or "")[:50] + "...", False: ""}[x[3] != None])}</span></div>')
print_summary = lambda: (lambda r, rv, d, s: (list(map(s.extend, [[f"RUN {x[1]}" for x in r[:2]], [f"? {x[1]}" for x in rv[:1]], [f"DONE {x[1]}" for x in d[:1]]])), list(map(print, s[:4]))))((list(filter(lambda x: x[2] == "running", j))), (list(filter(lambda x: x[2] == "review", j))), (list(filter(lambda x: x[2] == "done", j))[:5]), [])[-1]
{"summary": print_summary, "running": lambda: list(map(pr, filter(lambda x: x[2] == "running", j[:10]))), "review": lambda: list(map(prv, filter(lambda x: x[2] == "review", j[:10]))), "done": lambda: list(map(pd, filter(lambda x: x[2] == "done", j[:50]))), "run_wiki": lambda: (aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')"), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0])]))[-1], "accept": lambda: {True: None, False: aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(jid),))}[jid == None], "redo": lambda: {True: None, False: (aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(jid),)), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(jid)]))}[jid == None], "list": lambda: list(map(pj, j[:20]))}.get(c, lambda: list(map(pj, j[:20])))()

services/processes.py:
#!/usr/bin/env python3
import sys, subprocess, json
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from pathlib import Path

# Parse arguments
c = (sys.argv + ["json"])[1]
n = (sys.argv + ["", None])[2]

# Initialize database entries
[aios_db.write(k, v) for k, v in [("schedule", {}), ("aios_pids", {})]]

def get_all_processes():
    """Get all process information"""
    schedule = aios_db.read("schedule")
    pids = aios_db.read("aios_pids")
    aios_path = Path('/home/seanpatten/projects/AIOS')

    # Build scheduled tasks
    daily_tasks = [{"path": cmd, "type": "daily", "time": time, "status": "scheduled"}
                   for time, cmd in schedule.get("daily", {}).items()]

    hourly_tasks = [{"path": cmd, "type": "hourly", "time": f":{int(m):02d}", "status": "scheduled"}
                    for m, cmd in schedule.get("hourly", {}).items()]

    scheduled = sorted(daily_tasks + hourly_tasks, key=lambda x: x["time"])

    # Build ongoing processes
    ongoing = [{"path": f"{k}_pid_{v}", "type": "running", "status": "active"}
               for k, v in pids.items()]

    # Build core files list
    py_files = aios_path.rglob('*.py')
    core = []
    for f in py_files:
        if 'archive' not in f.parts and '__pycache__' not in f.parts:
            core.append({
                "path": str(f.relative_to(aios_path)),
                "type": "file",
                "status": "available"
            })

    return {
        "scheduled": scheduled,
        "ongoing": ongoing,
        "core": core
    }

def print_process(p):
    """Print a single process"""
    print(f"{p['path']}: {p['status']}")

def cmd_json():
    """Output JSON format"""
    print(json.dumps(get_all_processes()))

def cmd_list():
    """List all processes"""
    ap = get_all_processes()
    list(map(print_process, ap.get("scheduled", [])))
    list(map(print_process, ap.get("ongoing", [])))
    list(map(print_process, ap.get("core", [])))

def cmd_start():
    """Start a process"""
    if n is not None:
        subprocess.Popen(['python3', n])

def cmd_stop():
    """Stop a process"""
    if n is not None:
        subprocess.run(['pkill', '-f', n], timeout=5)

# Command dispatch
commands = {
    "json": cmd_json,
    "list": cmd_list,
    "start": cmd_start,
    "stop": cmd_stop
}

# Execute command (default to json)
handler = commands.get(c, cmd_json)
handler()

services/feed.py:
#!/usr/bin/env python3
import sys
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from datetime import datetime

# Get command
c = (sys.argv + ["list"])[1]

# Message formatting functions
def print_message(r):
    """Print message with standard formatting"""
    is_today = datetime.fromisoformat(r[2]).date() == datetime.now().date()
    time_part = r[2].split('T')[1][:5]

    if is_today:
        print(f"{time_part} {r[1]}")
    else:
        date_part = r[2].split('T')[0]
        print(f"{date_part} {time_part} {r[1]}")

def print_message_with_format(r, time_format):
    """Print message with custom time format"""
    dt = datetime.fromisoformat(r[2])
    is_today = dt.date() == datetime.now().date()
    time_str = dt.strftime(time_format)

    if is_today:
        print(f"{time_str} {r[1]}")
    else:
        date_part = r[2].split('T')[0]
        print(f"{date_part} {time_str} {r[1]}")

# Command functions
def add_message():
    content = " ".join(sys.argv[2:])
    timestamp = datetime.now().isoformat()
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)",
                   (content, timestamp, "manual"))

def list_messages():
    messages = aios_db.query("feed",
                            "SELECT id, content, timestamp, source FROM messages "
                            "ORDER BY timestamp DESC LIMIT 50")
    list(map(print_message, messages))

def view_messages():
    aios_db.write('settings', {})
    settings = aios_db.read('settings')
    is_12h = settings.get('time_format', '12h') == '12h'
    time_format = '%I:%M %p' if is_12h else '%H:%M'

    messages = aios_db.query("feed",
                            "SELECT id, content, timestamp, source FROM messages "
                            "ORDER BY timestamp DESC LIMIT 50")
    list(map(lambda r: print_message_with_format(r, time_format), messages))

def clear_old_messages():
    aios_db.execute("feed", "DELETE FROM messages WHERE timestamp < datetime('now', '-7 days')")

# Command dispatch
commands = {
    "add": add_message,
    "list": list_messages,
    "view": view_messages,
    "clear": clear_old_messages
}

# Execute command (default to list)
handler = commands.get(c, list_messages)
handler()

programs/job_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import subprocess

command = sys.argv[1] if len(sys.argv) > 1 else "summary"
job_id = sys.argv[2] if len(sys.argv) > 2 else None

jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")

if command == "summary":
    running = [j for j in jobs if j[2] == "running"]
    review = [j for j in jobs if j[2] == "review"]
    done = [j for j in jobs if j[2] == "done"][:5]

    summary = []
    summary.extend([f"RUN {j[1]}" for j in running[:2]])
    summary.extend([f"? {j[1]}" for j in review[:1]])
    summary.extend([f"DONE {j[1]}" for j in done[:1]])

    for line in summary[:4]:
        print(line)

elif command == "running":
    running = [j for j in jobs if j[2] == "running"]
    for j in running[:10]:
        print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')

elif command == "review":
    review = [j for j in jobs if j[2] == "review"]
    for j in review[:10]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
        print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
        print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')

elif command == "done":
    done = [j for j in jobs if j[2] == "done"]
    for j in done[:50]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')

elif command == "run_wiki":
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

elif command == "accept" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))

elif command == "redo" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),))
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("ideas", [])
ideas, command = aios_db.read("ideas"), (sys.argv + ["list"])[1]
score = lambda i: len(i.get('description', '')) * i.get('impact', 1) / max(i.get('effort', 1), 1)
commands = {
    "add": lambda: aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}]),
    "rank": lambda: list(map(lambda x: print(f"{x[0]+1}. [{score(x[1]):.1f}] {x[1]['description']}"), enumerate(sorted(ideas, key=score, reverse=True)))),
    "list": lambda: list(map(lambda x: print(f"{x[0]+1}. {x[1]['description']}"), enumerate(ideas))),
    "pick": lambda: print(f"Best: {sorted(ideas, key=lambda x: score(x)/x.get('effort', 5), reverse=True)[0]['description']}") if ideas else None
}
commands.get(command, commands["list"])()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys, subprocess, concurrent.futures
from pathlib import Path
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
components, build_dir = sys.argv[1:] or [], Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)
build_component = lambda n: ((build_dir / f"{n}.build").write_text(f"Built at {datetime.now()}"), {"name": n, "status": {0: "success"}.get(subprocess.run(['echo', f'Building {n}'], capture_output=True, timeout=10).returncode, "failed"), "time": datetime.now().isoformat()})[1]
results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components))
list(map(lambda r: print(f"{r['name']}: {r['status']}"), results))
aios_db.write("build_log", [])
aios_db.write("build_log", aios_db.read("build_log") + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys, subprocess, schedule as sched
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
schedules = aios_db.read("schedule")
run_cmd = lambda cmd: subprocess.run(cmd, shell=True, timeout=300)
list(map(lambda item: sched.every().day.at(item[0]).do(run_cmd, item[1]), schedules.get("daily", {}).items()))
list(map(lambda item: sched.every().hour.at(f":{int(item[0]):02d}").do(run_cmd, item[1]), schedules.get("hourly", {}).items()))
sched.run_pending()

programs/wiki_fetcher/wiki_fetcher.py:
#!/usr/bin/env python3
import sys, json, urllib.request
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
data = json.loads(urllib.request.urlopen(urllib.request.Request("https://en.wikipedia.org/api/rest_v1/page/random/summary", headers={'User-Agent': 'Mozilla/5.0'})).read().decode())
output, job_id = f"{data.get('title', 'Unknown')}: {data.get('extract', 'No extract available')[:200]}...", (sys.argv + [None])[1]
(job_id and aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?", (output, job_id))) or print(output)

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("tasks", []) or aios_db.write("daily_plan", {})
tasks, today, plan = aios_db.read("tasks"), str(datetime.now().date()), aios_db.read("daily_plan")
pending = [t for t in tasks if not (t.startswith("[x]") or t.startswith("[!]"))][:10]
plan[today] = pending
aios_db.write("daily_plan", plan)
list(map(lambda t: print(f"- {t}"), pending))

programs/settings/settings.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
command, key, value, settings = (sys.argv + ["set"])[1], (sys.argv + ["set", "theme"])[2], (sys.argv + ["set", "theme", ""])[3], aios_db.read("settings") or {}
{"set": lambda: aios_db.write("settings", {**settings, key: value}), "get": lambda: print(settings.get(key, ""))}[command]()


programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = (sys.argv + ["list"])[1]
question = ' '.join(sys.argv[2:])

client = anthropic.Anthropic(api_key=(aios_db.read("api_keys") or {}).get("anthropic", ""))

def ask():
    response = client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text
    cache[question] = {"response": response, "time": datetime.now().isoformat()}
    aios_db.write("llm_cache", cache)
    print(response)
    return cache

def print_item(item):
    q, a = item
    print(f"Q: {q[:50]}... A: {a['response'][:50]}...")

def list_cache():
    list(map(print_item, cache.items()))
    return cache

def clear():
    return aios_db.write("llm_cache", {})

def stats():
    print(f"Cached queries: {len(cache)}")
    return len(cache)

actions = {"ask": ask, "list": list_cache, "clear": clear, "stats": stats}
actions.get(command, list_cache)()

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
command, get_tasks = (sys.argv + ["list"])[1], lambda: aios_db.read("tasks")
tasks = get_tasks()
commands = {
    "add": lambda: (aios_db.write("tasks", get_tasks() + [f"[ ] {datetime.now():%Y-%m-%d %H:%M} {' '.join(sys.argv[2:]).split('@')[0].strip()}"]),
                   aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Task: {' '.join(sys.argv[2:]).split('@')[0].strip()}", datetime.now().isoformat(), "todo"))),
    "done": lambda: (lambda ts, tid, t: (aios_db.write("tasks", ts[:tid] + [t.replace("[ ]", "[x]")] + ts[tid+1:]),
                                          aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Completed: {' '.join(t.split()[3:])}", datetime.now().isoformat(), "todo"))))(get_tasks(), int(sys.argv[2])-1, get_tasks()[int(sys.argv[2])-1]),
    "list": lambda: list(map(lambda x: print(f"{x[0]+1}. {x[1]}"), enumerate(tasks))),
    "clear": lambda: aios_db.write("tasks", [t for t in tasks if not t.startswith("[x]")])
}
commands.get(command, commands["list"])()

programs/autollm/view_output.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file, db_output = (sys.argv + [""])[1], Path.home() / ".aios" / f"autollm_output_{(sys.argv + [''])[1]}.txt", aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", ((sys.argv + [""])[1],))
print(output_file.read_text() if output_file.exists() else (db_output[0][0] or "No output yet") if db_output else "No output yet")

programs/autollm/capture_output.py:
#!/usr/bin/env python3
import subprocess, sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file, cmd_type, model, task = sys.argv[1], Path.home() / ".aios" / f"autollm_output_{sys.argv[1]}.txt", sys.argv[2], sys.argv[3], " ".join(sys.argv[4:])
result = subprocess.run({"claude": ["claude", task], "claude-dangerous": ["claude", "--dangerously-skip-permissions", task], "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]}.get(cmd_type, ["echo", "Invalid command"]), capture_output=True, text=True, timeout=999999)
output = result.stdout + result.stderr
output_file.write_text(output)
list(map(lambda q: aios_db.execute(q[0], q[1], (output, job_id)), [("autollm", "UPDATE worktrees SET output=?, status='review' WHERE job_id=?"), ("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?")]))

programs/autollm/output_page.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file = (sys.argv + [""])[1], Path.home() / ".aios" / f"autollm_output_{(sys.argv + [''])[1]}.txt"
worktree = aios_db.query("autollm", "SELECT branch, task, model, status, output FROM worktrees WHERE job_id=?", (job_id,))
info = worktree[0] if worktree else ["unknown", "unknown", "unknown", "unknown", ""]
file_output = output_file.read_text() if output_file.exists() else (info[4] or "No output yet") if worktree else "No output yet"
list(map(print, [f"Branch: {info[0]}", f"Task: {info[1]}", f"Model: {info[2]}", f"Status: {info[3]}", f"Output:\n{file_output}"]))

programs/autollm/llm.py:
#!/usr/bin/env python3
import subprocess, sys
command, model, task = (sys.argv + ["claude"])[1], (sys.argv + ["", "claude-3-5-sonnet-20241022"])[2], " ".join(sys.argv[3:]) or "Improve this code"
subprocess.run({"claude": ["claude", "--dangerously-skip-permissions", task], "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]}.get(command, ["claude", "--dangerously-skip-permissions", task]), timeout=999999)

programs/autollm/llm_test.py:
#!/usr/bin/env python3
import sys
print(f"LLM called with: command={sys.argv[1]}, model={sys.argv[2]}, task={' '.join(sys.argv[3:])}")

programs/autollm/autollm.py:
#!/usr/bin/env python3
import subprocess, sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
command = (sys.argv + ["run"])[1]
create_and_launch = lambda repo, branch, model, task: (
    subprocess.run(["git", "worktree", "add", "-b", branch, str(Path(repo).parent / f"{Path(repo).name}-{branch}")], cwd=repo, capture_output=True, timeout=5),
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES (?, 'running')", (branch,)),
    aios_db.execute("autollm", "INSERT INTO worktrees(repo, branch, path, job_id, model, task, status) VALUES (?, ?, ?, ?, ?, ?, 'running')",
                    (repo, branch, str(Path(repo).parent / f"{Path(repo).name}-{branch}"), aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0], model, task)),
    subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_runner.py", "python3", "/home/seanpatten/projects/AIOS/programs/autollm/capture_output.py",
                     str(aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]),
                     "claude-dangerous" if model == "claude-dangerous" else "claude" if model.startswith("claude") else "codex", model, task],
                    cwd=str(Path(repo).parent / f"{Path(repo).name}-{branch}"), env={**subprocess.os.environ, "AIOS_TIMEOUT": "999999"})
)
commands = {
    "run": lambda: list(map(lambda i: create_and_launch((sys.argv + ["", "/home/seanpatten/projects/testRepoPrivate"])[2], f"autollm-{Path((sys.argv + ['', '/home/seanpatten/projects/testRepoPrivate'])[2]).name}-{i}", (sys.argv + ["", "", "", "claude-3-5-sonnet-20241022"])[4], " ".join(sys.argv[5:]) or "Improve code"), range(int((sys.argv + ["", "", "1"])[3])))),
    "status": lambda: list(map(lambda w: print(f"{w[0]}: {w[1]}"), aios_db.query("autollm", "SELECT branch, status FROM worktrees"))),
    "clean": lambda: (list(map(lambda w: subprocess.run(["git", "worktree", "remove", w[2]], cwd=w[0], capture_output=True, timeout=5), aios_db.query("autollm", "SELECT repo, branch, path FROM worktrees WHERE status='done'"))), aios_db.execute("autollm", "DELETE FROM worktrees WHERE status='done'")),
    "output": lambda: print((lambda r: (r[0][0] or "") if r else "")(aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", ((sys.argv + ["", ""])[2],)))),
    "accept": lambda: (aios_db.execute("autollm", "UPDATE worktrees SET status='done' WHERE job_id=?", ((sys.argv + ["", ""])[2],)), aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", ((sys.argv + ["", ""])[2],)))
}
commands.get(command, commands["run"])()

programs/autollm/reset.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

aios_db.execute("autollm", "DROP TABLE IF EXISTS worktrees")
aios_db.execute("autollm", "CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY, repo TEXT, branch TEXT, path TEXT, job_id INTEGER, model TEXT, task TEXT, status TEXT, output TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
print("Reset autollm database")

programs/autollm/terminal.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
worktree = aios_db.query("autollm", "SELECT path, output FROM worktrees WHERE job_id=?", (job_id,))
path = worktree[0][0]

output_file = Path(path) / ".autollm_output"
subprocess.run(["tail", "-f", str(output_file)], timeout=999999)

programs/autollm/monitor.py:
#!/usr/bin/env python3
import sys
import subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, model, task FROM worktrees")
list(map(lambda w: print(f"{w[0]}: {w[3]} | {w[4]} | {w[5][:30]}"), worktrees))

programs/workflow/workflow.py:
#!/usr/bin/env python3
import sys, json, subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
from pathlib import Path
from datetime import datetime

cmd = (sys.argv + ["list"])[1]

def get_workflows():
    try:
        return aios_db.read("workflows")
    except:
        aios_db.write("workflows", {})
        return {}

def get_nodes():
    try:
        return aios_db.read("workflow_nodes")
    except:
        aios_db.write("workflow_nodes", [])
        return []

def add_node():
    nodes = get_nodes()
    col = int((sys.argv + ["", "0"])[2])
    args = sys.argv[3:]
    folder = str(Path.cwd())
    text = " ".join(args)
    for i, arg in enumerate(args):
        if arg.startswith("/") and Path(arg).exists():
            folder = arg
            text = " ".join(args[:i] + args[i+1:])
            break
    node = {"id": len(nodes), "col": col, "text": text, "folder": folder, "parent": None, "children": [], "branch": None, "created": datetime.now().isoformat()}
    aios_db.write("workflow_nodes", nodes + [node])
    print(f"{node['id']}")

def list_nodes():
    cols = {}
    for n in get_nodes():
        cols.setdefault(n["col"], []).append(n)
    for c in sorted(cols.keys()):
        print(f"Column {c}:")
        list(map(lambda n: print(f"  {n['id']}: {n['text'][:50]}"), cols[c]))

def expand():
    nid = int((sys.argv + ["", "0"])[2])
    instruction = " ".join(sys.argv[3:])
    nodes = get_nodes()
    parent = nodes[nid]
    new_text = f"{parent['text']}\n{instruction}" if instruction else parent['text']
    child = {"id": len(nodes), "col": parent["col"] + 1, "text": new_text, "folder": parent["folder"], "parent": nid, "children": [], "branch": None, "created": datetime.now().isoformat()}
    nodes[nid]["children"].append(child["id"])
    aios_db.write("workflow_nodes", nodes + [child])
    print(f"{child['id']}")

def branch():
    nid = int((sys.argv + ["", "0"])[2])
    btype = (sys.argv + ["", "", "folder"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    folder = node["folder"]
    if btype == "worktree":
        branch_name = f"workflow-{nid}-{datetime.now():%Y%m%d%H%M%S}"
        path = f"{folder}-{branch_name}"
        subprocess.run(["git", "worktree", "add", "-b", branch_name, path], cwd=folder, capture_output=True, timeout=5)
        nodes[nid]["branch"] = {"type": "worktree", "path": path, "branch": branch_name}
    elif btype == "subfolder":
        path = f"{folder}/workflow-{nid}"
        Path(path).mkdir(parents=True, exist_ok=True)
        nodes[nid]["branch"] = {"type": "subfolder", "path": path}
    else:
        nodes[nid]["branch"] = {"type": "main", "path": folder}
    aios_db.write("workflow_nodes", nodes)
    print(nodes[nid]["branch"]["path"])

def worktree_with_terminal():
    """Create a worktree and return terminal session info for PTY"""
    repo = (sys.argv + ["", "/home/seanpatten/projects/AIOS"])[2]
    branch_name = (sys.argv + ["", ""])[3]

    # Generate branch name if empty or not provided
    if not branch_name or branch_name.strip() == "":
        branch_name = f"worktree_{datetime.now():%Y%m%d_%H%M%S}"

    # Create worktree path
    parent = Path(repo).parent
    worktree_path = parent / f"{Path(repo).name}_{branch_name}"

    # Create the worktree
    result = subprocess.run(
        ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
        cwd=repo,
        capture_output=True,
        text=True,
        timeout=10
    )

    if result.returncode != 0:
        print(json.dumps({"error": f"Failed to create worktree: {result.stderr}"}))
        return

    # Store worktree info
    try:
        worktrees = aios_db.read("worktrees_list")
    except:
        worktrees = []

    worktree_info = {
        "repo": str(repo),
        "branch": branch_name,
        "path": str(worktree_path),
        "created": datetime.now().isoformat()
    }
    worktrees.append(worktree_info)
    aios_db.write("worktrees_list", worktrees)

    # Return info for terminal creation
    print(json.dumps({
        "success": True,
        "branch": branch_name,
        "path": str(worktree_path),
        "message": f"Worktree created at {worktree_path}"
    }))

def execute():
    nid = int((sys.argv + ["", "0"])[2])
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    full_prompt = node["text"]
    parent_id = node.get("parent")
    while parent_id is not None:
        parent = nodes[parent_id]
        full_prompt = f"{parent['text']}\n{full_prompt}"
        parent_id = parent.get("parent")
    aios_db.execute("jobs", "INSERT INTO jobs(name, status, output) VALUES (?, 'running', ?)", (f"workflow-{nid}", node["text"]))
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["claude", "--dangerously-skip-permissions", full_prompt], cwd=path, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print(f"{job_id}")

def save_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    workflows[name] = {"nodes": get_nodes(), "saved": datetime.now().isoformat()}
    aios_db.write("workflows", workflows)
    print(f"Saved: {name}")

def load_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    aios_db.write("workflow_nodes", workflows.get(name, {}).get("nodes", []))
    print(f"Loaded: {name}")

def git_push():
    nid = int((sys.argv + ["", "0"])[2])
    msg = " ".join(sys.argv[3:]) or "workflow update"
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.run(["git", "add", "."], cwd=path, timeout=5)
    subprocess.run(["git", "commit", "-m", msg], cwd=path, timeout=5, capture_output=True)
    result = subprocess.run(["git", "push"], cwd=path, timeout=5, capture_output=True, text=True)
    if "no upstream branch" in result.stderr:
        branch_name = subprocess.run(["git", "branch", "--show-current"], cwd=path, capture_output=True, text=True, timeout=5).stdout.strip()
        subprocess.run(["git", "push", "--set-upstream", "origin", branch_name], cwd=path, timeout=5)
    print(f"Pushed: {path}")

def terminal():
    nid = int((sys.argv + ["", "0"])[2])
    term = (sys.argv + ["", "", "gnome-terminal"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.Popen([term, "--working-directory", path])
    print(f"Terminal: {path}")

def comment():
    nid = int((sys.argv + ["", "0"])[2])
    text = " ".join(sys.argv[3:])
    nodes = get_nodes()
    nodes[nid].setdefault("comments", []).append({"text": text, "time": datetime.now().isoformat(), "author": "human"})
    aios_db.write("workflow_nodes", nodes)
    print(f"Comment added to {nid}")

{"add": add_node, "list": list_nodes, "expand": expand, "branch": branch, "exec": execute, "save": save_workflow, "load": load_workflow, "push": git_push, "term": terminal, "comment": comment, "worktree_terminal": worktree_with_terminal}.get(cmd, list_nodes)()


programs/worktree/worktree_manager.py:
#!/usr/bin/env python3
import sys
import subprocess
import os
from pathlib import Path
from datetime import datetime
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

def create_worktree_with_terminal(repo_path=None, branch_name=None):
    """Create a new git worktree and open a terminal in it"""

    # Default to AIOS project if no repo specified
    if not repo_path or repo_path == '':
        repo_path = '/home/seanpatten/projects/AIOS'

    # Check if it's a git repository
    try:
        subprocess.run(["git", "status"], cwd=repo_path, capture_output=True, check=True)
    except:
        return {"error": "Not a git repository", "path": repo_path}

    # Generate branch name if not provided
    if not branch_name:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        branch_name = f"worktree_{timestamp}"

    # Create worktree path
    parent = Path(repo_path).parent
    worktree_path = parent / f"{Path(repo_path).name}_{branch_name}"

    # Create the worktree
    try:
        result = subprocess.run(
            ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
            cwd=repo_path,
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode != 0:
            return {"error": f"Failed to create worktree: {result.stderr}", "branch": branch_name}

        # Store worktree info in database
        try:
            worktrees = aios_db.read("worktrees_list")
        except:
            worktrees = []
        worktrees.append({
            "repo": str(repo_path),
            "branch": branch_name,
            "path": str(worktree_path),
            "created": datetime.now().isoformat()
        })
        aios_db.write("worktrees_list", worktrees)

        # Try to open terminal (different commands for different environments)
        terminal_opened = False
        terminal_commands = [
            ["gnome-terminal", "--working-directory", str(worktree_path)],
            ["xterm", "-e", f"cd {worktree_path} && bash"],
            ["konsole", "--workdir", str(worktree_path)],
            ["xfce4-terminal", "--working-directory", str(worktree_path)]
        ]

        for cmd in terminal_commands:
            try:
                subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                terminal_opened = True
                break
            except:
                continue

        return {
            "success": True,
            "branch": branch_name,
            "path": str(worktree_path),
            "terminal": terminal_opened
        }

    except Exception as e:
        return {"error": str(e)}

def list_worktrees():
    """List all worktrees"""
    try:
        result = subprocess.run(
            ["git", "worktree", "list"],
            capture_output=True,
            text=True
        )
        return result.stdout
    except:
        return "Not a git repository"

def remove_worktree(path):
    """Remove a worktree"""
    try:
        subprocess.run(["git", "worktree", "remove", path], check=True)
        return f"Removed worktree: {path}"
    except Exception as e:
        return f"Error removing worktree: {e}"

if __name__ == "__main__":
    command = sys.argv[1] if len(sys.argv) > 1 else "create"

    if command == "create":
        repo = sys.argv[2] if len(sys.argv) > 2 else None
        branch = sys.argv[3] if len(sys.argv) > 3 else None
        result = create_worktree_with_terminal(repo, branch)
        if "success" in result and result["success"]:
            print(f"Created worktree: {result['path']}")
            print(f"Branch: {result['branch']}")
            if result["terminal"]:
                print("Terminal opened in worktree")
        else:
            print(f"Error: {result.get('error', 'Unknown error')}")

    elif command == "list":
        print(list_worktrees())

    elif command == "remove":
        path = sys.argv[2] if len(sys.argv) > 2 else None
        if path:
            print(remove_worktree(path))
        else:
            print("Please specify path to remove")

services/web/web.py:
#!/usr/bin/env python3
import sys
sys.path.extend(['/home/seanpatten/projects/AIOS', '/home/seanpatten/projects/AIOS/core'])
from http.server import HTTPServer, BaseHTTPRequestHandler
import json, aios_db, subprocess, os, asyncio, websockets, pty, struct, fcntl, termios, signal
from urllib.parse import parse_qs, urlparse
from datetime import datetime
from pathlib import Path
from threading import Thread

TEMPLATE_DIR = Path(__file__).parent / 'templates'
WEB_PORT = int(sys.argv[2]) if len(sys.argv) > 2 else 8080

# Load templates
T = {}
template_files = {
    'index': 'index.html',
    'todo': 'todo.html',
    'jobs': 'jobs.html',
    'feed': 'feed.html',
    'autollm': 'autollm.html',
    'autollm_output': 'autollm_output.html',
    'terminal': 'terminal.html',
    'terminal_emulator': 'terminal-emulator.html',
    'terminal_xterm': 'terminal-xterm.html',
    'settings': 'settings.html',
    'workflow': 'workflow.html',
    'workflow_manager': 'workflow_manager.html'
}
for k, v in template_files.items():
    T[k] = (TEMPLATE_DIR / v).read_text()

class Handler(BaseHTTPRequestHandler):
    def _ctx(self):
        s = aios_db.read("settings") or {}
        c = {}
        c.update({
            'bg': {'light': '#fff'}.get(s.get('theme'), '#000'),
            'fg': {'light': '#000'}.get(s.get('theme'), '#fff'),
            'bg2': {'light': '#f0f0f0'}.get(s.get('theme'), '#1a1a1a')
        })
        return s, c

    def _get_todo_html(self, c):
        cmd = ["python3", "core/aios_runner.py", "python3", "programs/todo/todo.py", "list"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        tasks = result.stdout.strip().split('\n') if result.stdout.strip() else []

        task_html = []
        for i, t in enumerate(tasks):
            done_class = "done" if "[x]" in t else ""
            task_id = t.split(".")[0] if "." in t else str(i+1)
            html = f'''<div class="task {done_class}">{t}
                <form style="display:inline" action="/todo/done" method="POST">
                    <input type="hidden" name="id" value="{task_id}">
                    <button>Done</button>
                </form>
            </div>'''
            task_html.append(html)

        tasks_content = "".join(task_html) or '<div style="color:#888">No tasks yet</div>'
        return T['todo'].format(**c, tasks=tasks_content)

    def _get_feed_html(self, s, c):
        messages = aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp DESC LIMIT 100")

        if not messages:
            feed_content = "<div style='color:#888'>No messages yet</div>"
        else:
            seen_dates = []
            feed_items = []
            time_fmt = "12h" if s.get("time_format", "12h") == "12h" else "24h"

            for content, timestamp in messages:
                msg_date = datetime.fromisoformat(timestamp).date()

                # Add date header if new date
                if msg_date not in seen_dates:
                    seen_dates.append(msg_date)
                    date_html = f'<div style="color:#888;font-weight:bold;margin:15px 0 5px">{msg_date}</div>'
                    feed_items.append(date_html)

                # Format time
                dt = datetime.fromisoformat(timestamp)
                if time_fmt == "12h":
                    time_str = dt.strftime("%I:%M %p")
                else:
                    time_str = dt.strftime("%H:%M")

                # Add message
                msg_html = f'<div style="padding:8px;margin:2px 0">{time_str} - {content}</div>'
                feed_items.append(msg_html)

            feed_content = "".join(feed_items)

        return T['feed'].format(**c, feed_content=feed_content)

    def _get_settings_html(self, s, c):
        styles = {
            'theme_dark_style': 'style="font-weight:bold"' if s.get('theme', 'dark') == 'dark' else '',
            'theme_light_style': 'style="font-weight:bold"' if s.get('theme') == 'light' else '',
            'time_12h_style': 'style="font-weight:bold"' if s.get('time_format', '12h') == '12h' else '',
            'time_24h_style': 'style="font-weight:bold"' if s.get('time_format') == '24h' else ''
        }
        return T['settings'].format(**c, **styles)

    def _get_jobs_html(self, c):
        job_types = {'running_jobs': 'running', 'review_jobs': 'review', 'done_jobs': 'done'}
        job_data = {}

        for key, job_type in job_types.items():
            cmd = f"python3 services/jobs.py {job_type}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
            content = result.stdout.strip()
            job_data[key] = content or f'<div style="color:#888;padding:10px">No {job_type} jobs</div>'

        return T['jobs'].format(**c, **job_data)

    def _get_autollm_html(self, c):
        def format_running(w):
            branch, path, job_id, status, task, model = w
            output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
            if output_file.exists():
                output_text = output_file.read_text()[-200:]
            else:
                output_text = "Waiting for output..."

            return f'''<div class="worktree">
                <span class="status running">{branch}</span><br>
                {model}: {task[:30]}<br>
                <pre style="background:#000;padding:5px;margin:5px 0;max-height:100px;overflow-y:auto;font-size:10px">{output_text}</pre>
                <a href="/autollm/output?job_id={job_id}" style="padding:5px 10px;background:{c["fg"]};color:{c["bg"]};text-decoration:none;border-radius:3px">Full Output</a>
                <a href="/terminal?job_id={job_id}" style="padding:5px 10px;background:{c["fg"]};color:{c["bg"]};text-decoration:none;border-radius:3px;margin-left:5px">Terminal</a>
            </div>'''

        def format_review(w):
            branch, path, job_id, status, task, model, output = w
            output_preview = (output or "")[:50]
            return f'''<div class="worktree">
                <span class="status review">{branch}</span><br>
                {model}: {task[:30]}<br>
                Output: {output_preview}<br>
                <form action="/autollm/accept" method="POST" style="display:inline">
                    <input type="hidden" name="job_id" value="{job_id}">
                    <button>Accept</button>
                </form>
                <form action="/autollm/vscode" method="POST" style="display:inline">
                    <input type="hidden" name="path" value="{path}">
                    <button>VSCode</button>
                </form>
            </div>'''

        def format_done(w):
            branch = w[0]
            return f'<div class="worktree"><span class="status done">{branch}</span></div>'

        # Get worktrees
        all_worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, task, model, output FROM worktrees")

        # Filter and format
        running = [w for w in all_worktrees if len(w) > 3 and w[3] == 'running']
        review = [w for w in all_worktrees if len(w) > 3 and w[3] == 'review']
        done = [w for w in all_worktrees if len(w) > 3 and w[3] == 'done']

        worktree_data = {
            'running_worktrees': "".join([format_running(w[:6]) for w in running]) or '<div style="color:#888">No running worktrees</div>',
            'review_worktrees': "".join([format_review(w) for w in review]) or '<div style="color:#888">No review worktrees</div>',
            'done_worktrees': "".join([format_done(w) for w in done]) or '<div style="color:#888">No done worktrees</div>'
        }

        return T['autollm'].format(**c, **worktree_data)

    def _get_autollm_output(self, c, job_id):
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"

        if output_file.exists():
            output_content = output_file.read_text()
        else:
            result = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))
            output_content = result[0][0] if result else "No output yet"

        return T['autollm_output'].format(**c, output_content=output_content)

    def _get_terminal(self, c, job_id):
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
        terminal_content = output_file.read_text() if output_file.exists() else "Waiting for output..."
        return T['terminal'].format(**c, terminal_content=terminal_content, job_id=job_id)

    def _get_workflow_worktrees(self):
        cmd = ["git", "worktree", "list"]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
        lines = result.stdout.strip().split('\n') if result.stdout.strip() else []

        worktrees = []
        for line in lines:
            if line and len(line.split()) >= 3:
                parts = line.split()
                worktrees.append({
                    "path": parts[0],
                    "branch": parts[2].strip('[]')
                })

        return json.dumps(worktrees)

    def do_GET(self):
        p = urlparse(self.path)
        q = parse_qs(p.query)
        s, c = self._ctx()

        # Route handlers
        routes = {
            '/': lambda: (T['index'].format(**c), 'text/html'),
            '/api/jobs': lambda: (
                json.dumps([
                    {"id": j[0], "name": j[1], "status": j[2], "output": j[3]}
                    for j in aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")
                ]),
                'application/json'
            ),
            '/todo': lambda: (self._get_todo_html(c), 'text/html'),
            '/feed': lambda: (self._get_feed_html(s, c), 'text/html'),
            '/settings': lambda: (self._get_settings_html(s, c), 'text/html'),
            '/jobs': lambda: (self._get_jobs_html(c), 'text/html'),
            '/autollm': lambda: (self._get_autollm_html(c), 'text/html'),
            '/autollm/output': lambda: (
                self._get_autollm_output(c, q.get('job_id', [''])[0]),
                'text/html'
            ),
            '/terminal': lambda: (
                self._get_terminal(c, q.get('job_id', [''])[0]),
                'text/html'
            ),
            '/terminal-emulator': lambda: (
                T['terminal_emulator'].replace('ws://localhost:8766', f'ws://localhost:{WEB_PORT + 1000}'),
                'text/html'
            ),
            '/terminal-xterm': lambda: (
                T['terminal_xterm'].replace('ws://localhost:8766', f'ws://localhost:{WEB_PORT + 1000}'),
                'text/html'
            ),
            '/workflow': lambda: (T['workflow'].format(**c), 'text/html'),
            '/workflow-manager': lambda: (T['workflow_manager'].format(**c), 'text/html'),
            '/workflow/list_worktrees': lambda: (self._get_workflow_worktrees(), 'application/json'),
            '/api/workflow/nodes': lambda: (
                json.dumps(aios_db.read("workflow_nodes") or []),
                'application/json'
            )
        }

        # Get handler or default to index
        handler = routes.get(p.path, lambda: (T['index'].format(**c), 'text/html'))
        content, content_type = handler()

        # Send response
        self.send_response(200)
        self.send_header('Content-type', content_type)
        self.end_headers()
        self.wfile.write(content.encode())

    def do_POST(self):
        p = urlparse(self.path).path
        content_length = int(self.headers.get('Content-Length', 0))
        b = self.rfile.read(content_length) if content_length else b''

        # Handle workflow routes
        if p.startswith('/workflow/'):
            d = json.loads(b.decode() or '{}')

            if p == '/workflow/worktree_terminal':
                cmd = ["python3", "programs/workflow/workflow.py", "worktree_terminal",
                       d.get('repo', '/home/seanpatten/projects/AIOS'), d.get('branch', '')]
                r = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                output = json.loads(r.stdout) if r.stdout else {"error": "No output"}
                self.wfile.write(json.dumps(output).encode())
                return

            if p == '/workflow/remove_worktree':
                subprocess.run(["git", "worktree", "remove", d.get('path', '')], check=True, timeout=5)
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"success":true}')
                return

            # Other workflow commands
            workflow_cmds = {
                '/workflow/add': f"python3 programs/workflow/workflow.py add {d.get('col', 0)} {d.get('text', '')}",
                '/workflow/expand': f"python3 programs/workflow/workflow.py expand {d.get('id', 0)} {d.get('text', '')}",
                '/workflow/branch': f"python3 programs/workflow/workflow.py branch {d.get('id', 0)}",
                '/workflow/exec': f"python3 programs/workflow/workflow.py exec {d.get('id', 0)}",
                '/workflow/push': f"python3 programs/workflow/workflow.py push {d.get('id', 0)}",
                '/workflow/term': f"python3 programs/workflow/workflow.py term {d.get('id', 0)}",
                '/workflow/comment': f"python3 programs/workflow/workflow.py comment {d.get('id', 0)} {d.get('text', '')}",
                '/workflow/save': f"python3 programs/workflow/workflow.py save {d.get('name', 'default')}",
                '/workflow/load': f"python3 programs/workflow/workflow.py load {d.get('name', 'default')}"
            }

            if p in workflow_cmds:
                subprocess.run(workflow_cmds[p], shell=True, timeout=5, capture_output=True)
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"status":"ok"}')
            return

        # Handle shutdown
        if p == '/shutdown':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            html = b'<html><body><h1>Shutting down AIOS...</h1>'
            html += b'<script>setTimeout(function(){window.close();}, 2000);</script></body></html>'
            self.wfile.write(html)

            pids = aios_db.read("aios_pids") or {}
            for pid in pids.values():
                os.kill(pid, signal.SIGTERM)
            os._exit(0)

        # Handle restart
        if p == '/restart':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            html = b'<html><body><h1>Restarting AIOS...</h1>'
            html += b'<script>setTimeout(function(){location.href="/";}, 3000);</script></body></html>'
            self.wfile.write(html)

            def restart_aios():
                __import__('time').sleep(0.5)
                subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_start.py"])
                __import__('time').sleep(1)
                os._exit(0)

            Thread(target=restart_aios, daemon=True).start()
            return

        # Handle worktree creation
        if p == '/worktree/create':
            d = parse_qs(b.decode()) or {}
            cmd = ["python3", "/home/seanpatten/projects/AIOS/programs/worktree/worktree_manager.py",
                   "create", d.get('repo', [''])[0], d.get('branch', [''])[0]]
            r = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()

            if r.returncode == 0:
                output = r.stdout
            else:
                output = f"Error: {r.stderr}"

            html = f'<html><body><h2>Worktree Created</h2><pre>{output}</pre>'
            html += '<br><a href="/">Back to Control Center</a></body></html>'
            self.wfile.write(html.encode())
            return

        # Handle other commands
        d = parse_qs(b.decode()) or {}

        commands = {
            '/job/run': "python3 services/jobs.py run_wiki",
            '/job/accept': f"python3 services/jobs.py accept {d.get('id', [''])[0]}",
            '/job/redo': f"python3 services/jobs.py redo {d.get('id', [''])[0]}",
            '/run': d.get('cmd', [''])[0],
            '/todo/add': f"python3 programs/todo/todo.py add {d.get('task', [''])[0]}",
            '/todo/done': f"python3 programs/todo/todo.py done {d.get('id', [''])[0]}",
            '/todo/clear': "python3 programs/todo/todo.py clear",
            '/settings/theme': f"python3 programs/settings/settings.py set theme {d.get('theme', ['dark'])[0]}",
            '/settings/time': f"python3 programs/settings/settings.py set time_format {d.get('format', ['12h'])[0]}",
            '/autollm/run': f"python3 programs/autollm/autollm.py run {d.get('repo', [''])[0]} "
                           f"{d.get('branches', ['1'])[0]} {d.get('model', ['claude-3-5-sonnet-20241022'])[0]} "
                           f"{d.get('task', [''])[0]}",
            '/autollm/accept': f"python3 programs/autollm/autollm.py accept {d.get('job_id', [''])[0]}",
            '/autollm/vscode': f"code {d.get('path', [''])[0]}",
            '/autollm/clean': "python3 programs/autollm/autollm.py clean"
        }

        if p in commands:
            subprocess.run(commands[p], shell=True, timeout=5, capture_output=True)

        # Redirect based on path
        if 'autollm' in p:
            redirect = '/autollm'
        elif 'settings' in p:
            redirect = '/settings'
        else:
            redirect = p.replace('/add', '').replace('/done', '').replace('/clear', '')

        self.send_response(303)
        self.send_header('Location', redirect)
        self.end_headers()

    def log_message(self, *args):
        pass

async def client_handler(ws):
    # Open PTY
    master, slave = pty.openpty()

    # Set terminal size
    fcntl.ioctl(slave, termios.TIOCSWINSZ, struct.pack('HHHH', 24, 80, 0, 0))

    # Start bash process
    proc = await asyncio.create_subprocess_exec(
        'bash',
        stdin=slave,
        stdout=slave,
        stderr=slave,
        preexec_fn=os.setsid
    )

    os.close(slave)
    os.set_blocking(master, False)

    # Setup reading from PTY
    loop = asyncio.get_event_loop()

    def read_and_send():
        try:
            data = os.read(master, 65536)
            if data:
                asyncio.create_task(ws.send(data))
        except:
            pass

    loop.add_reader(master, read_and_send)

    try:
        async for msg in ws:
            if isinstance(msg, bytes):
                # Check if it's a resize command
                if msg[0:1] == b'{':
                    try:
                        d = json.loads(msg.decode())
                        if 'resize' in d:
                            rows = d['resize']['rows']
                            cols = d['resize']['cols']
                            fcntl.ioctl(master, termios.TIOCSWINSZ,
                                       struct.pack('HHHH', rows, cols, 0, 0))
                    except:
                        os.write(master, msg)
                else:
                    os.write(master, msg)
    finally:
        loop.remove_reader(master)
        proc.terminate()
        await proc.wait()
        os.close(master)

def serve_http(sock=None):
    s = HTTPServer(('', WEB_PORT), Handler, bind_and_activate=(sock is None))
    s.socket = sock if sock else s.socket
    s.serve_forever()

async def main():
    import socket

    # Get socket from parent if provided
    if len(sys.argv) > 1:
        sock = socket.fromfd(int(sys.argv[1]), socket.AF_INET, socket.SOCK_STREAM)
    else:
        sock = None

    # Start HTTP server in thread
    Thread(target=serve_http, args=(sock,), daemon=True).start()

    # Start WebSocket server
    ws_port = WEB_PORT + 1000
    try:
        async with websockets.serve(client_handler, 'localhost', ws_port):
            await asyncio.Future()
    except OSError:
        # Try alternate port if primary is busy
        async with websockets.serve(client_handler, 'localhost', WEB_PORT + 2000):
            await asyncio.Future()

asyncio.run(main())
