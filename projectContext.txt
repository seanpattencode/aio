Generated: 2025-10-01 13:51:29

aios_start.py:
#!/usr/bin/env python3
import subprocess, sys
sys.path.append('/home/seanpatten/projects/AIOS')
command = (sys.argv + ["start"])[1]
subprocess.run(["python3", f"/home/seanpatten/projects/AIOS/core/aios_{command}.py"] + sys.argv[2:])


core/aios_runner.py:
#!/usr/bin/env python3
import subprocess, sys, signal, os
cmd_str = ' '.join(sys.argv[1:]).lower()
timeout = float(os.getenv('AIOS_TIMEOUT', max([max([999999 * min(1, cmd_str.find(p) + 1) for p in ['web.py', 'aios_api.py', 'scheduler.py', 'poll', 'watch', 'serve', 'autollm', 'claude', 'codex']]), max([5.0 * min(1, cmd_str.find(p) + 1) for p in ['wiki_fetcher', 'scraper', 'gdrive', 'curl', 'wget', 'git', 'npm', 'pip']]), 0.1])))
signal.signal(signal.SIGALRM, sys.exit)
signal.setitimer(signal.ITIMER_REAL, timeout)
result = subprocess.run(sys.argv[1:], capture_output=True, text=True)
signal.alarm(0)
print(result.stdout, end='')
sys.stderr.write(str(result.stderr))
sys.exit(result.returncode)


core/aios_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
print(f"PIDs: {aios_db.read('aios_pids')}")


core/aios_stop.py:
#!/usr/bin/env python3
import subprocess, sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
subprocess.run(["pkill", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
subprocess.run(["pkill", "-f", "services/web/web.py"], stderr=subprocess.DEVNULL)
aios_db.write("aios_pids", {})
print("AIOS stopped")


core/aios_db.py:
import json, sqlite3, pathlib
d = sqlite3.connect(str(pathlib.Path(__file__).parent.parent / "data/aios.db"), isolation_level=None, check_same_thread=False)
d.execute("PRAGMA synchronous=0")
d.execute("PRAGMA journal_mode=MEMORY")
d.executescript("CREATE TABLE IF NOT EXISTS kv(k TEXT PRIMARY KEY,v TEXT);CREATE TABLE IF NOT EXISTS jobs(id INTEGER PRIMARY KEY,name TEXT,status TEXT,output TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY,content TEXT,timestamp TEXT,source TEXT,priority INTEGER DEFAULT 0);CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY,repo TEXT,branch TEXT,path TEXT,job_id INTEGER,model TEXT,task TEXT,status TEXT,output TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE IF NOT EXISTS events(id INTEGER PRIMARY KEY,target TEXT,data TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
def read(n):
    return json.loads(d.execute("SELECT v FROM kv WHERE k=?", (n,)).fetchone()[0])
def write(n, x):
    d.execute("INSERT OR REPLACE INTO kv VALUES(?,?)", (n, json.dumps(x, indent=2)))
    return x
def query(_, s, p=()):
    return d.execute(s, p).fetchall()
def execute(_, s, p=()):
    d.execute(s, p)


core/aios_start.py:
#!/usr/bin/env python3
import subprocess, time, sys, webbrowser
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
aios_path = Path.home() / ".aios"
start_time = time.time()
subprocess.run(["pkill", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
subprocess.run(["pkill", "-f", "services/web/web.py"], stderr=subprocess.DEVNULL)
aios_db.write("aios_pids", {})
aios_path.mkdir(exist_ok=True)
api_proc = subprocess.Popen(["python3", "core/aios_api.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
web_proc = subprocess.Popen(["python3", "services/web/web.py", "start", str(start_time)])
aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
elapsed = time.time() - start_time
{True: None, False: print(f"AIOS started in {elapsed:.3f}s: http://localhost:8080")}[elapsed > 0.05]
webbrowser.open("http://localhost:8080")
subprocess.Popen(["python3", "-c", "from services import context_generator; context_generator.generate()"], cwd="/home/seanpatten/projects/AIOS")


core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db, uvicorn
app = FastAPI()
@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)
@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())
@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)", (target, (await request.body()).decode()))
    return {"status": "ok"}
@app.get("/status")
async def status():
    aios_db.write("services", {})
    aios_db.write("tasks", [])
    aios_db.write("schedule", {})
    return {"services": aios_db.read("services"), "tasks": aios_db.read("tasks"), "schedule": aios_db.read("schedule")}
uvicorn.run(app, host="0.0.0.0", port=8000)

services/backup.py:
#!/usr/bin/env python3
import sys, shutil
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
from pathlib import Path
import aios_db
from datetime import datetime
aios_db.write("backup", {"source": str(Path.home()), "dest": "/tmp/backup"})
aios_db.write("backup_log", [])
config = aios_db.read("backup")
source = Path(config.get("source", Path.home()))
dest = Path(config.get("dest", "/tmp/backup")) / f"{datetime.now():%Y%m%d_%H%M%S}"
dest.parent.mkdir(parents=True, exist_ok=True)
shutil.copytree(source, dest, dirs_exist_ok=True)
aios_db.write("backup_log", aios_db.read("backup_log") + [{"time": datetime.now().isoformat(), "dest": str(dest)}])
print(f"Backed up to {dest}")

services/service.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("services", {})
services = aios_db.read("services")
command = (sys.argv + ["list"])[1]
name = (sys.argv + ["", None])[2]
def cmd_list():
    list(map(print, [f"{k}: {v.get('status', 'unknown')}" for k, v in services.items()]))
def cmd_start():
    aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "running"}})
def cmd_stop():
    aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "stopped"}})
def cmd_status():
    print({True: "specify service", False: services.get(name, {}).get("status", "unknown")}[name == None])
{"list": cmd_list, "start": cmd_start, "stop": cmd_stop, "status": cmd_status}.get(command, cmd_list)()

services/scraper.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import requests, aios_db
from bs4 import BeautifulSoup
from datetime import datetime
aios_db.write("scraper", {"urls": ["https://news.ycombinator.com"]})
config = aios_db.read("scraper")
def scrape_url(url):
    soup = BeautifulSoup(requests.get(url).text, 'html.parser')
    return {"url": url, "title": {True: "No title", False: soup.title.string}[soup.title == None], "time": datetime.now().isoformat()}
def print_result(r):
    print(f"{r['url']}: {r['title']}")
results = list(map(scrape_url, config.get("urls", [])))
aios_db.write("scraper_results", results)
list(map(print_result, results))

services/context_generator.py:
from pathlib import Path
from datetime import datetime
def generate():
    root = Path(__file__).parent.parent
    output = Path(root / "projectContext.txt")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    files = [f for f in root.rglob("*.py")]
    readme = root / "README.md"
    content = f"Generated: {timestamp}\n\n"
    content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in files])
    content += {True: "", False: f"\nREADME.md:\n{readme.read_text()}\n"}[readme.exists()]
    output.write_text(content)
    return str(output)

services/jobs.py:
#!/usr/bin/env python3
import sys, subprocess
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
cmd = (sys.argv + ["list"])[1]
job_id = (sys.argv + ["", None])[2]
jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")
def print_job(j):
    output_text = {True: (j[3] or 'No output')[:50], False: 'No output'}[j[3] != None]
    print(f"{j[0]}: {j[1]} - {j[2]} - {output_text}...")
def print_running(j):
    print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')
def print_review(j):
    output = {True: (j[3] or "")[:50] + "...", False: ""}[j[3] != None]
    print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
    print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
    print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')
def print_done(j):
    output = {True: (j[3] or "")[:50] + "...", False: ""}[j[3] != None]
    print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')
def is_running(j):
    return j[2] == "running"
def is_review(j):
    return j[2] == "review"
def is_done(j):
    return j[2] == "done"
def cmd_summary():
    running = list(filter(is_running, jobs))
    review = list(filter(is_review, jobs))
    done = list(filter(is_done, jobs))[:5]
    summary = []
    list(map(summary.extend, [[f"RUN {j[1]}" for j in running[:2]], [f"? {j[1]}" for j in review[:1]], [f"DONE {j[1]}" for j in done[:1]]]))
    list(map(print, summary[:4]))
def cmd_running():
    list(map(print_running, filter(is_running, jobs[:10])))
def cmd_review():
    list(map(print_review, filter(is_review, jobs[:10])))
def cmd_done():
    list(map(print_done, filter(is_done, jobs[:50])))
def cmd_run_wiki():
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    new_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(new_id)])
def cmd_accept():
    {True: None, False: aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))}[job_id == None]
def cmd_redo():
    {True: None, False: (aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),)), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)]))}[job_id == None]
def cmd_list():
    list(map(print_job, jobs[:20]))
{"summary": cmd_summary, "running": cmd_running, "review": cmd_review, "done": cmd_done, "run_wiki": cmd_run_wiki, "accept": cmd_accept, "redo": cmd_redo, "list": cmd_list}.get(cmd, cmd_list)()

services/processes.py:
#!/usr/bin/env python3
import sys, subprocess, json
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from pathlib import Path
command = (sys.argv + ["json"])[1]
name = (sys.argv + ["", None])[2]
def get_time(x):
    return x["time"]
def is_not_archive(f):
    return ('archive' not in f.parts) * ('__pycache__' not in f.parts)
def get_all_processes():
    aios_db.write("schedule", {})
    aios_db.write("aios_pids", {})
    schedule = aios_db.read("schedule")
    pids = aios_db.read("aios_pids")
    python_files = list(Path('/home/seanpatten/projects/AIOS').rglob('*.py'))
    scheduled = sorted([{"path": cmd, "type": "daily", "time": time, "status": "scheduled"} for time, cmd in schedule.get("daily", {}).items()] + [{"path": cmd, "type": "hourly", "time": f":{int(m):02d}", "status": "scheduled"} for m, cmd in schedule.get("hourly", {}).items()], key=get_time)
    ongoing = [{"path": f"{k}_pid_{v}", "type": "running", "status": "active"} for k, v in pids.items()]
    core = [{"path": str(f.relative_to(Path('/home/seanpatten/projects/AIOS'))), "type": "file", "status": "available"} for f in python_files]
    return {"scheduled": scheduled, "ongoing": ongoing, "core": core}
def cmd_json():
    print(json.dumps(get_all_processes()))
def print_process(p):
    print(f"{p['path']}: {p['status']}")
def cmd_list():
    all_procs = get_all_processes()
    list(map(print_process, all_procs.get("scheduled", [])))
    list(map(print_process, all_procs.get("ongoing", [])))
    list(map(print_process, all_procs.get("core", [])))
def cmd_start():
    {True: None, False: subprocess.Popen(['python3', name])}[name == None]
def cmd_stop():
    {True: None, False: subprocess.run(['pkill', '-f', name], timeout=5)}[name == None]
{"json": cmd_json, "list": cmd_list, "start": cmd_start, "stop": cmd_stop}.get(command, cmd_json)()

services/feed.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime
command = (sys.argv + ["list"])[1]
def cmd_add():
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (" ".join(sys.argv[2:]), datetime.now().isoformat(), "manual"))
def print_message(row):
    time_part = row[2].split('T')[1][:5]
    date_part = row[2].split('T')[0]
    print({True: f"{time_part} {row[1]}", False: f"{date_part} {time_part} {row[1]}"}[datetime.fromisoformat(row[2]).date() == datetime.now().date()])
def cmd_list():
    list(map(print_message, aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")))
def print_view_message(row, time_fmt):
    time_str = datetime.fromisoformat(row[2]).strftime(time_fmt)
    date_str = row[2].split('T')[0]
    print({True: f"{time_str} {row[1]}", False: f"{date_str} {time_str} {row[1]}"}[datetime.fromisoformat(row[2]).date() == datetime.now().date()])
def make_print_view(time_fmt):
    def print_wrapper(row):
        print_view_message(row, time_fmt)
    return print_wrapper
def cmd_view():
    aios_db.write('settings', {})
    settings = aios_db.read('settings')
    time_fmt = {True: '%I:%M %p', False: '%H:%M'}[settings.get('time_format', '12h') == '12h']
    messages = aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")
    list(map(make_print_view(time_fmt), messages))
def cmd_clear():
    aios_db.execute("feed", "DELETE FROM messages WHERE timestamp < datetime('now', '-7 days')")
{"add": cmd_add, "list": cmd_list, "view": cmd_view, "clear": cmd_clear}.get(command, cmd_list)()

programs/job_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import subprocess

command = sys.argv[1] if len(sys.argv) > 1 else "summary"
job_id = sys.argv[2] if len(sys.argv) > 2 else None

jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")

if command == "summary":
    running = [j for j in jobs if j[2] == "running"]
    review = [j for j in jobs if j[2] == "review"]
    done = [j for j in jobs if j[2] == "done"][:5]

    summary = []
    summary.extend([f"RUN {j[1]}" for j in running[:2]])
    summary.extend([f"? {j[1]}" for j in review[:1]])
    summary.extend([f"DONE {j[1]}" for j in done[:1]])

    for line in summary[:4]:
        print(line)

elif command == "running":
    running = [j for j in jobs if j[2] == "running"]
    for j in running[:10]:
        print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')

elif command == "review":
    review = [j for j in jobs if j[2] == "review"]
    for j in review[:10]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
        print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
        print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')

elif command == "done":
    done = [j for j in jobs if j[2] == "done"]
    for j in done[:50]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')

elif command == "run_wiki":
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

elif command == "accept" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))

elif command == "redo" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),))
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime
aios_db.write("ideas", [])
ideas = aios_db.read("ideas")
command = (sys.argv + ["list"])[1]
def score(idea):
    return len(idea.get('description', '')) * idea.get('impact', 1) / max(idea.get('effort', 1), 1)
def add():
    return aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}])
def print_item(x):
    print(f"{x[0]+1}. {x[1]['description']}")
def print_scored(x):
    print(f"{x[0]+1}. [{score(x[1]):.1f}] {x[1]['description']}")
def rank():
    list(map(print_scored, enumerate(sorted(ideas, key=score, reverse=True))))
def list_ideas():
    list(map(print_item, enumerate(ideas)))
def efficiency(x):
    return score(x)/x.get('effort', 5)
def pick():
    {False: print(f"Best: {sorted(ideas, key=efficiency, reverse=True)[0]['description']}"), True: None}[len(ideas) == 0]
{"add": add, "rank": rank, "list": list_ideas, "pick": pick}.get(command, list_ideas)()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
from pathlib import Path
import aios_db
from datetime import datetime
import concurrent.futures

components = sys.argv[1:] or []
build_dir = Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)

def build_component(name):
    result = subprocess.run(['echo', f'Building {name}'], capture_output=True, text=True, timeout=10)
    (build_dir / f"{name}.build").write_text(f"Built at {datetime.now()}")
    status_map = {0: "success"}
    return {"name": name, "status": status_map.get(result.returncode, "failed"), "time": datetime.now().isoformat()}

def print_result(r):
    print(f"{r['name']}: {r['status']}")

results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components))
list(map(print_result, results))
aios_db.write("build_log", [])
existing_log = aios_db.read("build_log")
aios_db.write("build_log", existing_log + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import schedule as sched
import subprocess
import aios_db

schedules = aios_db.read("schedule")

def run_cmd(cmd):
    return subprocess.run(cmd, shell=True, timeout=300)

def schedule_daily(item):
    t, cmd = item
    sched.every().day.at(t).do(run_cmd, cmd)

def schedule_hourly(item):
    m, cmd = item
    sched.every().hour.at(f":{int(m):02d}").do(run_cmd, cmd)

list(map(schedule_daily, schedules.get("daily", {}).items()))
list(map(schedule_hourly, schedules.get("hourly", {}).items()))

sched.run_pending()

programs/wiki_fetcher/wiki_fetcher.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
import urllib.request
import json

req = urllib.request.Request("https://en.wikipedia.org/api/rest_v1/page/random/summary", headers={'User-Agent': 'Mozilla/5.0'})
response = urllib.request.urlopen(req)
data = json.loads(response.read().decode())
output = f"{data.get('title', 'Unknown')}: {data.get('extract', 'No extract available')[:200]}..."
job_id = sys.argv[1:2] and sys.argv[1] or None

aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review', updated=CURRENT_TIMESTAMP WHERE id=?", (output, job_id)) or print(output)

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime
aios_db.write("tasks", [])
aios_db.write("daily_plan", {})
tasks = aios_db.read("tasks")
today = datetime.now().date()
plan = aios_db.read("daily_plan")
def is_pending(t):
    return (t.startswith("[x]") == False) * (t.startswith("[!]") == False)
def print_task(t):
    print(f"- {t}")
pending = list(filter(is_pending, tasks))
plan[str(today)] = pending[:10]
aios_db.write("daily_plan", plan)
list(map(print_task, plan[str(today)]))

programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = (sys.argv + ["list"])[1]
question = ' '.join(sys.argv[2:])

client = anthropic.Anthropic(api_key=(aios_db.read("api_keys") or {}).get("anthropic", ""))

def ask():
    response = client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text
    cache[question] = {"response": response, "time": datetime.now().isoformat()}
    aios_db.write("llm_cache", cache)
    print(response)
    return cache

def print_item(item):
    q, a = item
    print(f"Q: {q[:50]}... A: {a['response'][:50]}...")

def list_cache():
    list(map(print_item, cache.items()))
    return cache

def clear():
    return aios_db.write("llm_cache", {})

def stats():
    print(f"Cached queries: {len(cache)}")
    return len(cache)

actions = {"ask": ask, "list": list_cache, "clear": clear, "stats": stats}
actions.get(command, list_cache)()

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime, timedelta
command = (sys.argv + ["list"])[1]
def get_tasks():
    return aios_db.read("tasks")
tasks = get_tasks()
def add_task():
    task_text = ' '.join(sys.argv[2:])
    task_desc = task_text.split('@')[0].strip()
    new_task = f"[ ] {datetime.now():%Y-%m-%d %H:%M} {task_desc}"
    aios_db.write("tasks", get_tasks() + [new_task])
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Task: {task_desc}", datetime.now().isoformat(), "todo"))
def done_task():
    current_tasks = get_tasks()
    task_id = int(sys.argv[2]) - 1
    task = current_tasks[task_id]
    task_text = ' '.join(task.split()[3:])
    updated = list(current_tasks)
    updated[task_id] = task.replace("[ ]", "[x]")
    aios_db.write("tasks", updated)
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Completed: {task_text}", datetime.now().isoformat(), "todo"))
def print_task(item):
    i, t = item
    print(f"{i+1}. {t}")
def list_tasks():
    list(map(print_task, enumerate(tasks)))
def is_not_done(t):
    return t.startswith("[x]") == False
def clear_done():
    return aios_db.write("tasks", list(filter(is_not_done, tasks)))
{"list": list_tasks, "add": add_task, "done": done_task, "clear": clear_done}.get(command, list_tasks)()

programs/autollm/view_output.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
db_output = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))

print(output_file.read_text() * output_file.exists() or (db_output[0][0] or "No output yet") * bool(db_output) or "No output yet")

programs/autollm/capture_output.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = sys.argv[1]
output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"

cmd_type = sys.argv[2]
model = sys.argv[3]
task = " ".join(sys.argv[4:])

commands = {
    "claude": ["claude", task],
    "claude-dangerous": ["claude", "--dangerously-skip-permissions", task],
    "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]
}

result = subprocess.run(commands.get(cmd_type, ["echo", "Invalid command"]), capture_output=True, text=True, timeout=999999)
output_file.write_text(result.stdout + result.stderr)
aios_db.execute("autollm", "UPDATE worktrees SET output=?, status='review' WHERE job_id=?", (result.stdout + result.stderr, job_id))
aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?", (result.stdout + result.stderr, job_id))

programs/autollm/output_page.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
worktree = aios_db.query("autollm", "SELECT branch, task, model, status, output FROM worktrees WHERE job_id=?", (job_id,))

info = worktree[0] * bool(worktree) or ["unknown", "unknown", "unknown", "unknown", ""]
file_output = output_file.read_text() * output_file.exists() or (info[4] or "No output yet") * bool(worktree) or "No output yet"

print(f"Branch: {info[0]}")
print(f"Task: {info[1]}")
print(f"Model: {info[2]}")
print(f"Status: {info[3]}")
print(f"Output:\n{file_output}")

programs/autollm/llm.py:
#!/usr/bin/env python3
import subprocess
import sys

command = (sys.argv + ["claude"])[1]
model = (sys.argv + ["", "claude-3-5-sonnet-20241022"])[2]
task = " ".join(sys.argv[3:]) or "Improve this code"

commands = {
    "claude": ["claude", "--dangerously-skip-permissions", task],
    "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]
}

subprocess.run(commands.get(command, commands["claude"]), timeout=999999)

programs/autollm/llm_test.py:
#!/usr/bin/env python3
import sys
print(f"LLM called with: command={sys.argv[1]}, model={sys.argv[2]}, task={' '.join(sys.argv[3:])}")

programs/autollm/autollm.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

command = (sys.argv + ["run"])[1]

def run():
    repo = (sys.argv + ["", "/home/seanpatten/projects/testRepoPrivate"])[2]
    branches = int((sys.argv + ["", "1"])[3])
    model = (sys.argv + ["", "claude-3-5-sonnet-20241022"])[4]
    task = " ".join(sys.argv[5:]) or "Improve code"

    list(map(lambda i: create_and_launch(repo, f"autollm-{Path(repo).name}-{i}", model, task), range(branches)))

def create_and_launch(repo, branch, model, task):
    path = str(Path(repo).parent / f"{Path(repo).name}-{branch}")
    subprocess.run(["git", "worktree", "add", "-b", branch, path], cwd=repo, capture_output=True, timeout=5)
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES (?, 'running')", (branch,))
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    aios_db.execute("autollm", "INSERT INTO worktrees(repo, branch, path, job_id, model, task, status) VALUES (?, ?, ?, ?, ?, ?, 'running')",
                    (repo, branch, path, job_id, model, task))

    cmd_type = "claude-dangerous" * (model == "claude-dangerous") or "claude" * (model.startswith("claude")) or "codex"
    subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_runner.py", "python3", "/home/seanpatten/projects/AIOS/programs/autollm/capture_output.py", str(job_id), cmd_type, model, task], cwd=path, env={**subprocess.os.environ, "AIOS_TIMEOUT": "999999"})

def status():
    worktrees = aios_db.query("autollm", "SELECT branch, status FROM worktrees")
    list(map(lambda w: print(f"{w[0]}: {w[1]}"), worktrees))

def clean():
    done = aios_db.query("autollm", "SELECT repo, branch, path FROM worktrees WHERE status='done'")
    list(map(lambda w: subprocess.run(["git", "worktree", "remove", w[2]], cwd=w[0], capture_output=True, timeout=5), done))
    aios_db.execute("autollm", "DELETE FROM worktrees WHERE status='done'")

def output():
    job_id = (sys.argv + ["", ""])[2]
    result = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))
    print((result[0][0] or "") * bool(result) or "")

def accept():
    job_id = (sys.argv + ["", ""])[2]
    aios_db.execute("autollm", "UPDATE worktrees SET status='done' WHERE job_id=?", (job_id,))
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (job_id,))

{"run": run, "status": status, "clean": clean, "output": output, "accept": accept}.get(command, run)()

programs/autollm/reset.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

aios_db.execute("autollm", "DROP TABLE IF EXISTS worktrees")
aios_db.execute("autollm", "CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY, repo TEXT, branch TEXT, path TEXT, job_id INTEGER, model TEXT, task TEXT, status TEXT, output TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
print("Reset autollm database")

programs/autollm/terminal.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
worktree = aios_db.query("autollm", "SELECT path, output FROM worktrees WHERE job_id=?", (job_id,))
path = worktree[0][0]

output_file = Path(path) / ".autollm_output"
subprocess.run(["tail", "-f", str(output_file)], timeout=999999)

programs/autollm/monitor.py:
#!/usr/bin/env python3
import sys
import subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, model, task FROM worktrees")
list(map(lambda w: print(f"{w[0]}: {w[3]} | {w[4]} | {w[5][:30]}"), worktrees))

services/web/web.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
from http.server import HTTPServer, BaseHTTPRequestHandler
import json, aios_db, subprocess, os, asyncio, websockets, pty, struct, fcntl, termios
from urllib.parse import parse_qs, urlparse
from datetime import datetime
from pathlib import Path
from threading import Thread

TEMPLATE_DIR = Path(__file__).parent / 'templates'
TEMPLATE_INDEX = (TEMPLATE_DIR / 'index.html').read_text()
TEMPLATE_TODO = (TEMPLATE_DIR / 'todo.html').read_text()
TEMPLATE_JOBS = (TEMPLATE_DIR / 'jobs.html').read_text()
TEMPLATE_FEED = (TEMPLATE_DIR / 'feed.html').read_text()
TEMPLATE_AUTOLLM = (TEMPLATE_DIR / 'autollm.html').read_text()
TEMPLATE_AUTOLLM_OUTPUT = (TEMPLATE_DIR / 'autollm_output.html').read_text()
TEMPLATE_TERMINAL = (TEMPLATE_DIR / 'terminal.html').read_text()
TEMPLATE_TERMINAL_EMULATOR = (TEMPLATE_DIR / 'terminal-emulator.html').read_text()
TEMPLATE_TERMINAL_XTERM = (TEMPLATE_DIR / 'terminal-xterm.html').read_text()
TEMPLATE_SETTINGS = (TEMPLATE_DIR / 'settings.html').read_text()

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urlparse(self.path)
        path = parsed.path
        query = parse_qs(parsed.query)
        s = aios_db.read("settings") or {}
        c = {'bg': {'light': '#fff'}.get(s.get('theme'), '#000'), 'fg': {'light': '#000'}.get(s.get('theme'), '#fff'), 'bg2': {'light': '#f0f0f0'}.get(s.get('theme'), '#1a1a1a')}
        self.s = s
        self.c = c
        self.query = query
        handlers = {'/api/jobs': self.handle_api_jobs, '/': self.handle_home, '/todo': self.handle_todo, '/feed': self.handle_feed, '/settings': self.handle_settings, '/jobs': self.handle_jobs, '/autollm': self.handle_autollm, '/autollm/output': self.handle_autollm_output, '/terminal': self.handle_terminal, '/terminal-emulator': self.handle_terminal_emulator, '/terminal-xterm': self.handle_terminal_xterm}
        content, ctype = handlers.get(path, self.handle_default)()
        self.send_response(200)
        self.send_header('Content-type', ctype)
        self.end_headers()
        self.wfile.write(content.encode())

    def handle_default(self):
        return (TEMPLATE_INDEX.format(**self.c, vp="", tasks="", feed_content="", running_jobs="", review_jobs="", done_jobs=""), 'text/html')

    def handle_api_jobs(self):
        return (json.dumps(list(map(lambda j: {"id": j[0], "name": j[1], "status": j[2], "output": j[3]}, aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")))), 'application/json')

    def handle_home(self):
        return (TEMPLATE_INDEX.format(**self.c), 'text/html')

    def handle_todo(self):
        result = subprocess.run(["python3", "core/aios_runner.py", "python3", "programs/todo/todo.py", "list"], capture_output=True, text=True)
        tasks = result.stdout.strip().split('\n') or []
        tasks_html = "".join(list(map(lambda it: f'<div class="task {"done" * ("[x]" in it[1])}">{it[1]} <form style="display:inline" action="/todo/done" method="POST"><input type="hidden" name="id" value="{it[1].split(".")[0] or str(it[0]+1)}"><button>Done</button></form></div>', enumerate(tasks))))
        return TEMPLATE_TODO.format(**self.c, tasks=tasks_html or '<div style="color:#888">No tasks yet</div>'), 'text/html'

    def handle_feed(self):
        messages = aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp DESC LIMIT 100")
        time_format = self.s.get("time_format", "12h")
        feed_html = []
        self._dates = []
        def process_message(m):
            date_header = {True: f'<div style="color:#888;font-weight:bold;margin:15px 0 5px">{datetime.fromisoformat(m[1]).date()}</div>', False: ''}.get(datetime.fromisoformat(m[1]).date() not in self._dates, '')
            feed_html.append(date_header + f'<div style="padding:8px;margin:2px 0">{datetime.fromisoformat(m[1]).strftime({"12h": "%I:%M %p"}.get(time_format, "%H:%M"))} - {m[0]}</div>')
            self._dates.append(datetime.fromisoformat(m[1]).date())
        list(map(process_message, messages))
        return TEMPLATE_FEED.format(**self.c, feed_content="".join(feed_html) or "<div style='color:#888'>No messages yet</div>"), 'text/html'

    def handle_settings(self):
        theme_dark_style = {'dark': 'style="font-weight:bold"'}.get(self.s.get('theme', 'dark'), '')
        theme_light_style = {'light': 'style="font-weight:bold"'}.get(self.s.get('theme'), '')
        time_12h_style = {'12h': 'style="font-weight:bold"'}.get(self.s.get('time_format', '12h'), '')
        time_24h_style = {'24h': 'style="font-weight:bold"'}.get(self.s.get('time_format'), '')
        return TEMPLATE_SETTINGS.format(**self.c, theme_dark_style=theme_dark_style, theme_light_style=theme_light_style, time_12h_style=time_12h_style, time_24h_style=time_24h_style), 'text/html'

    def handle_jobs(self):
        running = subprocess.run("python3 services/jobs.py running", shell=True, capture_output=True, text=True, timeout=5)
        review = subprocess.run("python3 services/jobs.py review", shell=True, capture_output=True, text=True, timeout=5)
        done = subprocess.run("python3 services/jobs.py done", shell=True, capture_output=True, text=True, timeout=5)
        running_html = running.stdout.strip() or '<div style="color:#888;padding:10px">No running jobs</div>'
        review_html = review.stdout.strip() or '<div style="color:#888;padding:10px">No jobs in review</div>'
        done_html = done.stdout.strip() or '<div style="color:#888;padding:10px">No completed jobs</div>'
        return TEMPLATE_JOBS.format(**self.c, running_jobs=running_html, review_jobs=review_html, done_jobs=done_html), 'text/html'

    def handle_autollm(self):
        worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, task, model, output FROM worktrees")
        running = []
        review = []
        done = []
        for w in worktrees:
            if w[3] == 'running': running.append((w[0], w[1], w[2], w[4], w[5]))
            elif w[3] == 'review': review.append((w[0], w[1], w[2], w[4], w[5], w[6]))
            elif w[3] == 'done': done.append((w[0], w[1]))
        running_html = "".join(list(map(lambda w: f'<div class="worktree"><span class="status running">{w[0]}</span><br>{w[4]}: {w[3][:30]}<br><pre style="background:#000;padding:5px;margin:5px 0;max-height:100px;overflow-y:auto;font-size:10px">{((Path.home() / ".aios" / f"autollm_output_{w[2]}.txt").read_text()[-200:] if (Path.home() / ".aios" / f"autollm_output_{w[2]}.txt").exists() else "Waiting for output...")}</pre><a href="/autollm/output?job_id={w[2]}" style="padding:5px 10px;background:{self.c["fg"]};color:{self.c["bg"]};text-decoration:none;border-radius:3px">Full Output</a><a href="/terminal?job_id={w[2]}" style="padding:5px 10px;background:{self.c["fg"]};color:{self.c["bg"]};text-decoration:none;border-radius:3px;margin-left:5px">Terminal</a></div>', running))) or '<div style="color:#888">No running worktrees</div>'
        review_html = "".join(list(map(lambda w: f'<div class="worktree"><span class="status review">{w[0]}</span><br>{w[4]}: {w[3][:30]}<br>Output: {(w[5] or "")[:50]}<br><form action="/autollm/accept" method="POST" style="display:inline"><input type="hidden" name="job_id" value="{w[2]}"><button>Accept</button></form><form action="/autollm/vscode" method="POST" style="display:inline"><input type="hidden" name="path" value="{w[1]}"><button>VSCode</button></form></div>', review))) or '<div style="color:#888">No worktrees in review</div>'
        done_html = "".join(list(map(lambda w: f'<div class="worktree"><span class="status done">{w[0]}</span></div>', done))) or '<div style="color:#888">No completed worktrees</div>'
        return TEMPLATE_AUTOLLM.format(**self.c, running_worktrees=running_html, review_worktrees=review_html, done_worktrees=done_html), 'text/html'

    def handle_autollm_output(self):
        job_id = self.query.get('job_id', [''])[0]
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
        db_output = aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (job_id,))
        output_content = output_file.read_text() * output_file.exists() or (db_output[0][0] or "No output yet") * bool(db_output) or "No output yet"
        return TEMPLATE_AUTOLLM_OUTPUT.format(**self.c, output_content=output_content), 'text/html'

    def handle_terminal(self):
        job_id = self.query.get('job_id', [''])[0]
        output_file = Path.home() / ".aios" / f"autollm_output_{job_id}.txt"
        terminal_content = (output_file.exists() and output_file.read_text()) or "Waiting for output..."
        return TEMPLATE_TERMINAL.format(**self.c, terminal_content=terminal_content, job_id=job_id), 'text/html'

    def handle_terminal_emulator(self):
        return (TEMPLATE_TERMINAL_EMULATOR, 'text/html')

    def handle_terminal_xterm(self):
        return (TEMPLATE_TERMINAL_XTERM, 'text/html')

    def do_POST(self):
        path = urlparse(self.path).path
        length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(length) or b''
        data = parse_qs(body.decode()) or {}
        self.data = data
        post_handlers = {'/job/run': lambda: subprocess.run("python3 services/jobs.py run_wiki", shell=True, timeout=5), '/job/accept': lambda: subprocess.run(f"python3 services/jobs.py accept {self.data.get('id', [''])[0]}", shell=True, timeout=5), '/job/redo': lambda: subprocess.run(f"python3 services/jobs.py redo {self.data.get('id', [''])[0]}", shell=True, timeout=5), '/run': lambda: subprocess.run(self.data.get('cmd', [''])[0], shell=True, capture_output=True, text=True, timeout=5), '/todo/add': lambda: subprocess.run(f"python3 programs/todo/todo.py add {self.data.get('task', [''])[0]}", shell=True, timeout=5), '/todo/done': lambda: subprocess.run(f"python3 programs/todo/todo.py done {self.data.get('id', [''])[0]}", shell=True, timeout=5), '/todo/clear': lambda: subprocess.run("python3 programs/todo/todo.py clear", shell=True, timeout=5), '/settings/theme': lambda: aios_db.write('settings', {**(aios_db.read('settings') or {}), 'theme': self.data.get('theme', ['dark'])[0]}), '/settings/time': lambda: aios_db.write('settings', {**(aios_db.read('settings') or {}), 'time_format': self.data.get('format', ['12h'])[0]}), '/autollm/run': lambda: subprocess.run(["python3", "programs/autollm/autollm.py", "run", self.data.get('repo', [''])[0], self.data.get('branches', ['1'])[0], self.data.get('model', ['claude-3-5-sonnet-20241022'])[0], self.data.get('task', [''])[0]], timeout=5), '/autollm/accept': lambda: (aios_db.execute("autollm", "UPDATE worktrees SET status='done' WHERE job_id=?", (int(self.data.get('job_id', [''])[0]),)), aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(self.data.get('job_id', [''])[0]),))), '/autollm/vscode': lambda: subprocess.run(["code", self.data.get('path', [''])[0]]), '/autollm/clean': lambda: subprocess.run(["python3", "programs/autollm/autollm.py", "clean"], timeout=5)}
        handler = post_handlers.get(path, str)
        handler()
        self.send_response(303)
        self.send_header('Location', '/autollm' * ('autollm' in path) or '/settings' * ('settings' in path) or path.replace('/add', '').replace('/done', '').replace('/clear', ''))
        self.end_headers()

    def log_message(self, *args): pass

async def client_handler(ws):
    master, slave = pty.openpty()
    winsize = struct.pack('HHHH', 24, 80, 0, 0)
    fcntl.ioctl(slave, termios.TIOCSWINSZ, winsize)
    proc = await asyncio.create_subprocess_exec('bash', stdin=slave, stdout=slave, stderr=slave, preexec_fn=os.setsid)
    os.close(slave)
    os.set_blocking(master, False)
    loop = asyncio.get_event_loop()
    def read_output():
        try:
            data = os.read(master, 65536)
            if data: asyncio.create_task(ws.send(data))
        except (OSError, BlockingIOError): pass
    loop.add_reader(master, read_output)
    try:
        async for msg in ws:
            if isinstance(msg, bytes):
                try:
                    data = json.loads(msg.decode('utf-8'))
                    if 'resize' in data:
                        size = data['resize']
                        winsize = struct.pack('HHHH', size['rows'], size['cols'], 0, 0)
                        fcntl.ioctl(master, termios.TIOCSWINSZ, winsize)
                        if 'term' in data: os.environ['TERM'] = data['term']
                except: os.write(master, msg)
    finally:
        loop.remove_reader(master)
        proc.terminate()
        await proc.wait()
        os.close(master)

async def main():
    Thread(target=lambda: HTTPServer(('', 8080), Handler).serve_forever(), daemon=True).start()
    async with websockets.serve(client_handler, 'localhost', 8766):
        await asyncio.Future()

if __name__ == '__main__': asyncio.run(main())

