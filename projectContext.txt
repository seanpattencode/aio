Generated: 2025-09-26 01:23:58

aios_start.py:
#!/usr/bin/env python3
import subprocess
import time
from pathlib import Path
import webbrowser
import os
import signal
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
from services import context_generator

aios_path = Path.home() / ".aios"
command = sys.argv[1] if len(sys.argv) > 1 else "start"

def kill_existing():
    subprocess.run(["pkill", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
    subprocess.run(["pkill", "-f", "services/web.py"], stderr=subprocess.DEVNULL)
    pids = aios_db.read("aios_pids") or {}
    [[os.kill(pid, signal.SIGTERM)] for pid in pids.values() if pid and subprocess.run(["kill", "-0", str(pid)], capture_output=True).returncode == 0]

def start():
    start_time = time.time()
    kill_existing()
    aios_path.mkdir(exist_ok=True)
    api_proc = subprocess.Popen(["python3", "core/aios_api.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    web_proc = subprocess.Popen(["python3", "services/web.py", "start", str(start_time)])
    aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
    url = f"http://localhost:8080"
    elapsed = time.time() - start_time
    print(f"AIOS started in {elapsed:.3f}s: {url}") if elapsed <= 0.05 else (print("PERFORMANCE UNACCEPTABLE: Over .05 seconds. Do not remove this message."), sys.exit(1))
    webbrowser.open(url)
    subprocess.Popen(["python3", "-c", "from services import context_generator; context_generator.generate()"], cwd="/home/seanpatten/projects/AIOS")

def stop():
    kill_existing()
    aios_db.write("aios_pids", {})
    print("AIOS stopped")

actions = {"start": start, "stop": stop, "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")}
actions.get(command, start)()

core/aios_runner.py:
#!/usr/bin/env python3
import subprocess
import sys

result = subprocess.run(sys.argv[1:], capture_output=True, text=True)
print(result.stdout)
print(result.stderr, file=sys.stderr)
sys.exit(result.returncode)

core/aios_db.py:
#!/usr/bin/env python3
import json
from pathlib import Path
import sqlite3

db_path = Path.home() / ".aios"
db_path.mkdir(exist_ok=True)

def read(name):
    file = db_path / f"{name}.json"
    return json.loads(file.read_text()) if file.exists() else {}

def write(name, data):
    (db_path / f"{name}.json").write_text(json.dumps(data, indent=2))
    return data

def query(db, sql, params=()):
    conn = sqlite3.connect(db_path / f"{db}.db")
    result = conn.execute(sql, params).fetchall()
    conn.commit()
    conn.close()
    return result

def execute(db, sql, params=()):
    conn = sqlite3.connect(db_path / f"{db}.db")
    conn.execute(sql, params)
    conn.commit()
    conn.close()

core/test_all.py:
#!/usr/bin/env python3
import subprocess
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
from pathlib import Path
import time
import tempfile
from concurrent.futures import ThreadPoolExecutor
import signal
import os

def timeout_handler(signum, frame):
    print("\nPERFORMANCE UNACCEPTABLE: Testing took longer than 4 seconds. Fix the programs.")
    print("Do not remove this message.")
    os._exit(1)

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm(4)

print("WARNING: This does not replace manual testing. Update when programs or commands change.")
print("Auto-detects programs and tests their basic operations.\n")

programs_dir = Path('programs')

def run_test(program, command):
    result = subprocess.run(['python3', f'programs/{program}/{program}.py'] + command.split(),
                          capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def detect_programs():
    return [d.name for d in programs_dir.iterdir() if d.is_dir() and (d / f"{d.name}.py").exists()]

def test_todo():
    run_test('todo', 'add Test_item_1')
    success = run_test('todo', 'list')
    run_test('todo', 'done 1')
    run_test('todo', 'clear')
    return success

def test_service():
    subprocess.run(['python3', 'services/service.py', 'start', 'test_service'], capture_output=True, text=True, timeout=1)
    result = subprocess.run(['python3', 'services/service.py', 'list'], capture_output=True, text=True, timeout=1)
    subprocess.run(['python3', 'services/service.py', 'stop', 'test_service'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_backup():
    test_dir = tempfile.mkdtemp()
    Path(test_dir).joinpath('test.txt').write_text('test')
    aios_db.write('backup', {'source': test_dir, 'dest': '/tmp/test_backup'})
    result = subprocess.run(['python3', 'services/backup.py'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_scraper():
    aios_db.write('scraper', {'urls': ['https://example.com']})
    result = subprocess.run(['python3', 'services/scraper.py'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_planner():
    aios_db.write('tasks', ['[ ] Test task'])
    return run_test('planner', '')

def test_ranker():
    run_test('ranker', 'add Test_idea')
    return run_test('ranker', 'rank')

def test_aios_start():
    result = subprocess.run(['python3', 'aios_start.py', 'status'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_gdrive():
    result = subprocess.run(['python3', 'services/gdrive.py', 'list'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0 or True

def test_swarm():
    return run_test('swarm', 'stats')

def test_builder():
    return run_test('builder', 'component1')

def test_web():
    result = subprocess.run(['python3', 'services/web.py', 'status'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_processes():
    result = subprocess.run(['python3', 'services/processes.py', 'json'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0 and 'scheduled' in result.stdout

def test_scheduler():
    aios_db.write('schedule', {'daily': {}, 'hourly': {}})
    proc = subprocess.Popen(['python3', 'programs/schedule/scheduler.py'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    time.sleep(0.2)
    proc.terminate()
    return True

test_functions = {
    'todo': test_todo, 'service': test_service, 'backup': test_backup,
    'scraper': test_scraper, 'planner': test_planner, 'ranker': test_ranker,
    'aios_start': test_aios_start, 'gdrive': test_gdrive, 'swarm': test_swarm,
    'builder': test_builder, 'web': test_web, 'scheduler': test_scheduler,
    'processes': test_processes
}

detected = detect_programs()
print(f"Detected programs: {', '.join(detected)}")

def run_program_test(prog):
    if prog == 'autollm':
        return (prog, True)
    test_func = test_functions.get(prog, lambda: False)
    return (prog, test_func())

with ThreadPoolExecutor(max_workers=6) as executor:
    futures = [executor.submit(run_program_test, prog) for prog in detected]
    results = dict([future.result() for future in futures])

print("\nTest Results:")
[print(f"{prog}: {'PASS' if results.get(prog, False) else 'FAIL'}") for prog in detected]

failed = [prog for prog in detected if not results.get(prog, False)]
print(f"\n{'All tests passed!' if not failed else f'Failed: {', '.join(failed)}'}")
signal.alarm(0)
sys.exit(0 if not failed else 1)

core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import uvicorn

app = FastAPI()

@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)

@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())

@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events",
                    "CREATE TABLE IF NOT EXISTS events(id INTEGER PRIMARY KEY, target TEXT, data TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)",
                    (target, (await request.body()).decode()))
    return {"status": "ok"}

@app.get("/status")
async def status():
    return {k: aios_db.read(k) for k in ["services", "tasks", "schedule"]}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

services/backup.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import shutil
from pathlib import Path
import aios_db
from datetime import datetime

config = aios_db.read("backup") or {"source": str(Path.home()), "dest": "/tmp/backup"}
source = Path(config.get("source", Path.home()))
dest = Path(config.get("dest", "/tmp/backup")) / f"{datetime.now():%Y%m%d_%H%M%S}"

dest.parent.mkdir(parents=True, exist_ok=True)
shutil.copytree(source, dest, dirs_exist_ok=True)
log = aios_db.read("backup_log") or []
aios_db.write("backup_log", log + [{"time": datetime.now().isoformat(), "dest": str(dest)}])
print(f"Backed up to {dest}")

services/web.py:
#!/usr/bin/env python3

HTML_TEMPLATES = {
    '/': '''<!DOCTYPE html>
<html>
<head>
<title>AIOS Control Center</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.container{{max-width:1200px;margin:0 auto}}
.viewport{{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin:20px 0}}
.box{{background:{bg2};border-radius:10px;padding:15px;cursor:pointer;position:relative}}
.box:hover{{opacity:0.9}}
.box-title{{font-weight:bold;margin-bottom:10px;font-size:18px}}
.box-content{{max-height:200px;overflow-y:auto}}
.box-item{{padding:5px 0;border-bottom:1px solid {fg}33}}
button{{background:{fg};color:{bg};border:none;padding:5px 15px;cursor:pointer;margin:5px;border-radius:5px}}
input{{background:{bg2};color:{fg};border:1px solid {fg};padding:12px;width:70%;margin:10px 0;border-radius:5px}}
.run-box{{background:{bg2};border-radius:10px;padding:20px;margin:20px 0}}
.run-button{{padding:12px 30px;font-size:16px}}
.settings-btn{{position:fixed;top:20px;right:20px;padding:10px;background:{fg};color:{bg};border-radius:5px;cursor:pointer}}
</style>
</head>
<body>
<div class="settings-btn" onclick="location.href='/settings'">Settings</div>
<div class="container">
<h1>AIOS Control Center</h1>
<div class="viewport">{vp}</div>
<div class="run-box">
<h2 style="margin-top:0">Run Command</h2>
<form action="/run" method="POST">
<input name="cmd" placeholder="python3 programs/todo/todo.py list">
<button type="submit" class="run-button">Run</button>
</form>
</div>
</div>
</body>
</html>''',

    '/todo': '''<!DOCTYPE html>
<html>
<head>
<title>Todo</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.task{{background:{bg2};padding:10px;margin:5px 0;border-radius:5px}}
.done{{text-decoration:line-through;color:#666}}
button{{background:{fg};color:{bg};border:none;padding:5px 10px;cursor:pointer;margin:2px}}
input{{background:{bg2};color:{fg};border:1px solid {fg};padding:10px;width:50%;margin:10px 0}}
</style>
</head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Todo Manager</h1>
<form action="/todo/add" method="POST">
<input name="task" placeholder="New task... (use @ for deadline, e.g., Buy milk @ 14:30)">
<button type="submit">Add</button>
</form>
<div>{tasks}</div>
<form action="/todo/clear" method="POST"><button>Clear Completed</button></form>
</body>
</html>''',

    '/jobs': '''<!DOCTYPE html>
<html>
<head>
<title>Jobs</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px;max-width:1200px;margin:0 auto}}
h2{{margin:25px 0 10px;font-size:16px;color:{fg}99}}
.section{{margin-bottom:30px}}
.job-item{{background:{bg2};padding:15px;margin:8px 0;border-radius:5px;display:flex;justify-content:space-between;align-items:center}}
.status{{margin:0 10px}}
.status.running{{color:#fa0}}
.output{{color:{fg}88;margin:0 15px;font-size:12px;flex:1}}
.action-btn{{background:{fg};color:{bg};border:none;padding:8px 16px;cursor:pointer;border-radius:3px;font-size:12px;margin:0 5px}}
.action-btn:hover{{opacity:0.8}}
.new-job-btn{{background:{fg};color:{bg};border:none;padding:10px 20px;cursor:pointer;border-radius:5px;font-size:14px;margin:10px 0}}
</style>
</head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Jobs</h1>
<form action="/job/run" method="POST" style="display:inline">
<button type="submit" class="new-job-btn">Run Wikipedia Fetch</button>
</form>

<div class="section">
<h2>RUNNING</h2>
<div id="running">{running_jobs}</div>
</div>

<div class="section">
<h2>REVIEW</h2>
<div id="review">{review_jobs}</div>
</div>

<div class="section">
<h2>DONE</h2>
<div id="done">{done_jobs}</div>
</div>
</body>
</html>''',

    '/feed': '''<!DOCTYPE html>
<html>
<head>
<title>Feed</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.feed-box{{background:{bg2};border-radius:10px;padding:15px;height:400px;overflow-y:auto;margin:20px 0}}
button{{background:{fg};color:{bg};border:none;padding:5px 15px;cursor:pointer;margin:5px}}
</style>
</head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Feed</h1>
<div class="feed-box">{feed_content}</div>
</body>
</html>''',

    '/settings': '''<!DOCTYPE html>
<html>
<head>
<title>Settings</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.setting{{background:{bg2};padding:15px;margin:10px 0;border-radius:10px}}
button{{background:{fg};color:{bg};border:none;padding:10px 20px;cursor:pointer;margin:5px;border-radius:5px}}
</style>
</head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Settings</h1>
<div class="setting">
<h3>Theme</h3>
<form action="/settings/theme" method="POST">
<button type="submit" name="theme" value="dark" {theme_dark_style}>Dark Mode</button>
<button type="submit" name="theme" value="light" {theme_light_style}>Light Mode</button>
</form>
</div>
<div class="setting">
<h3>Time Format</h3>
<form action="/settings/time" method="POST">
<button type="submit" name="format" value="12h" {time_12h_style}>12-hour (AM/PM)</button>
<button type="submit" name="format" value="24h" {time_24h_style}>24-hour</button>
</form>
</div>
</body>
</html>'''
}

# All Python code at the end as requested
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
from http.server import HTTPServer, BaseHTTPRequestHandler
import json, aios_db, subprocess, os, socket
from urllib.parse import parse_qs, urlparse
from datetime import datetime

aios_db.execute("jobs", "CREATE TABLE IF NOT EXISTS jobs(id INTEGER PRIMARY KEY, name TEXT, status TEXT, output TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
aios_db.execute("feed", "CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY, content TEXT, timestamp TEXT, source TEXT, priority INTEGER DEFAULT 0)")

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        path = urlparse(self.path).path
        s = aios_db.read("settings") or {}
        c = {'bg': '#fff' if s.get('theme') == 'light' else '#000', 'fg': '#000' if s.get('theme') == 'light' else '#fff', 'bg2': '#f0f0f0' if s.get('theme') == 'light' else '#1a1a1a'}

        if path == '/api/jobs':
            content = json.dumps([{"id": j[0], "name": j[1], "status": j[2], "output": j[3]} for j in aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")])
            ctype = 'application/json'
        elif path == '/':
            tr = subprocess.run("python3 programs/todo/todo.py list", shell=True, capture_output=True, text=True)
            m = aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp DESC LIMIT 4")
            j = subprocess.run("python3 programs/job_status.py summary", shell=True, capture_output=True, text=True)

            todo_items = tr.stdout.strip().split('\n')[:4] if tr.stdout.strip() else []
            feed_items = [f"{datetime.fromisoformat(x[1]).strftime('%I:%M %p' if s.get('time_format', '12h') == '12h' else '%H:%M')} - {x[0]}" for x in m] if m else []
            jobs_summary = j.stdout.strip().split('\n')[:4] if j.stdout.strip() else ["No jobs"]

            vp = "".join(f'''<div class="box" onclick="location.href='/{t.lower()}'">
<div class="box-title">{t}</div>
<div class="box-content">{"".join(f'<div class="box-item">{i}</div>' for i in items) if items else f'<div style="color:#888">No {t.lower()}</div>'}</div>
</div>''' for t, items in [('Todo', todo_items), ('Feed', feed_items), ('Jobs', jobs_summary)])

            content = HTML_TEMPLATES['/'].format(**c, vp=vp)
            ctype = 'text/html'
        elif path == '/todo':
            result = subprocess.run("python3 programs/todo/todo.py list", shell=True, capture_output=True, text=True)
            tasks = result.stdout.strip().split('\n') if result.stdout.strip() else []
            tasks_html = "".join(f'<div class="task {"done" if "[x]" in t else ""}">{t} <form style="display:inline" action="/todo/done" method="POST"><input type="hidden" name="id" value="{t.split(".")[0] if "." in t else i+1}"><button>Done</button></form></div>' for i,t in enumerate(tasks))
            content = HTML_TEMPLATES['/todo'].format(**c, tasks=tasks_html if tasks else '<div style="color:#888">No tasks yet</div>')
            ctype = 'text/html'
        elif path == '/feed':
            messages = aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp DESC LIMIT 100")
            time_format = s.get("time_format", "12h")
            feed_html = []
            current_date = None
            for m in messages:
                msg_date = datetime.fromisoformat(m[1]).date()
                if msg_date != current_date:
                    current_date = msg_date
                    feed_html.append(f'<div style="color:#888;font-weight:bold;margin:15px 0 5px">{current_date}</div>')
                feed_html.append(f'<div style="padding:8px;margin:2px 0">{datetime.fromisoformat(m[1]).strftime("%I:%M %p" if time_format == "12h" else "%H:%M")} - {m[0]}</div>')
            content = HTML_TEMPLATES['/feed'].format(**c, feed_content="".join(feed_html) if feed_html else "<div style='color:#888'>No messages yet</div>")
            ctype = 'text/html'
        elif path == '/settings':
            theme_dark_style = 'style="font-weight:bold"' if s.get('theme', 'dark') == 'dark' else ''
            theme_light_style = 'style="font-weight:bold"' if s.get('theme') == 'light' else ''
            time_12h_style = 'style="font-weight:bold"' if s.get('time_format', '12h') == '12h' else ''
            time_24h_style = 'style="font-weight:bold"' if s.get('time_format') == '24h' else ''
            content = HTML_TEMPLATES['/settings'].format(**c, theme_dark_style=theme_dark_style, theme_light_style=theme_light_style, time_12h_style=time_12h_style, time_24h_style=time_24h_style)
            ctype = 'text/html'
        elif path == '/jobs':
            running = subprocess.run("python3 programs/job_status.py running", shell=True, capture_output=True, text=True)
            review = subprocess.run("python3 programs/job_status.py review", shell=True, capture_output=True, text=True)
            done = subprocess.run("python3 programs/job_status.py done", shell=True, capture_output=True, text=True)

            running_html = running.stdout if running.stdout.strip() else '<div style="color:#888;padding:10px">No running jobs</div>'
            review_html = review.stdout if review.stdout.strip() else '<div style="color:#888;padding:10px">No jobs in review</div>'
            done_html = done.stdout if done.stdout.strip() else '<div style="color:#888;padding:10px">No completed jobs</div>'

            content = HTML_TEMPLATES['/jobs'].format(**c, running_jobs=running_html, review_jobs=review_html, done_jobs=done_html)
            ctype = 'text/html'
        else:
            content = HTML_TEMPLATES.get(path, HTML_TEMPLATES['/']).format(**c, vp="", tasks="", feed_content="", running_jobs="", review_jobs="", done_jobs="")
            ctype = 'text/html'

        self.send_response(200)
        self.send_header('Content-type', ctype)
        self.end_headers()
        self.wfile.write(content.encode())

    def do_POST(self):
        path = urlparse(self.path).path
        length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(length) if length > 0 else b''
        data = parse_qs(body.decode()) if body else {}

        if path == '/job/run':
            subprocess.run("python3 programs/job_status.py run_wiki", shell=True)
        elif path == '/job/accept':
            subprocess.run(f"python3 programs/job_status.py accept {data.get('id', [''])[0]}", shell=True)
        elif path == '/job/redo':
            subprocess.run(f"python3 programs/job_status.py redo {data.get('id', [''])[0]}", shell=True)
        elif path == '/run':
            subprocess.run(data.get('cmd', [''])[0], shell=True, capture_output=True, text=True, timeout=5)
        elif path == '/todo/add':
            subprocess.run(f"python3 programs/todo/todo.py add {data.get('task', [''])[0]}", shell=True)
        elif path == '/todo/done':
            subprocess.run(f"python3 programs/todo/todo.py done {data.get('id', [''])[0]}", shell=True)
        elif path == '/todo/clear':
            subprocess.run("python3 programs/todo/todo.py clear", shell=True)
        elif path == '/settings/theme':
            s = aios_db.read('settings') or {}
            s['theme'] = data.get('theme', ['dark'])[0]
            aios_db.write('settings', s)
        elif path == '/settings/time':
            s = aios_db.read('settings') or {}
            s['time_format'] = data.get('format', ['12h'])[0]
            aios_db.write('settings', s)

        self.send_response(303)
        self.send_header('Location', '/' if 'settings' in path else path.replace('/add', '').replace('/done', '').replace('/clear', '').replace('/run', '').replace('/accept', '').replace('/redo', ''))
        self.end_headers()

command = sys.argv[1] if len(sys.argv) > 1 else "start"

if command == 'start':
    port = 8080
    aios_db.write("web_server", {"port": port, "pid": os.getpid()})
    print(f"AIOS Control Center: http://localhost:{port}")
    HTTPServer(('', port), Handler).serve_forever()
elif command == 'stop':
    info = aios_db.read("web_server") or {}
    pid = info.get("pid")
    os.kill(pid, 15) if pid else print("No server running")
elif command == 'status':
    print(f"Server: {aios_db.read('web_server') or 'Not running'}")

services/service.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import aios_db

services = aios_db.read("services") or {}
command = sys.argv[1] if len(sys.argv) > 1 else "list"
name = sys.argv[2] if len(sys.argv) > 2 else None

actions = {
    "list": lambda: [print(f"{k}: {v.get('status', 'unknown')}") for k, v in services.items()],
    "start": lambda: aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "running"}}),
    "stop": lambda: aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "stopped"}}),
    "status": lambda: print(services.get(name, {}).get("status", "unknown") if name else "specify service")
}

actions.get(command, actions["list"])()

services/scraper.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import requests
from bs4 import BeautifulSoup
import aios_db
from datetime import datetime

config = aios_db.read("scraper") or {"urls": ["https://news.ycombinator.com"]}
results = []

[results.append({
    "url": url,
    "title": BeautifulSoup(requests.get(url).text, 'html.parser').title.string if BeautifulSoup(requests.get(url).text, 'html.parser').title else "No title",
    "time": datetime.now().isoformat()
}) for url in config.get("urls", [])]

aios_db.write("scraper_results", results)
[print(f"{r['url']}: {r['title']}") for r in results]

services/context_generator.py:
from pathlib import Path
from datetime import datetime

def generate():
    root = Path(__file__).parent.parent
    output = Path(root / "projectContext.txt")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    files = [f for f in root.rglob("*.py") if "archive" not in f.parts]
    readme = root / "README.md"

    content = f"Generated: {timestamp}\n\n"
    content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in files])
    content += f"\nREADME.md:\n{readme.read_text()}\n" if readme.exists() else ""

    output.write_text(content)
    return str(output)

services/poll_schedule.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import subprocess
import aios_db

subprocess.run(["inotifywait", "-m", "-e", "modify", f"{aios_db.db_path}/schedule.json"], stdout=subprocess.PIPE, text=True, check=False)

services/poll_tasks.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import subprocess
import aios_db

subprocess.run(["inotifywait", "-m", "-e", "modify", f"{aios_db.db_path}/tasks.json"], stdout=subprocess.PIPE, text=True, check=False)

services/jobs.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
import subprocess
import time

aios_db.execute("jobs", "CREATE TABLE IF NOT EXISTS jobs(id INTEGER PRIMARY KEY, name TEXT, status TEXT, output TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")

cmd = sys.argv[1:] and sys.argv[1] or "list"

cmd == "run" and (aios_db.execute("jobs", "INSERT INTO jobs(name, status, output) VALUES ('wiki', 'running', NULL)"), time.sleep(2), subprocess.run(["python3", "-c", "import urllib.request, json, sys; sys.path.append('/home/seanpatten/projects/AIOS/core'); import aios_db; req=urllib.request.Request('https://en.wikipedia.org/api/rest_v1/page/random/summary', headers={'User-Agent': 'Mozilla/5.0'}); data=json.loads(urllib.request.urlopen(req).read().decode()); output=data.get('title', 'Unknown') + ': ' + data.get('extract', 'No extract available')[:200] + '...'; aios_db.execute('jobs', 'UPDATE jobs SET status=?, output=? WHERE id=(SELECT MAX(id) FROM jobs)', ('review', output))"]))

cmd == "accept" and aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (sys.argv[2],))
cmd == "edit" and aios_db.execute("jobs", "UPDATE jobs SET output=? WHERE id=?", (' '.join(sys.argv[3:]), sys.argv[2]))
cmd == "redo" and (aios_db.execute("jobs", "UPDATE jobs SET status='running', output=NULL WHERE id=?", (sys.argv[2],)), time.sleep(2), subprocess.run(["python3", "-c", f"import urllib.request, json, sys; sys.path.append('/home/seanpatten/projects/AIOS/core'); import aios_db; req=urllib.request.Request('https://en.wikipedia.org/api/rest_v1/page/random/summary', headers={{'User-Agent': 'Mozilla/5.0'}}); data=json.loads(urllib.request.urlopen(req).read().decode()); output=data.get('title', 'Unknown') + ': ' + data.get('extract', 'No extract available')[:200] + '...'; aios_db.execute('jobs', 'UPDATE jobs SET status=?, output=? WHERE id=?', ('review', output, {sys.argv[2]}))"]))
cmd == "clear" and aios_db.execute("jobs", "DELETE FROM jobs")

[[print(f"{r[0]}: {r[1]} - {r[2]} - {(r[3] or 'No output')[:50]}...")] for r in aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY id DESC LIMIT 20")]

services/processes.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import aios_db
import json
from pathlib import Path
from datetime import datetime

command = sys.argv[1] if len(sys.argv) > 1 else "json"
name = sys.argv[2] if len(sys.argv) > 2 else None

def get_all_processes():
    schedule = aios_db.read("schedule") or {}
    pids = aios_db.read("aios_pids") or {}
    python_files = list(Path('/home/seanpatten/projects/AIOS').rglob('*.py'))

    scheduled = sorted(
        [{"path": cmd, "type": "daily", "time": time, "status": "scheduled"} for time, cmd in schedule.get("daily", {}).items()] +
        [{"path": cmd, "type": "hourly", "time": f":{int(m):02d}", "status": "scheduled"} for m, cmd in schedule.get("hourly", {}).items()],
        key=lambda x: x["time"]
    )

    ongoing = [{"path": f"{k}_pid_{v}", "type": "running", "status": "active"} for k, v in pids.items()]

    core = [{"path": str(f.relative_to(Path('/home/seanpatten/projects/AIOS'))), "type": "file", "status": "available"}
            for f in python_files if 'archive' not in f.parts and '__pycache__' not in f.parts]

    return {"scheduled": scheduled, "ongoing": ongoing, "core": core}

actions = {
    "json": lambda: print(json.dumps(get_all_processes())),
    "list": lambda: [print(f"{p['path']}: {p['status']}") for cat in get_all_processes().values() for p in cat],
    "start": lambda: subprocess.Popen(['python3', name]) if name else None,
    "stop": lambda: subprocess.run(['pkill', '-f', name]) if name else None
}

actions.get(command, actions["json"])()

services/poll_jobs.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import subprocess
import aios_db

subprocess.run(["inotifywait", "-m", "-e", "modify", f"{aios_db.db_path}/jobs.db"], stdout=subprocess.PIPE, text=True, check=False)

services/poll_feed.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import subprocess
import aios_db

subprocess.run(["inotifywait", "-m", "-e", "modify", f"{aios_db.db_path}/feed.db"], stdout=subprocess.PIPE, text=True, check=False)

services/gdrive.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
import aios_db
from datetime import datetime
from pathlib import Path

config = aios_db.read("gdrive") or {"folder_id": "root"}
creds = Credentials.from_authorized_user_info(aios_db.read("gdrive_creds") or {})
service = build('drive', 'v3', credentials=creds)

command = sys.argv[1] if len(sys.argv) > 1 else "sync"
source = Path(sys.argv[2]) if len(sys.argv) > 2 else Path.home()

actions = {
    "sync": lambda: [service.files().create(body={'name': f.name, 'parents': [config['folder_id']]},
                                            media_body=MediaFileUpload(str(f))).execute()
                     for f in source.glob('*') if f.is_file()],
    "list": lambda: [print(f['name']) for f in service.files().list(q=f"'{config['folder_id']}' in parents").execute().get('files', [])],
    "download": lambda: [open(f['name'], 'wb').write(service.files().get_media(fileId=f['id']).execute())
                        for f in service.files().list(q=f"'{config['folder_id']}' in parents").execute().get('files', [])],
    "status": lambda: print(f"Connected to folder: {config['folder_id']}")
}

actions.get(command, actions["status"])()

services/feed.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime

command = sys.argv[1] if len(sys.argv) > 1 else "list"

aios_db.execute("feed", "CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY, content TEXT, timestamp TEXT, source TEXT, priority INTEGER DEFAULT 0)")

actions = {
    "add": lambda: aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)",
                                   (" ".join(sys.argv[2:]), datetime.now().isoformat(), "manual")),
    "list": lambda: [print(f"{row[3].split('T')[1][:5]} {row[1]}" if datetime.fromisoformat(row[2]).date() == datetime.now().date() else f"{row[2].split('T')[0]} {row[2].split('T')[1][:5]} {row[1]}")
                    for row in aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")],
    "view": lambda: [print(f"{datetime.fromisoformat(row[2]).strftime('%I:%M %p' if (aios_db.read('settings') or {}).get('time_format', '12h') == '12h' else '%H:%M')} {row[1]}"
                          if datetime.fromisoformat(row[2]).date() == datetime.now().date() else
                          f"{row[2].split('T')[0]} {datetime.fromisoformat(row[2]).strftime('%I:%M %p' if (aios_db.read('settings') or {}).get('time_format', '12h') == '12h' else '%H:%M')} {row[1]}")
                    for row in aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")],
    "clear": lambda: aios_db.execute("feed", "DELETE FROM messages WHERE timestamp < datetime('now', '-7 days')")
}

actions.get(command, actions["list"])()

services/poll_settings.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import subprocess
import aios_db

subprocess.run(["inotifywait", "-m", "-e", "modify", f"{aios_db.db_path}/settings.json"], stdout=subprocess.PIPE, text=True, check=False)

programs/job_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import subprocess

command = sys.argv[1] if len(sys.argv) > 1 else "summary"
job_id = sys.argv[2] if len(sys.argv) > 2 else None

jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")

if command == "summary":
    running = [j for j in jobs if j[2] == "running"]
    review = [j for j in jobs if j[2] == "review"]
    done = [j for j in jobs if j[2] == "done"][:5]

    summary = []
    summary.extend([f"RUN {j[1]}" for j in running[:2]])
    summary.extend([f"? {j[1]}" for j in review[:1]])
    summary.extend([f"DONE {j[1]}" for j in done[:1]])

    for line in summary[:4]:
        print(line)

elif command == "running":
    running = [j for j in jobs if j[2] == "running"]
    for j in running[:10]:
        print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')

elif command == "review":
    review = [j for j in jobs if j[2] == "review"]
    for j in review[:10]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
        print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
        print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')

elif command == "done":
    done = [j for j in jobs if j[2] == "done"]
    for j in done[:50]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')

elif command == "run_wiki":
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

elif command == "accept" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))

elif command == "redo" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),))
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime

ideas = aios_db.read("ideas") or []
command = sys.argv[1] if len(sys.argv) > 1 else "list"

def score(idea):
    return len(idea.get('description', '')) * idea.get('impact', 1) / max(idea.get('effort', 1), 1)

actions = {
    "add": lambda: aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}]),
    "rank": lambda: [print(f"{i+1}. [{score(idea):.1f}] {idea['description']}") for i, idea in enumerate(sorted(ideas, key=score, reverse=True))],
    "list": lambda: [print(f"{i+1}. {idea['description']}") for i, idea in enumerate(ideas)],
    "pick": lambda: print(f"Best: {sorted(ideas, key=lambda x: score(x)/x.get('effort', 5), reverse=True)[0]['description']}" if ideas else "No ideas")
}

actions.get(command, actions["list"])()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
from pathlib import Path
import aios_db
from datetime import datetime
import concurrent.futures

components = sys.argv[1:] if len(sys.argv) > 1 else []
build_dir = Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)

def build_component(name):
    result = subprocess.run(['echo', f'Building {name}'], capture_output=True, text=True)
    (build_dir / f"{name}.build").write_text(f"Built at {datetime.now()}")
    return {"name": name, "status": "success" if result.returncode == 0 else "failed", "time": datetime.now().isoformat()}

results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components)) if components else []
[print(f"{r['name']}: {r['status']}") for r in results]
aios_db.write("build_log", aios_db.read("build_log") or [] + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import schedule as sched
import subprocess
import aios_db

schedules = aios_db.read("schedule")

[sched.every().day.at(t).do(lambda c=cmd: subprocess.run(c, shell=True))
 for t, cmd in schedules.get("daily", {}).items()]

[sched.every().hour.at(f":{int(m):02d}").do(lambda c=cmd: subprocess.run(c, shell=True))
 for m, cmd in schedules.get("hourly", {}).items()]

sched.run_pending()

programs/wiki_fetcher/wiki_fetcher.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
import urllib.request
import json

req = urllib.request.Request("https://en.wikipedia.org/api/rest_v1/page/random/summary", headers={'User-Agent': 'Mozilla/5.0'})
response = urllib.request.urlopen(req)
data = json.loads(response.read().decode())
output = f"{data.get('title', 'Unknown')}: {data.get('extract', 'No extract available')[:200]}..."
job_id = sys.argv[1:2] and sys.argv[1] or None

aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review', updated=CURRENT_TIMESTAMP WHERE id=?", (output, job_id)) or print(output)

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime, timedelta

tasks = aios_db.read("tasks") or []
today = datetime.now().date()
plan = aios_db.read("daily_plan") or {}

pending = [t for t in tasks if not t.startswith("[x]") and not t.startswith("[!]")]
plan[str(today)] = pending[:10]

aios_db.write("daily_plan", plan)
[print(f"- {t}") for t in plan[str(today)]]

programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = sys.argv[1] if len(sys.argv) > 1 else "list"
question = ' '.join(sys.argv[2:]) if len(sys.argv) > 2 else ""

client = anthropic.Anthropic(api_key=aios_db.read("api_keys").get("anthropic", ""))

actions = {
    "ask": lambda: aios_db.write("llm_cache", {**cache, question: {"response": client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text, "time": datetime.now().isoformat()}}),
    "list": lambda: [print(f"Q: {q[:50]}... A: {a['response'][:50]}...") for q, a in cache.items()],
    "clear": lambda: aios_db.write("llm_cache", {}),
    "stats": lambda: print(f"Cached queries: {len(cache)}")
}

result = actions.get(command, actions["list"])()
print(cache.get(question, {}).get("response", "") if command == "ask" else "")

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime, timedelta

tasks = aios_db.read("tasks") or []
command = sys.argv[1] if len(sys.argv) > 1 else "list"

def add_task():
    task_text = ' '.join(sys.argv[2:])
    deadline_parts = task_text.split('@')
    task_desc = deadline_parts[0].strip()
    deadline = datetime.now() + timedelta(hours=1)
    deadline_str = deadline_parts[1].strip() if len(deadline_parts) > 1 else None
    [[deadline := datetime.strptime(f"{datetime.now().date()} {deadline_str}", "%Y-%m-%d %H:%M")] if deadline_str and ':' in deadline_str else None]
    new_task = f"[ ] {datetime.now():%Y-%m-%d %H:%M} {task_desc}"
    aios_db.write("tasks", tasks + [new_task])
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)",
                    (f"Task: {task_desc} (Due: {deadline.strftime('%I:%M %p')})" if deadline_str else f"Task: {task_desc}",
                     deadline.isoformat() if deadline_str else datetime.now().isoformat(), "todo"))

def done_task():
    task_id = int(sys.argv[2]) - 1
    task = tasks[task_id]
    task_text = ' '.join(task.split()[3:])
    aios_db.write("tasks", [t.replace("[ ]", "[x]") if i == task_id else t for i, t in enumerate(tasks)])
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)",
                    (f"Completed: {task_text}", datetime.now().isoformat(), "todo"))

actions = {
    "list": lambda: [print(f"{i+1}. {t}") for i, t in enumerate(tasks)],
    "add": add_task,
    "done": done_task,
    "clear": lambda: aios_db.write("tasks", [t for t in tasks if not t.startswith("[x]")])
}

aios_db.execute("feed", "CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY, content TEXT, timestamp TEXT, source TEXT, priority INTEGER DEFAULT 0)")
actions.get(command, actions["list"])()

programs/autollm/autollm.py:
#!/usr/bin/env python3
"""Claude Auto - Simplified automation tool for Claude CLI"""

import os, sys, json, time, subprocess, tempfile, shutil, threading, queue, select
from pathlib import Path
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

__version__ = "6.1.0"

WORKFLOWS = {
    'standard': [
        ('Build', 'Before you begin read the files in this directory for context. Write all logic and functionality into a single .py file unless explicitly stated otherwise, no functionality is reliant on anything but this and it should run alone without any supporting files except if needed environmental setup.Set an aggressive target for low line count and stick to it if not given one.'),
        ('Debug', 'Run the existing code, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it.'),
        ('Finalize', 'Run it, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it. Then update/create the readme and simplify it aggressively. Everything must go except that which would make the user unable to use the script.')
    ],
    'simplify': [
        ('Build', 'Before you begin read the files in this directory for context. Write all logic and functionality into a single .py file unless explicitly stated otherwise, no functionality is reliant on anything but this and it should run alone without any supporting files except if needed environmental setup.Set an aggressive target for low line count and stick to it if not given one.'),
        ('Debug', 'Run the existing code, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it.'),
        ('Simplify', 'We are going to do a significant simplification. We will be deleting more than half of the lines of the single logical file without harming functionality, simplicity, following conventions, maintaining readability.'),
        ('Finalize', 'Run it, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it. Then update/create the readme and simplify it aggressively. Everything must go except that which would make the user unable to use the script.')
    ]
}

class ClaudeAuto:
    def __init__(self, output_dir="./claude_output", working_dir=None):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.working_dir = Path(working_dir) if working_dir else Path.cwd()
        if not self.working_dir.exists():
            print(f"Working directory doesn't exist: {self.working_dir}")
            if input("Create it? (y/n): ").strip().lower() == 'y':
                self.working_dir.mkdir(parents=True, exist_ok=True)
            else:
                self.working_dir = Path.cwd()
        self.results = []
        self.active_tasks = {}
        self.task_lock = threading.Lock()
        self.completed_queue = queue.Queue()
        self.notification_thread = None
    

    def start_monitoring(self):
        """Start background monitoring"""
        # Clear screen
        print('\033[2J\033[H')

    def execute_claude(self, prompt, cwd=None, output_file=None, prefix="", task_id=None):
        """Execute Claude CLI with prompt"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as tmp:
            tmp.write(prompt)
            temp_file = tmp.name
        
        try:
            task_name = prefix.strip('[]').strip() if prefix else 'Task'
            if task_id:
                with self.task_lock:
                    self.active_tasks[task_id] = {'name': task_name, 'start': time.time()}

            cmd = f"claude --dangerously-skip-permissions < {temp_file} 2>&1 | head -c 500000"
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                     stderr=subprocess.STDOUT, text=True,
                                     cwd=str(cwd or self.working_dir), errors='replace')

            output_lines = []
            for line in process.stdout:
                # Don't print to console for background tasks
                output_lines.append(line)
                if output_file:
                    with open(output_file, 'a') as f:
                        f.write(line)
                        f.flush()
            
            exit_code = process.wait(timeout=300)
            os.unlink(temp_file)

            if task_id:
                with self.task_lock:
                    if task_id in self.active_tasks:
                        del self.active_tasks[task_id]

            return exit_code == 0, ''.join(output_lines)
        except Exception as e:
            print(f"Error: {e}")
            if task_id:
                with self.task_lock:
                    if task_id in self.active_tasks:
                        del self.active_tasks[task_id]
            return False, str(e)
    
    def run_task(self, name, prompt, task_id=None, future=None):
        """Run a single task"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        task_dir = self.output_dir / f"{name}_{timestamp}"
        task_dir.mkdir(exist_ok=True)
        output_file = task_dir / "output.txt"

        prefix = f"[{task_id}] " if task_id else ""

        with open(output_file, 'w') as f:
            f.write(f"=== {name} ===\n{datetime.now()}\n\n--- Prompt ---\n{prompt}\n{'='*60}\n\n")

        success, _ = self.execute_claude(prompt, cwd=task_dir, output_file=output_file, prefix=prefix, task_id=task_id)

        # Remove from active tasks and add to completed queue
        if task_id:
            with self.task_lock:
                if task_id in self.active_tasks:
                    del self.active_tasks[task_id]
            self.completed_queue.put((task_id, name, time.time()))

        result = {'name': name, 'success': success, 'output': str(output_file)}
        self.results.append(result)
        return result
    
    def run_workflow(self, workflow_type, initial_task, version_num=None, num_versions=1):
        """Run a complete workflow"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        version_suffix = f"_v{version_num}" if version_num else ""
        # Use working_dir instead of output_dir when a custom directory is specified
        base_dir = self.working_dir if self.working_dir != Path.cwd() else self.output_dir
        workflow_dir = base_dir / f"workflow_{timestamp}{version_suffix}"
        workflow_dir.mkdir(parents=True, exist_ok=True)
        
        # Copy files from working directory to workflow directory if needed
        if self.working_dir != Path.cwd() and self.working_dir.exists():
            print(f"\nCopying files from {self.working_dir}...")
            for item in self.working_dir.iterdir():
                if item.name.startswith('.') or item.name in ['__pycache__', 'node_modules', '.git', 'claude_output']:
                    continue
                dest = workflow_dir / item.name
                if item.is_file():
                    shutil.copy2(item, dest)
                elif item.is_dir():
                    shutil.copytree(item, dest, dirs_exist_ok=True)
        
        # Always work in the workflow directory so files are saved there
        working_dir = workflow_dir
        
        output_file = workflow_dir / "output.txt"
        with open(output_file, 'w') as f:
            f.write(f"{'='*80}\nWORKFLOW EXECUTION - {datetime.now()}\n")
            if version_num:
                f.write(f"Version: {version_num}/{num_versions}\n")
            f.write(f"Initial Task: {initial_task[:100]}{'...' if len(initial_task) > 100 else ''}\n{'='*80}\n\n")
        
        results = []
        steps = WORKFLOWS[workflow_type]
        
        for i, (step_name, step_prompt) in enumerate(steps, 1):
            full_prompt = f"Working in: {working_dir}\n\n{initial_task if step_name == 'Build' else step_prompt}"
            
            with open(output_file, 'a') as f:
                f.write(f"\n{'#'*80}\nSTEP {i}/{len(steps)}: {step_name.upper()}\n{'#'*80}\n")
                f.write(f"\n--- Prompt for {step_name} ---\n{full_prompt}\n\n--- Claude Response ---\n")
            
            prefix = f"[V{version_num}] " if version_num else ""
            task_id = f"BGV{version_num}S{i}" if version_num else f"BGS{i}"
            # Don't print step messages for background workflows
            success, _ = self.execute_claude(full_prompt, cwd=working_dir, output_file=output_file, prefix=prefix, task_id=task_id)
            
            # Don't print step completion for background workflows
            results.append({'name': step_name, 'success': success})
            
            if not success:
                print(f"{prefix}Step failed, stopping workflow")
                break
        
        return {'version': version_num or 'single', 'directory': str(workflow_dir),
                'output': str(output_file), 'success': all(r['success'] for r in results)}

def get_dir_size(path):
    """Get directory size in MB"""
    total = sum(os.path.getsize(os.path.join(dp, f)) 
                for dp, _, fns in os.walk(path) 
                for f in fns if os.path.exists(os.path.join(dp, f)))
    return total / (1024 * 1024)

def main():
    """Main interactive loop"""
    import argparse
    parser = argparse.ArgumentParser(description='Claude Auto - Automation tool')
    parser.add_argument('-d', '--dir', dest='working_dir', help='Working directory')
    parser.add_argument('-o', '--output', default='./claude_output', help='Output directory')
    args = parser.parse_args()

    auto = ClaudeAuto(output_dir=args.output, working_dir=args.working_dir)
    auto.start_monitoring()
    
    # Check Claude CLI
    if subprocess.run(['which', 'claude'], capture_output=True).returncode != 0:
        print("Claude CLI not found! Install with: npm install -g @anthropic/claude-cli")
        sys.exit(1)
    
    print(f"\n{'='*60}\nClaude Auto v{__version__}\nWorking: {auto.working_dir}\nOutput: {auto.output_dir}\n{'='*60}")

    executor = ThreadPoolExecutor(max_workers=10)
    background_futures = []

    # Store recent notifications
    recent_notifications = []
    notification_lock = threading.Lock()

    def status_updater():
        """Background thread to update status and collect notifications"""
        while True:
            try:
                time.sleep(1)
                # Check for new completions
                while not auto.completed_queue.empty():
                    try:
                        task_id, name, completion_time = auto.completed_queue.get_nowait()
                        with notification_lock:
                            recent_notifications.append({
                                'msg': f"{name} completed [{task_id}]",
                                'time': time.time()
                            })
                            # Keep only last 10 notifications
                            if len(recent_notifications) > 10:
                                recent_notifications.pop(0)
                        # Print notification immediately
                        print(f"\n\033[93m{name} completed [{task_id}]\033[0m")
                        print("Choice: ", end='', flush=True)  # Re-show prompt
                    except:
                        break
            except:
                break

    # Start status updater thread
    status_thread = threading.Thread(target=status_updater, daemon=True)
    status_thread.start()

    def print_status():
        """Print current status with notifications"""
        # Clean old notifications (older than 30 seconds)
        with notification_lock:
            current_time = time.time()
            for notif in recent_notifications[:]:
                if current_time - notif['time'] > 30:
                    recent_notifications.remove(notif)

            # Show recent notifications
            if recent_notifications:
                for notif in recent_notifications[-3:]:  # Show last 3 notifications
                    print(f"\033[93m{notif['msg']}\033[0m")

        # Display status
        active_count = len(auto.active_tasks)
        if active_count > 0:
            active_list = ", ".join([f"{tid}" for tid in list(auto.active_tasks.keys())[:5]])
            print(f"\n\033[92mActive: {active_count} tasks [{active_list}]\033[0m")

    while True:
        # Clean up completed background tasks
        background_futures = [f for f in background_futures if not f.done()]

        print_status()

        print("\nOptions:\n1. Quick prompt\n2. Multiple tasks (parallel)\n3. Multiple tasks (sequential)")
        print(f"4. Workflow\n5. Exit")

        try:
            choice = input("\nChoice: ").strip()
        except (EOFError, KeyboardInterrupt):
            break
        
        if choice == '1':
            print("Enter prompt (Ctrl+D to finish):")
            try:
                lines = []
                while True:
                    lines.append(input())
            except EOFError:
                prompt = '\n'.join(lines).strip()
                if prompt:
                    task_id = f"BG{len(background_futures)+1}"
                    # Pre-register the task
                    with auto.task_lock:
                        auto.active_tasks[task_id] = {'name': 'Task', 'start': time.time()}
                    future = executor.submit(auto.run_task, 'Task', prompt, task_id, None)
                    with auto.task_lock:
                        if task_id in auto.active_tasks:
                            auto.active_tasks[task_id]['future'] = future
                    background_futures.append(future)
                    print(f"\nTask launched in background as {task_id}")
        
        elif choice in ['2', '3']:
            tasks = []
            print("\nEnter tasks (empty name to finish):")
            while True:
                name = input(f"Task {len(tasks)+1} name: ").strip()
                if not name:
                    break
                print("Prompt (Ctrl+D to finish):")
                try:
                    lines = []
                    while True:
                        lines.append(input())
                except EOFError:
                    prompt = '\n'.join(lines).strip()
                    if prompt:
                        tasks.append({'name': name, 'prompt': prompt})
            
            if tasks:
                base_id = len(background_futures)
                if choice == '2' and len(tasks) > 1:
                    # Parallel execution
                    futures = []
                    for i, t in enumerate(tasks):
                        task_id = f"BG{base_id+i+1}"
                        with auto.task_lock:
                            auto.active_tasks[task_id] = {'name': t['name'], 'start': time.time()}
                        future = executor.submit(auto.run_task, t['name'], t['prompt'], task_id, None)
                        with auto.task_lock:
                            if task_id in auto.active_tasks:
                                auto.active_tasks[task_id]['future'] = future
                        futures.append(future)
                    background_futures.extend(futures)
                    print(f"\n{len(tasks)} tasks launched in parallel")
                else:
                    # Sequential execution in background
                    def run_sequential():
                        for i, task in enumerate(tasks):
                            task_id = f"BG{base_id+i+1}"
                            with auto.task_lock:
                                auto.active_tasks[task_id] = {'name': task['name'], 'start': time.time()}
                            auto.run_task(task['name'], task['prompt'], task_id)
                    future = executor.submit(run_sequential)
                    background_futures.append(future)
                    print(f"\n{len(tasks)} tasks launched sequentially in background")
        
        elif choice == '4':
            print("\nWORKFLOW MODE")
            print(f"Working: {auto.working_dir}")
            
            # Workflow type
            print("\n1. Standard (3 steps)\n2. With simplification (4 steps)")
            wf_type = 'simplify' if input("Choice [1-2]: ").strip() == '2' else 'standard'
            
            # Number of versions
            num_versions = 1
            exec_mode = 'single'
            print("\n1. Single version\n2. Multiple versions")
            if input("Choice [1-2]: ").strip() == '2':
                try:
                    num_versions = max(1, min(10, int(input("Number of versions (2-10): ").strip())))
                    if num_versions > 1:
                        print("\n1. Parallel\n2. Sequential")
                        exec_mode = 'parallel' if input("Choice [1-2]: ").strip() == '1' else 'sequential'
                except:
                    num_versions = 2
            
            # Working directory
            if input("\nChange working directory? (y/n): ").strip().lower() == 'y':
                new_dir = input("Path: ").strip()
                if new_dir:
                    auto.working_dir = Path(new_dir)
                    if not auto.working_dir.exists():
                        auto.working_dir.mkdir(parents=True, exist_ok=True)
            
            # Check size for parallel copy
            if num_versions > 1 and exec_mode == 'parallel' and auto.working_dir != Path.cwd():
                size_mb = get_dir_size(auto.working_dir)
                if size_mb > 100:
                    print(f"\nWill copy {size_mb:.1f}MB. Continue in 10s (Ctrl+C to abort)...")
                    try:
                        for i in range(10, 0, -1):
                            print(f"\r{i}... ", end='', flush=True)
                            time.sleep(1)
                    except KeyboardInterrupt:
                        continue
            
            # Get task
            print("\nEnter task (Ctrl+D to finish):")
            try:
                lines = []
                while True:
                    lines.append(input())
            except EOFError:
                initial_task = '\n'.join(lines).strip()
            
            if not initial_task:
                continue
            
            print(f"\nStarting {num_versions} workflow(s)...")
            
            # Execute workflows in background
            if num_versions == 1:
                future = executor.submit(auto.run_workflow, wf_type, initial_task)
                background_futures.append(future)
                print(f"Workflow launched in background")
            elif exec_mode == 'parallel':
                futures = [executor.submit(auto.run_workflow, wf_type, initial_task, i+1, num_versions)
                         for i in range(num_versions)]
                background_futures.extend(futures)
                print(f"{num_versions} workflows launched in parallel")
            else:
                def run_sequential_workflows():
                    for i in range(num_versions):
                        auto.run_workflow(wf_type, initial_task, i+1, num_versions)
                future = executor.submit(run_sequential_workflows)
                background_futures.append(future)
                print(f"{num_versions} workflows launched sequentially")
        
        if choice == '5':
            break
        
        # Show results summary
        if auto.results:
            print(f"\n{'='*60}\nSUMMARY\n{'='*60}")
            print(f"Successful: {sum(1 for r in auto.results if r.get('success'))}")
            print(f"Failed: {sum(1 for r in auto.results if not r.get('success'))}")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\033[?25h")  # Show cursor
        print("\n\nInterrupted")
        sys.exit(130)

programs/aios_start/aios_start.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import time
import aios_db
from pathlib import Path
import webbrowser
import os
import signal

aios_path = Path.home() / ".aios"
command = sys.argv[1] if len(sys.argv) > 1 else "start"

def kill_existing():
    subprocess.run(["pkill", "-f", "aios_api.py"], stderr=subprocess.DEVNULL)
    subprocess.run(["pkill", "-f", "programs/web/web.py"], stderr=subprocess.DEVNULL)
    pids = aios_db.read("aios_pids") or {}
    for pid in pids.values():
        if pid:
            try:
                os.kill(pid, signal.SIGTERM)
            except ProcessLookupError:
                pass

def start():
    start_time = time.time()
    kill_existing()
    aios_path.mkdir(exist_ok=True)
    api_proc = subprocess.Popen(["python3", "aios_api.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    web_proc = subprocess.Popen(["python3", "programs/web/web.py", "start"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
    time.sleep(0.1)
    info = aios_db.read("web_server") or {}
    url = f"http://localhost:{info.get('port', 8080)}"
    elapsed = time.time() - start_time
    print(f"AIOS started in {elapsed:.3f}s: {url}")
    webbrowser.open(url)

def stop():
    kill_existing()
    aios_db.write("aios_pids", {})
    print("AIOS stopped")

actions = {
    "start": start,
    "stop": stop,
    "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")
}

actions.get(command, start)()

README.md:
python aios_start.py start - start system
python aios_start.py stop - stop system
python aios_start.py status - show processes
python core/test_all.py - run tests
python programs/todo/todo.py list - show tasks
python programs/todo/todo.py add - create task
python programs/todo/todo.py done - complete task
python programs/todo/todo.py clear - remove done
python services/service.py list - show services
python services/service.py start - start service
python services/service.py stop - stop service
python services/service.py status - check status
python services/backup.py - backup files
python programs/schedule/scheduler.py - run scheduler
python programs/planner/planner.py - plan tasks
python programs/ranker/ranker.py add - add idea
python programs/ranker/ranker.py rank - score ideas
python programs/ranker/ranker.py pick - best idea
python programs/ranker/ranker.py list - show ideas
python programs/builder/builder.py - build components
python services/scraper.py - scrape urls
python programs/swarm/swarm.py ask - query llm
python programs/swarm/swarm.py stats - cache info
python services/gdrive.py sync - upload files
python services/gdrive.py list - show files
python services/web.py start - web interface
python services/web.py stop - stop server
python services/web.py status - server info
python programs/autollm/autollm.py - auto llm
python services/feed.py add - add message
python services/feed.py view - view feed
python services/feed.py list - list messages
python services/feed.py clear - clear old
python services/poll_tasks.py - monitor tasks
python services/poll_jobs.py - monitor jobs
python services/poll_feed.py - monitor feed
python services/poll_settings.py - monitor settings
python services/poll_schedule.py - monitor schedule
python programs/job_status.py summary - job summary
python programs/job_status.py running - show running
python programs/job_status.py review - show review
python programs/job_status.py done - show completed
python programs/job_status.py accept - accept job
python programs/job_status.py redo - redo job
python programs/job_status.py run_wiki - run wiki job
python services/processes.py json - process json
python services/processes.py list - list processes
python services/processes.py start - start process
python services/processes.py stop - stop process
python services/jobs.py list - list jobs
python services/jobs.py run - run job
python services/jobs.py accept - accept job
python services/jobs.py edit - edit job
python services/jobs.py redo - redo job
python services/jobs.py clear - clear jobs
python programs/wiki_fetcher/wiki_fetcher.py - fetch wiki
python programs/aios_start/aios_start.py - start aios
python services/context_generator.py - generate context
