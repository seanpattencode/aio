Generated: 2025-10-02 16:35:36

aios_start.py:
#!/usr/bin/env python3
import subprocess, sys
sys.path.append('/home/seanpatten/projects/AIOS')
command = (sys.argv + ["start"])[1]
subprocess.run(["python3", f"/home/seanpatten/projects/AIOS/core/aios_{command}.py"] + sys.argv[2:])


core/aios_runner.py:
#!/usr/bin/env python3
import subprocess, sys, signal, os, operator
cmd_str = ' '.join(sys.argv[1:]).lower()
timeout = float(os.getenv('AIOS_TIMEOUT', max([*[999999 * bool(cmd_str.find(p) + 1) for p in ['web.py', 'aios_api.py', 'scheduler.py', 'poll', 'watch', 'serve', 'autollm', 'claude', 'codex']], *[5.0 * bool(cmd_str.find(p) + 1) for p in ['wiki_fetcher', 'scraper', 'gdrive', 'curl', 'wget', 'git', 'npm', 'pip']], 0.1])))
signal.signal(signal.SIGALRM, lambda *_: sys.exit(1))
signal.setitimer(signal.ITIMER_REAL, timeout)
result = subprocess.run(sys.argv[1:], capture_output=True, text=True)
signal.alarm(0)
sys.stdout.write(result.stdout), sys.stderr.write(result.stderr), sys.exit(result.returncode)


core/aios_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
print(f"PIDs: {aios_db.read('aios_pids')}")


core/aios_stop.py:
#!/usr/bin/env python3
import subprocess, sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
subprocess.run(["pkill", "-9", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
subprocess.run(["pkill", "-9", "-f", "services/web/web.py"], stderr=subprocess.DEVNULL)
aios_db.write("aios_pids", {})
print("AIOS stopped")


core/aios_db.py:
import json, sqlite3, pathlib
d = sqlite3.connect(str(pathlib.Path(__file__).parent.parent / "data/aios.db"), isolation_level=None, check_same_thread=False)
[d.execute(p) for p in ["PRAGMA synchronous=0", "PRAGMA journal_mode=MEMORY"]]
d.executescript("CREATE TABLE IF NOT EXISTS kv(k TEXT PRIMARY KEY,v TEXT);CREATE TABLE IF NOT EXISTS jobs(id INTEGER PRIMARY KEY,name TEXT,status TEXT,output TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY,content TEXT,timestamp TEXT,source TEXT,priority INTEGER DEFAULT 0);CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY,repo TEXT,branch TEXT,path TEXT,job_id INTEGER,model TEXT,task TEXT,status TEXT,output TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP);CREATE TABLE IF NOT EXISTS events(id INTEGER PRIMARY KEY,target TEXT,data TEXT,created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
read = lambda n: json.loads(d.execute("SELECT v FROM kv WHERE k=?", (n,)).fetchone()[0])
write = lambda n, x: (d.execute("INSERT OR REPLACE INTO kv VALUES(?,?)", (n, json.dumps(x, indent=2))), x)[1]
query = lambda _, s, p=(): d.execute(s, p).fetchall()
execute = lambda _, s, p=(): d.execute(s, p)


core/aios_start.py:
#!/usr/bin/env python3
import subprocess, time, sys, socket, webbrowser
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
find_free_port = lambda: (lambda sk: (sk.bind(('', 0)), sk.getsockname()[1], sk.close())[1])(socket.socket())
aios_path, start_time = Path.home() / ".aios", time.time()
aios_path.mkdir(exist_ok=True)
web_port, api_port = find_free_port(), find_free_port()
aios_db.write("ports", {"web": web_port, "api": api_port}), aios_db.write("aios_pids", {})
web_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
[web_sock.setsockopt(socket.SOL_SOCKET, opt, 1) for opt in [socket.SO_REUSEADDR, socket.SO_REUSEPORT]]
web_sock.bind(('', web_port)), web_sock.listen(5)
api_proc = subprocess.Popen(["python3", "core/aios_api.py", str(api_port)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
web_proc = subprocess.Popen(["python3", "services/web/web.py", str(web_sock.fileno()), str(web_port), str(api_port)], pass_fds=[web_sock.fileno()])
web_sock.close()
aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
print(f"AIOS started in {time.time()-start_time:.3f}s: http://localhost:{web_port}"), webbrowser.open(f"http://localhost:{web_port}")
subprocess.Popen(["python3", "-c", "from services import context_generator; context_generator.generate()"], cwd="/home/seanpatten/projects/AIOS")

core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db, uvicorn
app = FastAPI()
@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)
@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())
@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)", (target, (await request.body()).decode()))
    return {"status": "ok"}
@app.get("/status")
async def status():
    aios_db.write("services", {})
    aios_db.write("tasks", [])
    aios_db.write("schedule", {})
    return {"services": aios_db.read("services"), "tasks": aios_db.read("tasks"), "schedule": aios_db.read("schedule")}

# Get port from command line argument or default to 8000
api_port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
uvicorn.run(app, host="0.0.0.0", port=api_port)

services/backup.py:
#!/usr/bin/env python3
import sys, shutil
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
from pathlib import Path
import aios_db
from datetime import datetime
[aios_db.write(*x) for x in [("backup", {"source": str(Path.home()), "dest": "/tmp/backup"}), ("backup_log", [])]]
dest = Path((c := aios_db.read("backup")).get("dest", "/tmp/backup")) / f"{(n := datetime.now()):%Y%m%d_%H%M%S}"
[dest.parent.mkdir(parents=True, exist_ok=True), shutil.copytree(Path(c.get("source", str(Path.home()))), dest, dirs_exist_ok=True), aios_db.write("backup_log", aios_db.read("backup_log") + [{"time": n.isoformat(), "dest": str(dest)}]), print(f"Backed up to {dest}")]

services/service.py:
#!/usr/bin/env python3
import sys
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
aios_db.write("services", {})
s, c, n = aios_db.read("services"), (sys.argv + ["list"])[1], (sys.argv + ["", None])[2]
{"list": lambda: list(map(print, [f"{k}: {v.get('status', 'unknown')}" for k, v in s.items()])), "start": lambda: aios_db.write("services", {**s, n: {**s.get(n, {}), "status": "running"}}), "stop": lambda: aios_db.write("services", {**s, n: {**s.get(n, {}), "status": "stopped"}}), "status": lambda: print({True: "specify service", False: s.get(n, {}).get("status", "unknown")}[n == None])}.get(c, lambda: list(map(print, [f"{k}: {v.get('status', 'unknown')}" for k, v in s.items()])))()

services/scraper.py:
#!/usr/bin/env python3
import sys, requests
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from bs4 import BeautifulSoup
from datetime import datetime
aios_db.write("scraper", {"urls": ["https://news.ycombinator.com"]})
results = [{"url": u, "title": (s := BeautifulSoup(requests.get(u, timeout=0.01).text, 'html.parser')).title.string or "No title", "time": datetime.now().isoformat()} for u in aios_db.read("scraper").get("urls", [])]
[aios_db.write("scraper_results", results), list(map(lambda r: print(f"{r['url']}: {r['title']}"), results))]

services/context_generator.py:
from pathlib import Path
from datetime import datetime
def generate():
    root = Path(__file__).parent.parent
    output = Path(root / "projectContext.txt")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    files = [f for f in root.rglob("*.py")]
    readme = root / "README.md"
    content = f"Generated: {timestamp}\n\n"
    content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in files])
    content += {True: "", False: f"\nREADME.md:\n{readme.read_text()}\n"}[readme.exists()]
    output.write_text(content)
    return str(output)

services/jobs.py:
#!/usr/bin/env python3
import sys, subprocess
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
c, jid, j = (sys.argv + ["list"])[1], (sys.argv + ["", None])[2], aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")
pj = lambda x: print(f"{x[0]}: {x[1]} - {x[2]} - {({True: (x[3] or 'No output')[:50], False: 'No output'}[x[3] != None])}...")
pr = lambda x: print(f'<div class="job-item">{x[1]} <span class="status running">Running...</span></div>')
prv = lambda x: [print(f'<div class="job-item">{x[1]} <span class="output">{({True: (x[3] or "")[:50] + "...", False: ""}[x[3] != None])}</span>'), print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{x[0]}"><button class="action-btn">Accept</button></form>'), print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{x[0]}"><button class="action-btn">Redo</button></form></div>')]
pd = lambda x: print(f'<div class="job-item">{x[1]} <span class="output">{({True: (x[3] or "")[:50] + "...", False: ""}[x[3] != None])}</span></div>')
{"summary": lambda: (r := list(filter(lambda x: x[2] == "running", j)), rv := list(filter(lambda x: x[2] == "review", j)), d := list(filter(lambda x: x[2] == "done", j))[:5], s := [], list(map(s.extend, [[f"RUN {x[1]}" for x in r[:2]], [f"? {x[1]}" for x in rv[:1]], [f"DONE {x[1]}" for x in d[:1]]])), list(map(print, s[:4])))[-1], "running": lambda: list(map(pr, filter(lambda x: x[2] == "running", j[:10]))), "review": lambda: list(map(prv, filter(lambda x: x[2] == "review", j[:10]))), "done": lambda: list(map(pd, filter(lambda x: x[2] == "done", j[:50]))), "run_wiki": lambda: (aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')"), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0])]))[-1], "accept": lambda: {True: None, False: aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(jid),))}[jid == None], "redo": lambda: {True: None, False: (aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(jid),)), subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(jid)]))}[jid == None], "list": lambda: list(map(pj, j[:20]))}.get(c, lambda: list(map(pj, j[:20])))()

services/processes.py:
#!/usr/bin/env python3
import sys, subprocess, json
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from pathlib import Path
c, n = (sys.argv + ["json"])[1], (sys.argv + ["", None])[2]
[aios_db.write(k, v) for k, v in [("schedule", {}), ("aios_pids", {})]]
gap = lambda: (lambda s: {"scheduled": sorted([{"path": cmd, "type": "daily", "time": time, "status": "scheduled"} for time, cmd in s.get("daily", {}).items()] + [{"path": cmd, "type": "hourly", "time": f":{int(m):02d}", "status": "scheduled"} for m, cmd in s.get("hourly", {}).items()], key=lambda x: x["time"]), "ongoing": [{"path": f"{k}_pid_{v}", "type": "running", "status": "active"} for k, v in aios_db.read("aios_pids").items()], "core": [{"path": str(f.relative_to(Path('/home/seanpatten/projects/AIOS'))), "type": "file", "status": "available"} for f in list(Path('/home/seanpatten/projects/AIOS').rglob('*.py')) if ('archive' not in f.parts) * ('__pycache__' not in f.parts)]})(aios_db.read("schedule"))
pp = lambda p: print(f"{p['path']}: {p['status']}")
{"json": lambda: print(json.dumps(gap())), "list": lambda: (lambda ap: (list(map(pp, ap.get("scheduled", []))), list(map(pp, ap.get("ongoing", []))), list(map(pp, ap.get("core", []))))[-1])(gap()), "start": lambda: {True: None, False: subprocess.Popen(['python3', n])}[n == None], "stop": lambda: {True: None, False: subprocess.run(['pkill', '-f', n], timeout=5)}[n == None]}.get(c, lambda: print(json.dumps(gap())))()

services/feed.py:
#!/usr/bin/env python3
import sys
[sys.path.append(p) for p in ["/home/seanpatten/projects/AIOS/core", "/home/seanpatten/projects/AIOS"]]
import aios_db
from datetime import datetime
c = (sys.argv + ["list"])[1]
pm = lambda r: print({True: f"{r[2].split('T')[1][:5]} {r[1]}", False: f"{r[2].split('T')[0]} {r[2].split('T')[1][:5]} {r[1]}"}[datetime.fromisoformat(r[2]).date() == datetime.now().date()])
pv = lambda r, f: print({True: f"{datetime.fromisoformat(r[2]).strftime(f)} {r[1]}", False: f"{r[2].split('T')[0]} {datetime.fromisoformat(r[2]).strftime(f)} {r[1]}"}[datetime.fromisoformat(r[2]).date() == datetime.now().date()])
{"add": lambda: aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (" ".join(sys.argv[2:]), datetime.now().isoformat(), "manual")), "list": lambda: list(map(pm, aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50"))), "view": lambda: (aios_db.write('settings', {}), list(map(lambda r: pv(r, {True: '%I:%M %p', False: '%H:%M'}[aios_db.read('settings').get('time_format', '12h') == '12h']), aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")))), "clear": lambda: aios_db.execute("feed", "DELETE FROM messages WHERE timestamp < datetime('now', '-7 days')")}.get(c, lambda: list(map(pm, aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50"))))()

programs/job_status.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import subprocess

command = sys.argv[1] if len(sys.argv) > 1 else "summary"
job_id = sys.argv[2] if len(sys.argv) > 2 else None

jobs = aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")

if command == "summary":
    running = [j for j in jobs if j[2] == "running"]
    review = [j for j in jobs if j[2] == "review"]
    done = [j for j in jobs if j[2] == "done"][:5]

    summary = []
    summary.extend([f"RUN {j[1]}" for j in running[:2]])
    summary.extend([f"? {j[1]}" for j in review[:1]])
    summary.extend([f"DONE {j[1]}" for j in done[:1]])

    for line in summary[:4]:
        print(line)

elif command == "running":
    running = [j for j in jobs if j[2] == "running"]
    for j in running[:10]:
        print(f'<div class="job-item">{j[1]} <span class="status running">Running...</span></div>')

elif command == "review":
    review = [j for j in jobs if j[2] == "review"]
    for j in review[:10]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span>')
        print(f'<form action="/job/accept" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Accept</button></form>')
        print(f'<form action="/job/redo" method="POST" style="display:inline"><input type="hidden" name="id" value="{j[0]}"><button class="action-btn">Redo</button></form></div>')

elif command == "done":
    done = [j for j in jobs if j[2] == "done"]
    for j in done[:50]:
        output = (j[3] or "")[:50] + "..." if j[3] else ""
        print(f'<div class="job-item">{j[1]} <span class="output">{output}</span></div>')

elif command == "run_wiki":
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES ('wiki', 'running')")
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

elif command == "accept" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", (int(job_id),))

elif command == "redo" and job_id:
    aios_db.execute("jobs", "UPDATE jobs SET status='running' WHERE id=?", (int(job_id),))
    subprocess.Popen(["python3", "programs/wiki_fetcher/wiki_fetcher.py", str(job_id)])

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("ideas", [])
ideas, command = aios_db.read("ideas"), (sys.argv + ["list"])[1]
score = lambda i: len(i.get('description', '')) * i.get('impact', 1) / max(i.get('effort', 1), 1)
commands = {
    "add": lambda: aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}]),
    "rank": lambda: list(map(lambda x: print(f"{x[0]+1}. [{score(x[1]):.1f}] {x[1]['description']}"), enumerate(sorted(ideas, key=score, reverse=True)))),
    "list": lambda: list(map(lambda x: print(f"{x[0]+1}. {x[1]['description']}"), enumerate(ideas))),
    "pick": lambda: print(f"Best: {sorted(ideas, key=lambda x: score(x)/x.get('effort', 5), reverse=True)[0]['description']}") if ideas else None
}
commands.get(command, commands["list"])()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys, subprocess, concurrent.futures
from pathlib import Path
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
components, build_dir = sys.argv[1:] or [], Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)
build_component = lambda n: ((build_dir / f"{n}.build").write_text(f"Built at {datetime.now()}"), {"name": n, "status": {0: "success"}.get(subprocess.run(['echo', f'Building {n}'], capture_output=True, timeout=10).returncode, "failed"), "time": datetime.now().isoformat()})[1]
results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components))
list(map(lambda r: print(f"{r['name']}: {r['status']}"), results))
aios_db.write("build_log", [])
aios_db.write("build_log", aios_db.read("build_log") + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys, subprocess, schedule as sched
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
schedules = aios_db.read("schedule")
run_cmd = lambda cmd: subprocess.run(cmd, shell=True, timeout=300)
list(map(lambda item: sched.every().day.at(item[0]).do(run_cmd, item[1]), schedules.get("daily", {}).items()))
list(map(lambda item: sched.every().hour.at(f":{int(item[0]):02d}").do(run_cmd, item[1]), schedules.get("hourly", {}).items()))
sched.run_pending()

programs/wiki_fetcher/wiki_fetcher.py:
#!/usr/bin/env python3
import sys, json, urllib.request
sys.path.append("/home/seanpatten/projects/AIOS/core")
import aios_db
data = json.loads(urllib.request.urlopen(urllib.request.Request("https://en.wikipedia.org/api/rest_v1/page/random/summary", headers={'User-Agent': 'Mozilla/5.0'})).read().decode())
output, job_id = f"{data.get('title', 'Unknown')}: {data.get('extract', 'No extract available')[:200]}...", (sys.argv + [None])[1]
(job_id and aios_db.execute("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?", (output, job_id))) or print(output)

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
aios_db.write("tasks", []) or aios_db.write("daily_plan", {})
tasks, today, plan = aios_db.read("tasks"), str(datetime.now().date()), aios_db.read("daily_plan")
pending = [t for t in tasks if not (t.startswith("[x]") or t.startswith("[!]"))][:10]
plan[today] = pending
aios_db.write("daily_plan", plan)
list(map(lambda t: print(f"- {t}"), pending))

programs/settings/settings.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
command, key, value, settings = (sys.argv + ["set"])[1], (sys.argv + ["set", "theme"])[2], (sys.argv + ["set", "theme", ""])[3], aios_db.read("settings") or {}
{"set": lambda: aios_db.write("settings", {**settings, key: value}), "get": lambda: print(settings.get(key, ""))}[command]()


programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = (sys.argv + ["list"])[1]
question = ' '.join(sys.argv[2:])

client = anthropic.Anthropic(api_key=(aios_db.read("api_keys") or {}).get("anthropic", ""))

def ask():
    response = client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text
    cache[question] = {"response": response, "time": datetime.now().isoformat()}
    aios_db.write("llm_cache", cache)
    print(response)
    return cache

def print_item(item):
    q, a = item
    print(f"Q: {q[:50]}... A: {a['response'][:50]}...")

def list_cache():
    list(map(print_item, cache.items()))
    return cache

def clear():
    return aios_db.write("llm_cache", {})

def stats():
    print(f"Cached queries: {len(cache)}")
    return len(cache)

actions = {"ask": ask, "list": list_cache, "clear": clear, "stats": stats}
actions.get(command, list_cache)()

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
from datetime import datetime
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
command, get_tasks = (sys.argv + ["list"])[1], lambda: aios_db.read("tasks")
tasks = get_tasks()
commands = {
    "add": lambda: (aios_db.write("tasks", get_tasks() + [f"[ ] {datetime.now():%Y-%m-%d %H:%M} {' '.join(sys.argv[2:]).split('@')[0].strip()}"]),
                   aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Task: {' '.join(sys.argv[2:]).split('@')[0].strip()}", datetime.now().isoformat(), "todo"))),
    "done": lambda: (lambda ts, tid, t: (aios_db.write("tasks", ts[:tid] + [t.replace("[ ]", "[x]")] + ts[tid+1:]),
                                          aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)", (f"Completed: {' '.join(t.split()[3:])}", datetime.now().isoformat(), "todo"))))(get_tasks(), int(sys.argv[2])-1, get_tasks()[int(sys.argv[2])-1]),
    "list": lambda: list(map(lambda x: print(f"{x[0]+1}. {x[1]}"), enumerate(tasks))),
    "clear": lambda: aios_db.write("tasks", [t for t in tasks if not t.startswith("[x]")])
}
commands.get(command, commands["list"])()

programs/autollm/view_output.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file, db_output = (sys.argv + [""])[1], Path.home() / ".aios" / f"autollm_output_{(sys.argv + [''])[1]}.txt", aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", ((sys.argv + [""])[1],))
print(output_file.read_text() if output_file.exists() else (db_output[0][0] or "No output yet") if db_output else "No output yet")

programs/autollm/capture_output.py:
#!/usr/bin/env python3
import subprocess, sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file, cmd_type, model, task = sys.argv[1], Path.home() / ".aios" / f"autollm_output_{sys.argv[1]}.txt", sys.argv[2], sys.argv[3], " ".join(sys.argv[4:])
result = subprocess.run({"claude": ["claude", task], "claude-dangerous": ["claude", "--dangerously-skip-permissions", task], "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]}.get(cmd_type, ["echo", "Invalid command"]), capture_output=True, text=True, timeout=999999)
output = result.stdout + result.stderr
output_file.write_text(output)
list(map(lambda q: aios_db.execute(q[0], q[1], (output, job_id)), [("autollm", "UPDATE worktrees SET output=?, status='review' WHERE job_id=?"), ("jobs", "UPDATE jobs SET output=?, status='review' WHERE id=?")]))

programs/autollm/output_page.py:
#!/usr/bin/env python3
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
job_id, output_file = (sys.argv + [""])[1], Path.home() / ".aios" / f"autollm_output_{(sys.argv + [''])[1]}.txt"
worktree = aios_db.query("autollm", "SELECT branch, task, model, status, output FROM worktrees WHERE job_id=?", (job_id,))
info = worktree[0] if worktree else ["unknown", "unknown", "unknown", "unknown", ""]
file_output = output_file.read_text() if output_file.exists() else (info[4] or "No output yet") if worktree else "No output yet"
list(map(print, [f"Branch: {info[0]}", f"Task: {info[1]}", f"Model: {info[2]}", f"Status: {info[3]}", f"Output:\n{file_output}"]))

programs/autollm/llm.py:
#!/usr/bin/env python3
import subprocess, sys
command, model, task = (sys.argv + ["claude"])[1], (sys.argv + ["", "claude-3-5-sonnet-20241022"])[2], " ".join(sys.argv[3:]) or "Improve this code"
subprocess.run({"claude": ["claude", "--dangerously-skip-permissions", task], "codex": ["codex", "-c", "model_reasoning_effort=high", "--model", model, "--dangerously-bypass-approvals-and-sandbox", task]}.get(command, ["claude", "--dangerously-skip-permissions", task]), timeout=999999)

programs/autollm/llm_test.py:
#!/usr/bin/env python3
import sys
print(f"LLM called with: command={sys.argv[1]}, model={sys.argv[2]}, task={' '.join(sys.argv[3:])}")

programs/autollm/autollm.py:
#!/usr/bin/env python3
import subprocess, sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
command = (sys.argv + ["run"])[1]
create_and_launch = lambda repo, branch, model, task: (
    subprocess.run(["git", "worktree", "add", "-b", branch, str(Path(repo).parent / f"{Path(repo).name}-{branch}")], cwd=repo, capture_output=True, timeout=5),
    aios_db.execute("jobs", "INSERT INTO jobs(name, status) VALUES (?, 'running')", (branch,)),
    aios_db.execute("autollm", "INSERT INTO worktrees(repo, branch, path, job_id, model, task, status) VALUES (?, ?, ?, ?, ?, ?, 'running')",
                    (repo, branch, str(Path(repo).parent / f"{Path(repo).name}-{branch}"), aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0], model, task)),
    subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_runner.py", "python3", "/home/seanpatten/projects/AIOS/programs/autollm/capture_output.py",
                     str(aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]),
                     "claude-dangerous" if model == "claude-dangerous" else "claude" if model.startswith("claude") else "codex", model, task],
                    cwd=str(Path(repo).parent / f"{Path(repo).name}-{branch}"), env={**subprocess.os.environ, "AIOS_TIMEOUT": "999999"})
)
commands = {
    "run": lambda: list(map(lambda i: create_and_launch((sys.argv + ["", "/home/seanpatten/projects/testRepoPrivate"])[2], f"autollm-{Path((sys.argv + ['', '/home/seanpatten/projects/testRepoPrivate'])[2]).name}-{i}", (sys.argv + ["", "", "", "claude-3-5-sonnet-20241022"])[4], " ".join(sys.argv[5:]) or "Improve code"), range(int((sys.argv + ["", "", "1"])[3])))),
    "status": lambda: list(map(lambda w: print(f"{w[0]}: {w[1]}"), aios_db.query("autollm", "SELECT branch, status FROM worktrees"))),
    "clean": lambda: (list(map(lambda w: subprocess.run(["git", "worktree", "remove", w[2]], cwd=w[0], capture_output=True, timeout=5), aios_db.query("autollm", "SELECT repo, branch, path FROM worktrees WHERE status='done'"))), aios_db.execute("autollm", "DELETE FROM worktrees WHERE status='done'")),
    "output": lambda: print((lambda r: (r[0][0] or "") if r else "")(aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", ((sys.argv + ["", ""])[2],)))),
    "accept": lambda: (aios_db.execute("autollm", "UPDATE worktrees SET status='done' WHERE job_id=?", ((sys.argv + ["", ""])[2],)), aios_db.execute("jobs", "UPDATE jobs SET status='done' WHERE id=?", ((sys.argv + ["", ""])[2],)))
}
commands.get(command, commands["run"])()

programs/autollm/reset.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

aios_db.execute("autollm", "DROP TABLE IF EXISTS worktrees")
aios_db.execute("autollm", "CREATE TABLE IF NOT EXISTS worktrees(id INTEGER PRIMARY KEY, repo TEXT, branch TEXT, path TEXT, job_id INTEGER, model TEXT, task TEXT, status TEXT, output TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
print("Reset autollm database")

programs/autollm/terminal.py:
#!/usr/bin/env python3
import subprocess
import sys
from pathlib import Path
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

job_id = (sys.argv + [""])[1]
worktree = aios_db.query("autollm", "SELECT path, output FROM worktrees WHERE job_id=?", (job_id,))
path = worktree[0][0]

output_file = Path(path) / ".autollm_output"
subprocess.run(["tail", "-f", str(output_file)], timeout=999999)

programs/autollm/monitor.py:
#!/usr/bin/env python3
import sys
import subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

worktrees = aios_db.query("autollm", "SELECT branch, path, job_id, status, model, task FROM worktrees")
list(map(lambda w: print(f"{w[0]}: {w[3]} | {w[4]} | {w[5][:30]}"), worktrees))

programs/workflow/workflow.py:
#!/usr/bin/env python3
import sys, json, subprocess
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
from pathlib import Path
from datetime import datetime

cmd = (sys.argv + ["list"])[1]

def get_workflows():
    try:
        return aios_db.read("workflows")
    except:
        aios_db.write("workflows", {})
        return {}

def get_nodes():
    try:
        return aios_db.read("workflow_nodes")
    except:
        aios_db.write("workflow_nodes", [])
        return []

def add_node():
    nodes = get_nodes()
    col = int((sys.argv + ["", "0"])[2])
    args = sys.argv[3:]
    folder = str(Path.cwd())
    text = " ".join(args)
    for i, arg in enumerate(args):
        if arg.startswith("/") and Path(arg).exists():
            folder = arg
            text = " ".join(args[:i] + args[i+1:])
            break
    node = {"id": len(nodes), "col": col, "text": text, "folder": folder, "parent": None, "children": [], "branch": None, "created": datetime.now().isoformat()}
    aios_db.write("workflow_nodes", nodes + [node])
    print(f"{node['id']}")

def list_nodes():
    cols = {}
    for n in get_nodes():
        cols.setdefault(n["col"], []).append(n)
    for c in sorted(cols.keys()):
        print(f"Column {c}:")
        list(map(lambda n: print(f"  {n['id']}: {n['text'][:50]}"), cols[c]))

def expand():
    nid = int((sys.argv + ["", "0"])[2])
    instruction = " ".join(sys.argv[3:])
    nodes = get_nodes()
    parent = nodes[nid]
    new_text = f"{parent['text']}\n{instruction}" if instruction else parent['text']
    child = {"id": len(nodes), "col": parent["col"] + 1, "text": new_text, "folder": parent["folder"], "parent": nid, "children": [], "branch": None, "created": datetime.now().isoformat()}
    nodes[nid]["children"].append(child["id"])
    aios_db.write("workflow_nodes", nodes + [child])
    print(f"{child['id']}")

def branch():
    nid = int((sys.argv + ["", "0"])[2])
    btype = (sys.argv + ["", "", "folder"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    folder = node["folder"]
    if btype == "worktree":
        branch_name = f"workflow-{nid}-{datetime.now():%Y%m%d%H%M%S}"
        path = f"{folder}-{branch_name}"
        subprocess.run(["git", "worktree", "add", "-b", branch_name, path], cwd=folder, capture_output=True, timeout=5)
        nodes[nid]["branch"] = {"type": "worktree", "path": path, "branch": branch_name}
    elif btype == "subfolder":
        path = f"{folder}/workflow-{nid}"
        Path(path).mkdir(parents=True, exist_ok=True)
        nodes[nid]["branch"] = {"type": "subfolder", "path": path}
    else:
        nodes[nid]["branch"] = {"type": "main", "path": folder}
    aios_db.write("workflow_nodes", nodes)
    print(nodes[nid]["branch"]["path"])

def worktree_with_terminal():
    """Create a worktree and return terminal session info for PTY"""
    repo = (sys.argv + ["", "/home/seanpatten/projects/AIOS"])[2]
    branch_name = (sys.argv + ["", ""])[3]

    # Generate branch name if empty or not provided
    if not branch_name or branch_name.strip() == "":
        branch_name = f"worktree_{datetime.now():%Y%m%d_%H%M%S}"

    # Create worktree path
    parent = Path(repo).parent
    worktree_path = parent / f"{Path(repo).name}_{branch_name}"

    # Create the worktree
    result = subprocess.run(
        ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
        cwd=repo,
        capture_output=True,
        text=True,
        timeout=10
    )

    if result.returncode != 0:
        print(json.dumps({"error": f"Failed to create worktree: {result.stderr}"}))
        return

    # Store worktree info
    try:
        worktrees = aios_db.read("worktrees_list")
    except:
        worktrees = []

    worktree_info = {
        "repo": str(repo),
        "branch": branch_name,
        "path": str(worktree_path),
        "created": datetime.now().isoformat()
    }
    worktrees.append(worktree_info)
    aios_db.write("worktrees_list", worktrees)

    # Return info for terminal creation
    print(json.dumps({
        "success": True,
        "branch": branch_name,
        "path": str(worktree_path),
        "message": f"Worktree created at {worktree_path}"
    }))

def execute():
    nid = int((sys.argv + ["", "0"])[2])
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    full_prompt = node["text"]
    parent_id = node.get("parent")
    while parent_id is not None:
        parent = nodes[parent_id]
        full_prompt = f"{parent['text']}\n{full_prompt}"
        parent_id = parent.get("parent")
    aios_db.execute("jobs", "INSERT INTO jobs(name, status, output) VALUES (?, 'running', ?)", (f"workflow-{nid}", node["text"]))
    job_id = aios_db.query("jobs", "SELECT MAX(id) FROM jobs")[0][0]
    subprocess.Popen(["claude", "--dangerously-skip-permissions", full_prompt], cwd=path, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print(f"{job_id}")

def save_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    workflows[name] = {"nodes": get_nodes(), "saved": datetime.now().isoformat()}
    aios_db.write("workflows", workflows)
    print(f"Saved: {name}")

def load_workflow():
    name = (sys.argv + ["", "default"])[2]
    workflows = get_workflows()
    aios_db.write("workflow_nodes", workflows.get(name, {}).get("nodes", []))
    print(f"Loaded: {name}")

def git_push():
    nid = int((sys.argv + ["", "0"])[2])
    msg = " ".join(sys.argv[3:]) or "workflow update"
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.run(["git", "add", "."], cwd=path, timeout=5)
    subprocess.run(["git", "commit", "-m", msg], cwd=path, timeout=5, capture_output=True)
    result = subprocess.run(["git", "push"], cwd=path, timeout=5, capture_output=True, text=True)
    if "no upstream branch" in result.stderr:
        branch_name = subprocess.run(["git", "branch", "--show-current"], cwd=path, capture_output=True, text=True, timeout=5).stdout.strip()
        subprocess.run(["git", "push", "--set-upstream", "origin", branch_name], cwd=path, timeout=5)
    print(f"Pushed: {path}")

def terminal():
    nid = int((sys.argv + ["", "0"])[2])
    term = (sys.argv + ["", "", "gnome-terminal"])[3]
    nodes = get_nodes()
    node = nodes[nid]
    branch = node.get("branch") or {}
    path = branch.get("path") if branch else node["folder"]
    subprocess.Popen([term, "--working-directory", path])
    print(f"Terminal: {path}")

def comment():
    nid = int((sys.argv + ["", "0"])[2])
    text = " ".join(sys.argv[3:])
    nodes = get_nodes()
    nodes[nid].setdefault("comments", []).append({"text": text, "time": datetime.now().isoformat(), "author": "human"})
    aios_db.write("workflow_nodes", nodes)
    print(f"Comment added to {nid}")

{"add": add_node, "list": list_nodes, "expand": expand, "branch": branch, "exec": execute, "save": save_workflow, "load": load_workflow, "push": git_push, "term": terminal, "comment": comment, "worktree_terminal": worktree_with_terminal}.get(cmd, list_nodes)()


programs/worktree/worktree_manager.py:
#!/usr/bin/env python3
import sys
import subprocess
import os
from pathlib import Path
from datetime import datetime
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db

def create_worktree_with_terminal(repo_path=None, branch_name=None):
    """Create a new git worktree and open a terminal in it"""

    # Default to AIOS project if no repo specified
    if not repo_path or repo_path == '':
        repo_path = '/home/seanpatten/projects/AIOS'

    # Check if it's a git repository
    try:
        subprocess.run(["git", "status"], cwd=repo_path, capture_output=True, check=True)
    except:
        return {"error": "Not a git repository", "path": repo_path}

    # Generate branch name if not provided
    if not branch_name:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        branch_name = f"worktree_{timestamp}"

    # Create worktree path
    parent = Path(repo_path).parent
    worktree_path = parent / f"{Path(repo_path).name}_{branch_name}"

    # Create the worktree
    try:
        result = subprocess.run(
            ["git", "worktree", "add", "-b", branch_name, str(worktree_path)],
            cwd=repo_path,
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode != 0:
            return {"error": f"Failed to create worktree: {result.stderr}", "branch": branch_name}

        # Store worktree info in database
        try:
            worktrees = aios_db.read("worktrees_list")
        except:
            worktrees = []
        worktrees.append({
            "repo": str(repo_path),
            "branch": branch_name,
            "path": str(worktree_path),
            "created": datetime.now().isoformat()
        })
        aios_db.write("worktrees_list", worktrees)

        # Try to open terminal (different commands for different environments)
        terminal_opened = False
        terminal_commands = [
            ["gnome-terminal", "--working-directory", str(worktree_path)],
            ["xterm", "-e", f"cd {worktree_path} && bash"],
            ["konsole", "--workdir", str(worktree_path)],
            ["xfce4-terminal", "--working-directory", str(worktree_path)]
        ]

        for cmd in terminal_commands:
            try:
                subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                terminal_opened = True
                break
            except:
                continue

        return {
            "success": True,
            "branch": branch_name,
            "path": str(worktree_path),
            "terminal": terminal_opened
        }

    except Exception as e:
        return {"error": str(e)}

def list_worktrees():
    """List all worktrees"""
    try:
        result = subprocess.run(
            ["git", "worktree", "list"],
            capture_output=True,
            text=True
        )
        return result.stdout
    except:
        return "Not a git repository"

def remove_worktree(path):
    """Remove a worktree"""
    try:
        subprocess.run(["git", "worktree", "remove", path], check=True)
        return f"Removed worktree: {path}"
    except Exception as e:
        return f"Error removing worktree: {e}"

if __name__ == "__main__":
    command = sys.argv[1] if len(sys.argv) > 1 else "create"

    if command == "create":
        repo = sys.argv[2] if len(sys.argv) > 2 else None
        branch = sys.argv[3] if len(sys.argv) > 3 else None
        result = create_worktree_with_terminal(repo, branch)
        if "success" in result and result["success"]:
            print(f"Created worktree: {result['path']}")
            print(f"Branch: {result['branch']}")
            if result["terminal"]:
                print("Terminal opened in worktree")
        else:
            print(f"Error: {result.get('error', 'Unknown error')}")

    elif command == "list":
        print(list_worktrees())

    elif command == "remove":
        path = sys.argv[2] if len(sys.argv) > 2 else None
        if path:
            print(remove_worktree(path))
        else:
            print("Please specify path to remove")

services/web/web.py:
#!/usr/bin/env python3
import sys; sys.path.extend(['/home/seanpatten/projects/AIOS', '/home/seanpatten/projects/AIOS/core'])
from http.server import HTTPServer, BaseHTTPRequestHandler
import json, aios_db, subprocess, os, asyncio, websockets, pty, struct, fcntl, termios, signal
from urllib.parse import parse_qs, urlparse
from datetime import datetime
from pathlib import Path
from threading import Thread

TEMPLATE_DIR, WEB_PORT = Path(__file__).parent / 'templates', int(sys.argv[2]) if len(sys.argv) > 2 else 8080
T = {k: (TEMPLATE_DIR / v).read_text() for k, v in {'index': 'index.html', 'todo': 'todo.html', 'jobs': 'jobs.html', 'feed': 'feed.html', 'autollm': 'autollm.html', 'autollm_output': 'autollm_output.html', 'terminal': 'terminal.html', 'terminal_emulator': 'terminal-emulator.html', 'terminal_xterm': 'terminal-xterm.html', 'settings': 'settings.html', 'workflow': 'workflow.html', 'workflow_manager': 'workflow_manager.html'}.items()}

class Handler(BaseHTTPRequestHandler):
    def _ctx(self): s, c = aios_db.read("settings") or {}, {}; c.update({'bg': {'light': '#fff'}.get(s.get('theme'), '#000'), 'fg': {'light': '#000'}.get(s.get('theme'), '#fff'), 'bg2': {'light': '#f0f0f0'}.get(s.get('theme'), '#1a1a1a')}); return s, c

    def do_GET(self):
        p, q, s, c = urlparse(self.path), parse_qs(urlparse(self.path).query), *self._ctx()
        H = {'/': lambda: (T['index'].format(**c), 'text/html'), '/api/jobs': lambda: (json.dumps([{"id": j[0], "name": j[1], "status": j[2], "output": j[3]} for j in aios_db.query("jobs", "SELECT id, name, status, output FROM jobs ORDER BY created DESC")]), 'application/json'), '/todo': lambda: (T['todo'].format(**c, tasks="".join([f'<div class="task {"done" * ("[x]" in t)}">{t} <form style="display:inline" action="/todo/done" method="POST"><input type="hidden" name="id" value="{t.split(".")[0] or str(i+1)}"><button>Done</button></form></div>' for i, t in enumerate(subprocess.run(["python3", "core/aios_runner.py", "python3", "programs/todo/todo.py", "list"], capture_output=True, text=True).stdout.strip().split('\n') or [])]) or '<div style="color:#888">No tasks yet</div>'), 'text/html'), '/feed': lambda: (T['feed'].format(**c, feed_content=(lambda m, d=[]: "".join([d.append(datetime.fromisoformat(x[1]).date()) or (f'<div style="color:#888;font-weight:bold;margin:15px 0 5px">{datetime.fromisoformat(x[1]).date()}</div>' if datetime.fromisoformat(x[1]).date() not in d else '') + f'<div style="padding:8px;margin:2px 0">{datetime.fromisoformat(x[1]).strftime({"12h": "%I:%M %p"}.get(s.get("time_format", "12h"), "%H:%M"))} - {x[0]}</div>' for x in m]) or "<div style='color:#888'>No messages yet</div>")(aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp DESC LIMIT 100"))), 'text/html'), '/settings': lambda: (T['settings'].format(**c, theme_dark_style={'dark': 'style="font-weight:bold"'}.get(s.get('theme', 'dark'), ''), theme_light_style={'light': 'style="font-weight:bold"'}.get(s.get('theme'), ''), time_12h_style={'12h': 'style="font-weight:bold"'}.get(s.get('time_format', '12h'), ''), time_24h_style={'24h': 'style="font-weight:bold"'}.get(s.get('time_format'), '')), 'text/html'), '/jobs': lambda: (T['jobs'].format(**c, **{k: subprocess.run(f"python3 services/jobs.py {v}", shell=True, capture_output=True, text=True, timeout=5).stdout.strip() or f'<div style="color:#888;padding:10px">No {v} jobs</div>' for k, v in {'running_jobs': 'running', 'review_jobs': 'review', 'done_jobs': 'done'}.items()}), 'text/html'), '/autollm': lambda: (T['autollm'].format(**c, **{f'{k}_worktrees': "".join([h(w) for w in g]) or f'<div style="color:#888">No {k} worktrees</div>' for k, g, h in [('running', [w for w in aios_db.query("autollm", "SELECT branch, path, job_id, status, task, model FROM worktrees") if w[3] == 'running'], lambda w: f'<div class="worktree"><span class="status running">{w[0]}</span><br>{w[5]}: {w[4][:30]}<br><pre style="background:#000;padding:5px;margin:5px 0;max-height:100px;overflow-y:auto;font-size:10px">{((Path.home() / ".aios" / f"autollm_output_{w[2]}.txt").read_text()[-200:] if (Path.home() / ".aios" / f"autollm_output_{w[2]}.txt").exists() else "Waiting for output...")}</pre><a href="/autollm/output?job_id={w[2]}" style="padding:5px 10px;background:{c["fg"]};color:{c["bg"]};text-decoration:none;border-radius:3px">Full Output</a><a href="/terminal?job_id={w[2]}" style="padding:5px 10px;background:{c["fg"]};color:{c["bg"]};text-decoration:none;border-radius:3px;margin-left:5px">Terminal</a></div>'), ('review', [w for w in aios_db.query("autollm", "SELECT branch, path, job_id, status, task, model, output FROM worktrees") if w[3] == 'review'], lambda w: f'<div class="worktree"><span class="status review">{w[0]}</span><br>{w[5]}: {w[4][:30]}<br>Output: {(w[6] or "")[:50]}<br><form action="/autollm/accept" method="POST" style="display:inline"><input type="hidden" name="job_id" value="{w[2]}"><button>Accept</button></form><form action="/autollm/vscode" method="POST" style="display:inline"><input type="hidden" name="path" value="{w[1]}"><button>VSCode</button></form></div>'), ('done', [w for w in aios_db.query("autollm", "SELECT branch, path FROM worktrees") if len(w) > 3 and w[3] == 'done'], lambda w: f'<div class="worktree"><span class="status done">{w[0]}</span></div>')]}), 'text/html'), '/autollm/output': lambda: (T['autollm_output'].format(**c, output_content=(lambda j, f: f.read_text() if f.exists() else ((lambda d: d[0][0] if d else "No output yet")(aios_db.query("autollm", "SELECT output FROM worktrees WHERE job_id=?", (j,)))))(q.get('job_id', [''])[0], Path.home() / ".aios" / f"autollm_output_{q.get('job_id', [''])[0]}.txt")), 'text/html'), '/terminal': lambda: (T['terminal'].format(**c, terminal_content=(lambda j, f: f.read_text() if f.exists() else "Waiting for output...")(q.get('job_id', [''])[0], Path.home() / ".aios" / f"autollm_output_{q.get('job_id', [''])[0]}.txt"), job_id=q.get('job_id', [''])[0]), 'text/html'), '/terminal-emulator': lambda: (T['terminal_emulator'].replace('ws://localhost:8766', f'ws://localhost:{WEB_PORT + 1000}'), 'text/html'), '/terminal-xterm': lambda: (T['terminal_xterm'].replace('ws://localhost:8766', f'ws://localhost:{WEB_PORT + 1000}'), 'text/html'), '/workflow': lambda: (T['workflow'].format(**c), 'text/html'), '/workflow-manager': lambda: (T['workflow_manager'].format(**c), 'text/html'), '/workflow/list_worktrees': lambda: (json.dumps([{"path": l.split()[0], "branch": l.split()[2].strip('[]')} for l in subprocess.run(["git", "worktree", "list"], capture_output=True, text=True, timeout=5).stdout.strip().split('\n') if l and len(l.split()) >= 3]), 'application/json'), '/api/workflow/nodes': lambda: (json.dumps(aios_db.read("workflow_nodes") or []), 'application/json')}
        ct, ty = H.get(p.path, lambda: (T['index'].format(**c), 'text/html'))(); self.send_response(200); self.send_header('Content-type', ty); self.end_headers(); self.wfile.write(ct.encode())

    def do_POST(self):
        p, b = urlparse(self.path).path, self.rfile.read(int(self.headers.get('Content-Length', 0))) or b''
        if p.startswith('/workflow/'): d = json.loads(b.decode() or '{}'); (p == '/workflow/worktree_terminal' and (lambda r: (self.send_response(200), self.send_header('Content-type', 'application/json'), self.end_headers(), self.wfile.write(json.dumps(json.loads(r.stdout) if r.stdout else {"error": "No output"}).encode())))(subprocess.run(["python3", "programs/workflow/workflow.py", "worktree_terminal", d.get('repo', '/home/seanpatten/projects/AIOS'), d.get('branch', '')], capture_output=True, text=True, timeout=10)) or p == '/workflow/remove_worktree' and (subprocess.run(["git", "worktree", "remove", d.get('path', '')], check=True, timeout=5), self.send_response(200), self.send_header('Content-type', 'application/json'), self.end_headers(), self.wfile.write(b'{"success":true}')) or (subprocess.run({'/workflow/add': f"python3 programs/workflow/workflow.py add {d.get('col', 0)} {d.get('text', '')}", '/workflow/expand': f"python3 programs/workflow/workflow.py expand {d.get('id', 0)} {d.get('text', '')}", '/workflow/branch': f"python3 programs/workflow/workflow.py branch {d.get('id', 0)}", '/workflow/exec': f"python3 programs/workflow/workflow.py exec {d.get('id', 0)}", '/workflow/push': f"python3 programs/workflow/workflow.py push {d.get('id', 0)}", '/workflow/term': f"python3 programs/workflow/workflow.py term {d.get('id', 0)}", '/workflow/comment': f"python3 programs/workflow/workflow.py comment {d.get('id', 0)} {d.get('text', '')}", '/workflow/save': f"python3 programs/workflow/workflow.py save {d.get('name', 'default')}", '/workflow/load': f"python3 programs/workflow/workflow.py load {d.get('name', 'default')}"}.get(p, ""), shell=True, timeout=5, capture_output=True), self.send_response(200), self.send_header('Content-type', 'application/json'), self.end_headers(), self.wfile.write(b'{"status":"ok"}'))); return
        if p == '/shutdown': self.send_response(200); self.send_header('Content-type', 'text/html'); self.end_headers(); self.wfile.write(b'<html><body><h1>Shutting down AIOS...</h1><script>setTimeout(function(){window.close();}, 2000);</script></body></html>'); [os.kill(pid, signal.SIGTERM) for pid in (aios_db.read("aios_pids") or {}).values() if True]; os._exit(0)
        if p == '/restart': self.send_response(200); self.send_header('Content-type', 'text/html'); self.end_headers(); self.wfile.write(b'<html><body><h1>Restarting AIOS...</h1><script>setTimeout(function(){location.href="/";}, 3000);</script></body></html>'); Thread(target=lambda: (__import__('time').sleep(0.5), subprocess.Popen(["python3", "/home/seanpatten/projects/AIOS/core/aios_start.py"]), __import__('time').sleep(1), os._exit(0))[-1], daemon=True).start(); return
        if p == '/worktree/create': d, r = parse_qs(b.decode()) or {}, subprocess.run(["python3", "/home/seanpatten/projects/AIOS/programs/worktree/worktree_manager.py", "create", d.get('repo', [''])[0], d.get('branch', [''])[0]], capture_output=True, text=True, timeout=10); self.send_response(200); self.send_header('Content-type', 'text/html'); self.end_headers(); self.wfile.write(f'<html><body><h2>Worktree Created</h2><pre>{r.stdout if r.returncode == 0 else f"Error: {r.stderr}"}</pre><br><a href="/">Back to Control Center</a></body></html>'.encode()); return
        d = parse_qs(b.decode()) or {}; subprocess.run({'/job/run': "python3 services/jobs.py run_wiki", '/job/accept': f"python3 services/jobs.py accept {d.get('id', [''])[0]}", '/job/redo': f"python3 services/jobs.py redo {d.get('id', [''])[0]}", '/run': d.get('cmd', [''])[0], '/todo/add': f"python3 programs/todo/todo.py add {d.get('task', [''])[0]}", '/todo/done': f"python3 programs/todo/todo.py done {d.get('id', [''])[0]}", '/todo/clear': "python3 programs/todo/todo.py clear", '/settings/theme': f"python3 programs/settings/settings.py set theme {d.get('theme', ['dark'])[0]}", '/settings/time': f"python3 programs/settings/settings.py set time_format {d.get('format', ['12h'])[0]}", '/autollm/run': f"python3 programs/autollm/autollm.py run {d.get('repo', [''])[0]} {d.get('branches', ['1'])[0]} {d.get('model', ['claude-3-5-sonnet-20241022'])[0]} {d.get('task', [''])[0]}", '/autollm/accept': f"python3 programs/autollm/autollm.py accept {d.get('job_id', [''])[0]}", '/autollm/vscode': f"code {d.get('path', [''])[0]}", '/autollm/clean': "python3 programs/autollm/autollm.py clean"}.get(p, ""), shell=True, timeout=5, capture_output=True); self.send_response(303); self.send_header('Location', '/autollm' if 'autollm' in p else '/settings' if 'settings' in p else p.replace('/add', '').replace('/done', '').replace('/clear', '')); self.end_headers()

    def log_message(self, *args): pass

async def client_handler(ws):
    m, s = pty.openpty(); fcntl.ioctl(s, termios.TIOCSWINSZ, struct.pack('HHHH', 24, 80, 0, 0)); proc = await asyncio.create_subprocess_exec('bash', stdin=s, stdout=s, stderr=s, preexec_fn=os.setsid); os.close(s); os.set_blocking(m, False); loop = asyncio.get_event_loop(); loop.add_reader(m, lambda: (lambda d: d and asyncio.create_task(ws.send(d)))(os.read(m, 65536) if True else None))
    try:
        async for msg in ws:
            isinstance(msg, bytes) and (msg[0:1] == b'{' and (lambda d: 'resize' in d and fcntl.ioctl(m, termios.TIOCSWINSZ, struct.pack('HHHH', d['resize']['rows'], d['resize']['cols'], 0, 0)))(json.loads(msg.decode())) or os.write(m, msg))
    finally: loop.remove_reader(m); proc.terminate(); await proc.wait(); os.close(m)

def serve_http(sock=None): s = HTTPServer(('', WEB_PORT), Handler, bind_and_activate=(sock is None)); s.socket = sock if sock else s.socket; s.serve_forever()

async def main():
    import socket; sock = socket.fromfd(int(sys.argv[1]), socket.AF_INET, socket.SOCK_STREAM) if len(sys.argv) > 1 else None; Thread(target=serve_http, args=(sock,), daemon=True).start(); ws_port = WEB_PORT + 1000
    try:
        async with websockets.serve(client_handler, 'localhost', ws_port): await asyncio.Future()
    except OSError:
        async with websockets.serve(client_handler, 'localhost', WEB_PORT + 2000): await asyncio.Future()

asyncio.run(main())

