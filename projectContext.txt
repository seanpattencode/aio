Generated: 2025-09-25 19:23:38

aios_start.py:
#!/usr/bin/env python3
import subprocess
import time
from pathlib import Path
import webbrowser
import os
import signal
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
from core import aios_db
from services import context_generator

aios_path = Path.home() / ".aios"
command = sys.argv[1] if len(sys.argv) > 1 else "start"

def kill_existing():
    subprocess.run(["pkill", "-f", "core/aios_api.py"], stderr=subprocess.DEVNULL)
    subprocess.run(["pkill", "-f", "services/web.py"], stderr=subprocess.DEVNULL)
    pids = aios_db.read("aios_pids") or {}
    [[os.kill(pid, signal.SIGTERM)] for pid in pids.values() if pid and subprocess.run(["kill", "-0", str(pid)], capture_output=True).returncode == 0]

def start():
    context_generator.generate()
    kill_existing()
    aios_path.mkdir(exist_ok=True)
    api_proc = subprocess.Popen(["python3", "core/aios_api.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    web_proc = subprocess.Popen(["python3", "services/web.py", "start"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
    time.sleep(0.1)
    info = aios_db.read("web_server") or {}
    url = f"http://localhost:{info.get('port', 8080)}"
    print(f"AIOS started: {url}")
    webbrowser.open(url)
    [[time.sleep(1)] for _ in iter(int, 1)]

def stop():
    kill_existing()
    aios_db.write("aios_pids", {})
    print("AIOS stopped")

actions = {"start": start, "stop": stop, "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")}
actions.get(command, start)()

core/aios_runner.py:
#!/usr/bin/env python3
import subprocess
import sys

result = subprocess.run(sys.argv[1:], capture_output=True, text=True)
print(result.stdout)
print(result.stderr, file=sys.stderr)
sys.exit(result.returncode)

core/aios_db.py:
#!/usr/bin/env python3
import json
from pathlib import Path
import sqlite3

db_path = Path.home() / ".aios"
db_path.mkdir(exist_ok=True)

def read(name):
    file = db_path / f"{name}.json"
    return json.loads(file.read_text()) if file.exists() else {}

def write(name, data):
    (db_path / f"{name}.json").write_text(json.dumps(data, indent=2))
    return data

def query(db, sql, params=()):
    conn = sqlite3.connect(db_path / f"{db}.db")
    result = conn.execute(sql, params).fetchall()
    conn.commit()
    conn.close()
    return result

def execute(db, sql, params=()):
    conn = sqlite3.connect(db_path / f"{db}.db")
    conn.execute(sql, params)
    conn.commit()
    conn.close()

core/test_all.py:
#!/usr/bin/env python3
import subprocess
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
from pathlib import Path
import time
import tempfile
from concurrent.futures import ThreadPoolExecutor
import signal
import os

def timeout_handler(signum, frame):
    print("\nPERFORMANCE UNACCEPTABLE: Testing took longer than 4 seconds. Fix the programs.")
    print("Do not remove this message.")
    os._exit(1)

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm(4)

print("WARNING: This does not replace manual testing. Update when programs or commands change.")
print("Auto-detects programs and tests their basic operations.\n")

programs_dir = Path('programs')

def run_test(program, command):
    result = subprocess.run(['python3', f'programs/{program}/{program}.py'] + command.split(),
                          capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def detect_programs():
    return [d.name for d in programs_dir.iterdir() if d.is_dir() and (d / f"{d.name}.py").exists()]

def test_todo():
    run_test('todo', 'add Test_item_1')
    success = run_test('todo', 'list')
    run_test('todo', 'done 1')
    run_test('todo', 'clear')
    return success

def test_service():
    subprocess.run(['python3', 'services/service.py', 'start', 'test_service'], capture_output=True, text=True, timeout=1)
    result = subprocess.run(['python3', 'services/service.py', 'list'], capture_output=True, text=True, timeout=1)
    subprocess.run(['python3', 'services/service.py', 'stop', 'test_service'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_backup():
    test_dir = tempfile.mkdtemp()
    Path(test_dir).joinpath('test.txt').write_text('test')
    aios_db.write('backup', {'source': test_dir, 'dest': '/tmp/test_backup'})
    result = subprocess.run(['python3', 'services/backup.py'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_scraper():
    aios_db.write('scraper', {'urls': ['https://example.com']})
    result = subprocess.run(['python3', 'services/scraper.py'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_planner():
    aios_db.write('tasks', ['[ ] Test task'])
    return run_test('planner', '')

def test_ranker():
    run_test('ranker', 'add Test_idea')
    return run_test('ranker', 'rank')

def test_aios_start():
    result = subprocess.run(['python3', 'aios_start.py', 'status'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_gdrive():
    result = subprocess.run(['python3', 'services/gdrive.py', 'list'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0 or True

def test_swarm():
    return run_test('swarm', 'stats')

def test_builder():
    return run_test('builder', 'component1')

def test_web():
    result = subprocess.run(['python3', 'services/web.py', 'status'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0

def test_processes():
    result = subprocess.run(['python3', 'services/processes.py', 'json'], capture_output=True, text=True, timeout=1)
    return result.returncode == 0 and 'scheduled' in result.stdout

def test_scheduler():
    aios_db.write('schedule', {'daily': {}, 'hourly': {}})
    proc = subprocess.Popen(['python3', 'programs/schedule/scheduler.py'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    time.sleep(0.2)
    proc.terminate()
    return True

test_functions = {
    'todo': test_todo, 'service': test_service, 'backup': test_backup,
    'scraper': test_scraper, 'planner': test_planner, 'ranker': test_ranker,
    'aios_start': test_aios_start, 'gdrive': test_gdrive, 'swarm': test_swarm,
    'builder': test_builder, 'web': test_web, 'scheduler': test_scheduler,
    'processes': test_processes
}

detected = detect_programs()
print(f"Detected programs: {', '.join(detected)}")

def run_program_test(prog):
    if prog == 'autollm':
        return (prog, True)
    test_func = test_functions.get(prog, lambda: False)
    return (prog, test_func())

with ThreadPoolExecutor(max_workers=6) as executor:
    futures = [executor.submit(run_program_test, prog) for prog in detected]
    results = dict([future.result() for future in futures])

print("\nTest Results:")
[print(f"{prog}: {'✓' if results.get(prog, False) else '✗'}") for prog in detected]

failed = [prog for prog in detected if not results.get(prog, False)]
print(f"\n{'All tests passed!' if not failed else f'Failed: {', '.join(failed)}'}")
signal.alarm(0)
sys.exit(0 if not failed else 1)

core/aios_api.py:
#!/usr/bin/env python3
from fastapi import FastAPI, Request
import sys
sys.path.append('/home/seanpatten/projects/AIOS/core')
import aios_db
import uvicorn

app = FastAPI()

@app.get("/data/{name}")
async def get_data(name: str):
    return aios_db.read(name)

@app.post("/data/{name}")
async def post_data(name: str, request: Request):
    return aios_db.write(name, await request.json())

@app.post("/event/{target}")
async def emit_event(target: str, request: Request):
    aios_db.execute("events",
                    "CREATE TABLE IF NOT EXISTS events(id INTEGER PRIMARY KEY, target TEXT, data TEXT, created TIMESTAMP DEFAULT CURRENT_TIMESTAMP)")
    aios_db.execute("events", "INSERT INTO events(target, data) VALUES (?, ?)",
                    (target, (await request.body()).decode()))
    return {"status": "ok"}

@app.get("/status")
async def status():
    return {k: aios_db.read(k) for k in ["services", "tasks", "schedule"]}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

services/backup.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import shutil
from pathlib import Path
import aios_db
from datetime import datetime

config = aios_db.read("backup") or {"source": str(Path.home()), "dest": "/tmp/backup"}
source = Path(config.get("source", Path.home()))
dest = Path(config.get("dest", "/tmp/backup")) / f"{datetime.now():%Y%m%d_%H%M%S}"

dest.parent.mkdir(parents=True, exist_ok=True)
shutil.copytree(source, dest, dirs_exist_ok=True)
log = aios_db.read("backup_log") or []
aios_db.write("backup_log", log + [{"time": datetime.now().isoformat(), "dest": str(dest)}])
print(f"Backed up to {dest}")

services/web.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
sys.path.append('/home/seanpatten/projects/AIOS/core')
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import aios_db
import socket
import os
import signal
import subprocess
from urllib.parse import parse_qs, urlparse
from datetime import datetime

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        path = urlparse(self.path).path
        if path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            settings = aios_db.read("settings") or {}
            viewports = settings.get('viewports', ['feed', 'processes', 'schedule', 'todo'])
            theme = settings.get('theme', 'dark')
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            time_format = settings.get("time_format", "12h")

            viewport_data = {}

            if 'todo' in viewports:
                todo_result = subprocess.run("python3 programs/todo/todo.py list", shell=True, capture_output=True, text=True)
                viewport_data['todo'] = {'title': 'Todo', 'items': todo_result.stdout.strip().split('\n')[:4] if todo_result.stdout else []}

            if 'feed' in viewports:
                messages = aios_db.query("feed", "SELECT content, timestamp FROM messages ORDER BY timestamp ASC LIMIT 4")
                viewport_data['feed'] = {'title': 'Feed', 'items': messages}

            if 'processes' in viewports:
                proc_result = subprocess.run("python3 services/processes.py list", shell=True, capture_output=True, text=True)
                viewport_data['processes'] = {'title': 'Processes', 'items': proc_result.stdout.strip().split('\n')[:4] if proc_result.stdout else []}

            if 'schedule' in viewports:
                schedule = aios_db.read("schedule") or {}
                schedule_items = []
                [[schedule_items.append(f"Daily {t}: {c}")] for t,c in sorted(schedule.get("daily",{}).items())]
                [[schedule_items.append(f"Hourly :{int(m):02d}: {c}")] for m,c in sorted(schedule.get("hourly",{}).items(), key=lambda x: int(x[0]))]
                viewport_data['schedule'] = {'title': 'Schedule', 'items': schedule_items[:4]}

            viewport_html = []
            for vp_name in viewports[:4]:
                if vp_name not in viewport_data:
                    continue
                data = viewport_data[vp_name]
                if vp_name == 'feed':
                    items_html = "".join(f'<div class="box-item">{datetime.fromisoformat(m[1]).strftime("%I:%M %p" if time_format == "12h" else "%H:%M")} - {m[0]}</div>' for m in data["items"]) if data["items"] else '<div style="color:#888">No messages</div>'
                else:
                    items_html = "".join(f'<div class="box-item">{item}</div>' for item in data["items"]) if data["items"] else f'<div style="color:#888">No {data["title"].lower()}</div>'

                viewport_html.append(f'''<div class="box" onclick="location.href='/{vp_name}'">
<div class="box-title">{data["title"]}</div>
<div class="box-content">{items_html}</div>
</div>''')

            html = f"""<html>
<head><title>AIOS Control Center</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.container{{max-width:1200px;margin:0 auto}}
.viewport{{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin:20px 0}}
.box{{background:{bg2};border-radius:10px;padding:15px;cursor:pointer;position:relative}}
.box:hover{{opacity:0.9}}
.box-title{{font-weight:bold;margin-bottom:10px;font-size:18px}}
.box-content{{max-height:200px;overflow-y:auto}}
.box-item{{padding:5px 0;border-bottom:1px solid {fg}33}}
button{{background:{fg};color:{bg};border:none;padding:5px 15px;cursor:pointer;margin:5px;border-radius:5px}}
input{{background:{bg2};color:{fg};border:1px solid {fg};padding:12px;width:70%;margin:10px 0;border-radius:5px}}
.run-box{{background:{bg2};border-radius:10px;padding:20px;margin:20px 0}}
.run-button{{padding:12px 30px;font-size:16px}}
.running{{color:#0a0}} .stopped{{color:#a00}}
a{{color:{fg};text-decoration:underline}}
.menu-btn{{position:fixed;top:20px;cursor:pointer;padding:10px;background:{fg};color:{bg};border-radius:5px}}
.settings-btn{{right:20px}}
.views-btn{{right:120px}}
.dropdown{{display:none;position:fixed;top:60px;background:{bg2};border:1px solid {fg};border-radius:10px;padding:10px;min-width:150px;z-index:1000}}
.dropdown.views{{right:120px}}
.dropdown.settings{{right:20px}}
.dropdown-item{{padding:8px 12px;cursor:pointer;border-radius:5px}}
.dropdown-item:hover{{background:{bg}}}
.dropdown.show{{display:block}}
</style>
<script>
function toggleDropdown(type) {{
  const dropdown = document.getElementById(type + '-dropdown');
  const other = type === 'views' ? 'settings' : 'views';
  document.getElementById(other + '-dropdown').classList.remove('show');
  dropdown.classList.toggle('show');
}}
window.onclick = function(e) {{
  if (!e.target.matches('.menu-btn') && !e.target.closest('.dropdown')) {{
    document.querySelectorAll('.dropdown').forEach(d => d.classList.remove('show'));
  }}
}}
</script>
</head>
<body>
<div class="menu-btn views-btn" onclick="toggleDropdown('views')">Views</div>
<div class="dropdown views" id="views-dropdown">
<form action="/views/update" method="POST" id="viewsForm" style="margin:0">
{''.join(f'<label class="dropdown-item" style="display:block;padding:8px 12px;margin:0;cursor:pointer"><input type="checkbox" name="viewport" value="{vp}" {"checked" if vp in viewports else ""} onchange="document.getElementById(\'viewsForm\').submit()" style="margin:0 5px 0 0;accent-color:{fg};vertical-align:middle;width:14px;height:14px">{i+1}. {vp.title()}</label>' for i, vp in enumerate(['feed', 'processes', 'schedule', 'todo']))}
</form>
<div class="dropdown-item" onclick="location.href='/views'" style="font-size:12px;color:{fg}88;border-top:1px solid {fg}33;margin-top:5px;padding-top:10px">Advanced...</div>
</div>
<div class="menu-btn settings-btn" onclick="toggleDropdown('settings')">Settings</div>
<div class="dropdown settings" id="settings-dropdown">
<form action="/settings/theme" method="POST" style="margin:0"><button type="submit" name="theme" value="{'dark' if is_light else 'light'}" class="dropdown-item" style="display:flex;justify-content:space-between;width:100%;text-align:left;background:transparent;color:{fg};padding:8px 12px">Theme <span>{theme.title()}</span></button></form>
<form action="/settings/time" method="POST" style="margin:0"><button type="submit" name="format" value="{'24h' if time_format == '12h' else '12h'}" class="dropdown-item" style="display:flex;justify-content:space-between;width:100%;text-align:left;background:transparent;color:{fg};padding:8px 12px">Time <span>{time_format.upper()}</span></button></form>
<div class="dropdown-item" onclick="location.href='/settings'" style="font-size:12px;color:{fg}88">More...</div>
</div>
<div class="container">
<h1>AIOS Control Center</h1>
<div class="viewport">
{"".join(viewport_html)}
</div>
<div class="run-box">
<h2 style="margin-top:0">Run Command</h2>
<form action="/run" method="POST">
<input name="cmd" placeholder="python3 programs/todo/todo.py list">
<button type="submit" class="run-button">Run</button>
</form>
</div>
</div></body></html>"""
            self.wfile.write(html.encode())
        elif path == '/views':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            settings = aios_db.read("settings") or {}
            current_viewports = settings.get('viewports', ['feed', 'processes', 'schedule', 'todo'])
            all_viewports = ['feed', 'processes', 'schedule', 'todo']
            theme = settings.get('theme', 'dark')
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            html = f"""<html>
<head><title>View Configuration</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.viewport-item{{background:{bg2};padding:15px;margin:10px 0;border-radius:5px}}
button{{background:{fg};color:{bg};border:none;padding:10px 20px;cursor:pointer;margin:5px}}
input[type="checkbox"]{{margin-right:10px;accent-color:{fg}}}
</style></head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Configure Views</h1>
<form action="/views/update" method="POST">
<div class="viewport-item">
<h3>Select Viewports (max 4, order matters)</h3>
{"".join(f'<div><input type="checkbox" name="viewport" value="{vp}" {"checked" if vp in current_viewports else ""}>{i+1}. {vp.title()}</div>' for i, vp in enumerate(all_viewports))}
</div>
<button type="submit">Save</button>
</form>
</body></html>"""
            self.wfile.write(html.encode())
        elif path == '/processes':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            result = subprocess.run("python3 services/processes.py json", shell=True, capture_output=True, text=True)
            processes_data = json.loads(result.stdout) if result.stdout else {"scheduled": [], "ongoing": [], "core": []}
            settings = aios_db.read("settings") or {}
            theme = settings.get('theme', 'dark')
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'

            scheduled_html = "".join(f'<div class="process-item"><span class="time">{p["time"]}</span> {p["path"]} <button onclick="runProcess(\'{p["path"]}\')">Run</button></div>'
                                    for p in processes_data.get("scheduled", []))

            ongoing_html = "".join(f'<div class="process-item">{p["path"]} <span class="status active">●</span> <button onclick="restartProcess(\'{p["path"]}\')">Restart</button></div>'
                                 for p in processes_data.get("ongoing", []))

            core_html = "".join(f'<div class="process-item">{p["path"]} <button onclick="runProcess(\'{p["path"]}\')">Run</button></div>'
                              for p in processes_data.get("core", []))

            html = f"""<html>
<head><title>Processes</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px;max-width:1200px;margin:0 auto}}
h2{{margin:25px 0 10px;font-size:16px;color:{fg}99}}
.section{{margin-bottom:30px}}
.process-item{{background:{bg2};padding:12px;margin:4px 0;border-radius:5px;display:flex;justify-content:space-between;align-items:center}}
.time{{color:{fg}88;margin-right:15px;font-weight:bold}}
.status{{margin:0 10px}}
.status.active{{color:#0a0}}
button{{background:{fg};color:{bg};border:none;padding:4px 12px;cursor:pointer;border-radius:3px;font-size:12px}}
button:hover{{opacity:0.8}}
.toggle-section{{cursor:pointer;user-select:none;color:{fg}66;font-size:12px;margin-top:15px}}
.hidden{{display:none}}
</style>
<script>
function runProcess(path) {{
    fetch('/process/run', {{method: 'POST', body: new URLSearchParams({{'path': path}})}}
    ).then(() => location.reload());
}}
function restartProcess(path) {{
    fetch('/process/restart', {{method: 'POST', body: new URLSearchParams({{'path': path}})}}
    ).then(() => location.reload());
}}
function toggleCore() {{
    const core = document.getElementById('core-section');
    const toggle = document.getElementById('core-toggle');
    if (core.classList.contains('hidden')) {{
        core.classList.remove('hidden');
        toggle.textContent = '▼ Core Processes (hide)';
    }} else {{
        core.classList.add('hidden');
        toggle.textContent = '▶ Core Processes (show)';
    }}
}}
</script>
</head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Processes</h1>

<div class="section">
<h2>SCHEDULED</h2>
{scheduled_html if scheduled_html else '<div style="color:#888;padding:10px">No scheduled processes</div>'}
</div>

<div class="section">
<h2>ONGOING</h2>
{ongoing_html if ongoing_html else '<div style="color:#888;padding:10px">No ongoing processes</div>'}
</div>

<div class="section">
<div id="core-toggle" class="toggle-section" onclick="toggleCore()">▶ Core Processes (show)</div>
<div id="core-section" class="hidden">
<h2>CORE</h2>
{core_html}
</div>
</div>

</body></html>"""
            self.wfile.write(html.encode())
        elif path == '/schedule':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            schedule = aios_db.read("schedule") or {}
            settings = aios_db.read("settings") or {}
            theme = settings.get('theme', 'dark')
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            html = f"""<html>
<head><title>Schedule</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.schedule-item{{background:{bg2};padding:10px;margin:5px 0;border-radius:5px}}
</style></head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Schedule</h1>
<h2>Daily Tasks</h2>
<div>{"".join(f'<div class="schedule-item">{t}: {c}</div>' for t,c in sorted(schedule.get("daily",{}).items()))}</div>
<h2>Hourly Tasks</h2>
<div>{"".join(f'<div class="schedule-item">:{int(m):02d}: {c}</div>' for m,c in sorted(schedule.get("hourly",{}).items(), key=lambda x: int(x[0])))}</div>
</body></html>"""
            self.wfile.write(html.encode())
        elif path == '/feed':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            messages = aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp ASC LIMIT 100")
            settings = aios_db.read("settings") or {}
            time_format = settings.get("time_format", "12h")
            theme = settings.get('theme', 'dark')
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            current_date = None
            feed_html = []
            [[feed_html.append(f'<div style="color:#888;font-weight:bold;margin:15px 0 5px">{datetime.fromisoformat(m[2]).date()}</div>') if (current_date := datetime.fromisoformat(m[2]).date()) != current_date else None,
              feed_html.append(f'<div style="padding:8px;margin:2px 0">{datetime.fromisoformat(m[2]).strftime("%I:%M %p" if time_format == "12h" else "%H:%M")} - {m[1]}</div>')]
             for m in messages]
            html = f"""<html>
<head><title>Feed</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.feed-box{{background:{bg2};border-radius:10px;padding:15px;height:400px;overflow-y:auto;margin:20px 0}}
button{{background:{fg};color:{bg};border:none;padding:5px 15px;cursor:pointer;margin:5px}}
</style></head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Feed</h1>
<div class="feed-box">{"".join(feed_html) if feed_html else "<div style='color:#888'>No messages yet</div>"}</div>
</body></html>"""
            self.wfile.write(html.encode())
        elif path == '/settings':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            settings = aios_db.read("settings") or {}
            time_format = settings.get("time_format", "12h")
            theme = settings.get('theme', 'dark')
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            html = f"""<html>
<head><title>Settings</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.setting{{background:{bg2};padding:15px;margin:10px 0;border-radius:10px}}
button{{background:{fg};color:{bg};border:none;padding:10px 20px;cursor:pointer;margin:5px;border-radius:5px}}
</style></head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Settings</h1>
<div class="setting">
<h3>Theme</h3>
<form action="/settings/theme" method="POST">
<button type="submit" name="theme" value="dark" {'style="font-weight:bold"' if theme == "dark" else ""}>Dark Mode</button>
<button type="submit" name="theme" value="light" {'style="font-weight:bold"' if theme == "light" else ""}>Light Mode</button>
</form>
</div>
<div class="setting">
<h3>Time Format</h3>
<form action="/settings/time" method="POST">
<button type="submit" name="format" value="12h" {'style="font-weight:bold"' if time_format == "12h" else ""}>12-hour (AM/PM)</button>
<button type="submit" name="format" value="24h" {'style="font-weight:bold"' if time_format == "24h" else ""}>24-hour</button>
</form>
</div>
</body></html>"""
            self.wfile.write(html.encode())
        elif path == '/todo':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            result = subprocess.run("python3 programs/todo/todo.py list", shell=True, capture_output=True, text=True)
            tasks = result.stdout.strip().split('\n') if result.stdout else []
            settings = aios_db.read("settings") or {}
            theme = settings.get('theme', 'dark')
            is_light = theme == 'light'
            bg = '#fff' if is_light else '#000'
            fg = '#000' if is_light else '#fff'
            bg2 = '#f0f0f0' if is_light else '#1a1a1a'
            html = f"""<html>
<head><title>Todo</title>
<style>
body{{font-family:monospace;background:{bg};color:{fg};padding:20px}}
.task{{background:{bg2};padding:10px;margin:5px 0;border-radius:5px}}
.done{{text-decoration:line-through;color:#666}}
button{{background:{fg};color:{bg};border:none;padding:5px 10px;cursor:pointer;margin:2px}}
input{{background:{bg2};color:{fg};border:1px solid {fg};padding:10px;width:50%;margin:10px 0}}
</style></head>
<body>
<div style="margin-bottom:20px"><a href="/" style="padding:10px;background:{fg};color:{bg};border-radius:5px;text-decoration:none">Back</a></div>
<h1>Todo Manager</h1>
<form action="/todo/add" method="POST">
<input name="task" placeholder="New task... (use @ for deadline, e.g., Buy milk @ 14:30)">
<button type="submit">Add</button>
</form>
<div>{"".join(f'<div class="task {"done" if "[x]" in t else ""}">{t} <form style="display:inline" action="/todo/done" method="POST"><input type="hidden" name="id" value="{t.split(".")[0] if "." in t else i+1}"><button>Done</button></form></div>' for i,t in enumerate(tasks))}</div>
<form action="/todo/clear" method="POST"><button>Clear Completed</button></form>
</body></html>"""
            self.wfile.write(html.encode())

    def do_POST(self):
        path = urlparse(self.path).path
        length = int(self.headers['Content-Length'])
        data = parse_qs(self.rfile.read(length).decode())

        if path == '/run':
            cmd = data.get('cmd', [''])[0]
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            output = f"<pre>{result.stdout}\n{result.stderr}</pre>"
            self.wfile.write(f'<html><body><a href="/">Back</a><h2>Output:</h2>{output}</body></html>'.encode())
        elif path == '/todo/add':
            task = data.get('task', [''])[0]
            subprocess.run(f"python3 programs/todo/todo.py add {task}", shell=True)
            self.send_response(303)
            self.send_header('Location', '/todo')
            self.end_headers()
        elif path == '/todo/done':
            task_id = data.get('id', [''])[0]
            subprocess.run(f"python3 programs/todo/todo.py done {task_id}", shell=True)
            self.send_response(303)
            self.send_header('Location', '/todo')
            self.end_headers()
        elif path == '/todo/clear':
            subprocess.run("python3 programs/todo/todo.py clear", shell=True)
            self.send_response(303)
            self.send_header('Location', '/todo')
            self.end_headers()
        elif path == '/settings/time':
            format_val = data.get('format', ['12h'])[0]
            settings = aios_db.read('settings') or {}
            aios_db.write('settings', {**settings, 'time_format': format_val})
            self.send_response(303)
            self.send_header('Location', '/')
            self.end_headers()
        elif path == '/settings/theme':
            theme_val = data.get('theme', ['dark'])[0]
            settings = aios_db.read('settings') or {}
            aios_db.write('settings', {**settings, 'theme': theme_val})
            self.send_response(303)
            self.send_header('Location', '/')
            self.end_headers()
        elif path == '/views/update':
            selected = data.get('viewport', [])
            if not isinstance(selected, list):
                selected = [selected]
            settings = aios_db.read('settings') or {}
            aios_db.write('settings', {**settings, 'viewports': selected[:4]})
            self.send_response(303)
            self.send_header('Location', '/')
            self.end_headers()
        elif path == '/process/run':
            process_path = data.get('path', [''])[0]
            subprocess.Popen(['python3', process_path])
            self.send_response(303)
            self.send_header('Location', '/processes')
            self.end_headers()
        elif path == '/process/restart':
            process_path = data.get('path', [''])[0]
            subprocess.run(['pkill', '-f', process_path])
            subprocess.Popen(['python3', process_path])
            self.send_response(303)
            self.send_header('Location', '/processes')
            self.end_headers()

def find_free_port(start=8080):
    for port in range(start, start + 100):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('127.0.0.1', port))
        sock.close()
        if result != 0:
            return port
    return start

def start_server():
    port = find_free_port()
    print(f"AIOS Control Center: http://localhost:{port}")
    aios_db.write("web_server", {"port": port, "pid": os.getpid()})
    HTTPServer(('', port), Handler).serve_forever()

def kill_server():
    info = aios_db.read("web_server")
    pid = info.get("pid") if info else None
    if pid:
        try:
            os.kill(pid, signal.SIGTERM)
            print(f"Killed server (PID: {pid})")
        except ProcessLookupError:
            print("Server not running")
    else:
        print("No server running")

command = sys.argv[1] if len(sys.argv) > 1 else "start"

actions = {
    "start": start_server,
    "stop": kill_server,
    "status": lambda: print(f"Server: {aios_db.read('web_server') or 'Not running'}"),
    "kill": kill_server
}

actions.get(command, start_server)()

services/service.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import aios_db

services = aios_db.read("services") or {}
command = sys.argv[1] if len(sys.argv) > 1 else "list"
name = sys.argv[2] if len(sys.argv) > 2 else None

actions = {
    "list": lambda: [print(f"{k}: {v.get('status', 'unknown')}") for k, v in services.items()],
    "start": lambda: aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "running"}}),
    "stop": lambda: aios_db.write("services", {**services, name: {**services.get(name, {}), "status": "stopped"}}),
    "status": lambda: print(services.get(name, {}).get("status", "unknown") if name else "specify service")
}

actions.get(command, actions["list"])()

services/scraper.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import requests
from bs4 import BeautifulSoup
import aios_db
from datetime import datetime

config = aios_db.read("scraper") or {"urls": ["https://news.ycombinator.com"]}
results = []

[results.append({
    "url": url,
    "title": BeautifulSoup(requests.get(url).text, 'html.parser').title.string if BeautifulSoup(requests.get(url).text, 'html.parser').title else "No title",
    "time": datetime.now().isoformat()
}) for url in config.get("urls", [])]

aios_db.write("scraper_results", results)
[print(f"{r['url']}: {r['title']}") for r in results]

services/context_generator.py:
from pathlib import Path
from datetime import datetime

def generate():
    root = Path(__file__).parent.parent
    output = Path(root / "projectContext.txt")
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    files = [f for f in root.rglob("*.py") if "archive" not in f.parts]
    readme = root / "README.md"

    content = f"Generated: {timestamp}\n\n"
    content += "\n".join([f"{f.relative_to(root)}:\n{f.read_text()}\n" for f in files])
    content += f"\nREADME.md:\n{readme.read_text()}\n" if readme.exists() else ""

    output.write_text(content)
    return str(output)

services/processes.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import aios_db
import json
from pathlib import Path
from datetime import datetime

command = sys.argv[1] if len(sys.argv) > 1 else "json"
name = sys.argv[2] if len(sys.argv) > 2 else None

def get_all_processes():
    schedule = aios_db.read("schedule") or {}
    pids = aios_db.read("aios_pids") or {}
    python_files = list(Path('/home/seanpatten/projects/AIOS').rglob('*.py'))

    scheduled = sorted(
        [{"path": cmd, "type": "daily", "time": time, "status": "scheduled"} for time, cmd in schedule.get("daily", {}).items()] +
        [{"path": cmd, "type": "hourly", "time": f":{int(m):02d}", "status": "scheduled"} for m, cmd in schedule.get("hourly", {}).items()],
        key=lambda x: x["time"]
    )

    ongoing = [{"path": f"{k}_pid_{v}", "type": "running", "status": "active"} for k, v in pids.items()]

    core = [{"path": str(f.relative_to(Path('/home/seanpatten/projects/AIOS'))), "type": "file", "status": "available"}
            for f in python_files if 'archive' not in f.parts and '__pycache__' not in f.parts]

    return {"scheduled": scheduled, "ongoing": ongoing, "core": core}

actions = {
    "json": lambda: print(json.dumps(get_all_processes())),
    "list": lambda: [print(f"{p['path']}: {p['status']}") for cat in get_all_processes().values() for p in cat],
    "start": lambda: subprocess.Popen(['python3', name]) if name else None,
    "stop": lambda: subprocess.run(['pkill', '-f', name]) if name else None
}

actions.get(command, actions["json"])()

services/gdrive.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
import aios_db
from datetime import datetime
from pathlib import Path

config = aios_db.read("gdrive") or {"folder_id": "root"}
creds = Credentials.from_authorized_user_info(aios_db.read("gdrive_creds") or {})
service = build('drive', 'v3', credentials=creds)

command = sys.argv[1] if len(sys.argv) > 1 else "sync"
source = Path(sys.argv[2]) if len(sys.argv) > 2 else Path.home()

actions = {
    "sync": lambda: [service.files().create(body={'name': f.name, 'parents': [config['folder_id']]},
                                            media_body=MediaFileUpload(str(f))).execute()
                     for f in source.glob('*') if f.is_file()],
    "list": lambda: [print(f['name']) for f in service.files().list(q=f"'{config['folder_id']}' in parents").execute().get('files', [])],
    "download": lambda: [open(f['name'], 'wb').write(service.files().get_media(fileId=f['id']).execute())
                        for f in service.files().list(q=f"'{config['folder_id']}' in parents").execute().get('files', [])],
    "status": lambda: print(f"Connected to folder: {config['folder_id']}")
}

actions.get(command, actions["status"])()

services/feed.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime

command = sys.argv[1] if len(sys.argv) > 1 else "list"

aios_db.execute("feed", "CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY, content TEXT, timestamp TEXT, source TEXT, priority INTEGER DEFAULT 0)")

actions = {
    "add": lambda: aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)",
                                   (" ".join(sys.argv[2:]), datetime.now().isoformat(), "manual")),
    "list": lambda: [print(f"{row[3].split('T')[1][:5]} {row[1]}" if datetime.fromisoformat(row[2]).date() == datetime.now().date() else f"{row[2].split('T')[0]} {row[2].split('T')[1][:5]} {row[1]}")
                    for row in aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")],
    "view": lambda: [print(f"{datetime.fromisoformat(row[2]).strftime('%I:%M %p' if (aios_db.read('settings') or {}).get('time_format', '12h') == '12h' else '%H:%M')} {row[1]}"
                          if datetime.fromisoformat(row[2]).date() == datetime.now().date() else
                          f"{row[2].split('T')[0]} {datetime.fromisoformat(row[2]).strftime('%I:%M %p' if (aios_db.read('settings') or {}).get('time_format', '12h') == '12h' else '%H:%M')} {row[1]}")
                    for row in aios_db.query("feed", "SELECT id, content, timestamp, source FROM messages ORDER BY timestamp DESC LIMIT 50")],
    "clear": lambda: aios_db.execute("feed", "DELETE FROM messages WHERE timestamp < datetime('now', '-7 days')")
}

actions.get(command, actions["list"])()

programs/ranker/ranker.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime

ideas = aios_db.read("ideas") or []
command = sys.argv[1] if len(sys.argv) > 1 else "list"

def score(idea):
    return len(idea.get('description', '')) * idea.get('impact', 1) / max(idea.get('effort', 1), 1)

actions = {
    "add": lambda: aios_db.write("ideas", ideas + [{"description": ' '.join(sys.argv[2:]), "impact": 5, "effort": 5, "added": datetime.now().isoformat()}]),
    "rank": lambda: [print(f"{i+1}. [{score(idea):.1f}] {idea['description']}") for i, idea in enumerate(sorted(ideas, key=score, reverse=True))],
    "list": lambda: [print(f"{i+1}. {idea['description']}") for i, idea in enumerate(ideas)],
    "pick": lambda: print(f"Best: {sorted(ideas, key=lambda x: score(x)/x.get('effort', 5), reverse=True)[0]['description']}" if ideas else "No ideas")
}

actions.get(command, actions["list"])()

programs/builder/builder.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
from pathlib import Path
import aios_db
from datetime import datetime
import concurrent.futures

components = sys.argv[1:] if len(sys.argv) > 1 else []
build_dir = Path.home() / ".aios" / "builds"
build_dir.mkdir(parents=True, exist_ok=True)

def build_component(name):
    result = subprocess.run(['echo', f'Building {name}'], capture_output=True, text=True)
    (build_dir / f"{name}.build").write_text(f"Built at {datetime.now()}")
    return {"name": name, "status": "success" if result.returncode == 0 else "failed", "time": datetime.now().isoformat()}

results = list(concurrent.futures.ThreadPoolExecutor(max_workers=4).map(build_component, components)) if components else []
[print(f"{r['name']}: {r['status']}") for r in results]
aios_db.write("build_log", aios_db.read("build_log") or [] + results)

programs/schedule/scheduler.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import schedule as sched
import time
import subprocess
import aios_db

schedules = aios_db.read("schedule")

[sched.every().day.at(t).do(lambda c=cmd: subprocess.run(c, shell=True))
 for t, cmd in schedules.get("daily", {}).items()]

[sched.every().hour.at(f":{int(m):02d}").do(lambda c=cmd: subprocess.run(c, shell=True))
 for m, cmd in schedules.get("hourly", {}).items()]

[[sched.run_pending(), time.sleep(60)] for _ in iter(int, 1)]

programs/planner/planner.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime, timedelta

tasks = aios_db.read("tasks") or []
today = datetime.now().date()
plan = aios_db.read("daily_plan") or {}

pending = [t for t in tasks if not t.startswith("[x]") and not t.startswith("[!]")]
plan[str(today)] = pending[:10]

aios_db.write("daily_plan", plan)
[print(f"- {t}") for t in plan[str(today)]]

programs/swarm/swarm.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
import anthropic
from datetime import datetime

cache = aios_db.read("llm_cache") or {}
command = sys.argv[1] if len(sys.argv) > 1 else "list"
question = ' '.join(sys.argv[2:]) if len(sys.argv) > 2 else ""

client = anthropic.Anthropic(api_key=aios_db.read("api_keys").get("anthropic", ""))

actions = {
    "ask": lambda: aios_db.write("llm_cache", {**cache, question: {"response": client.messages.create(
        model="claude-3-haiku-20240307",
        max_tokens=500,
        messages=[{"role": "user", "content": question}]
    ).content[0].text, "time": datetime.now().isoformat()}}),
    "list": lambda: [print(f"Q: {q[:50]}... A: {a['response'][:50]}...") for q, a in cache.items()],
    "clear": lambda: aios_db.write("llm_cache", {}),
    "stats": lambda: print(f"Cached queries: {len(cache)}")
}

result = actions.get(command, actions["list"])()
print(cache.get(question, {}).get("response", "") if command == "ask" else "")

programs/todo/todo.py:
#!/usr/bin/env python3
import sys
sys.path.append("/home/seanpatten/projects/AIOS/core")
sys.path.append('/home/seanpatten/projects/AIOS')
import aios_db
from datetime import datetime, timedelta

tasks = aios_db.read("tasks") or []
command = sys.argv[1] if len(sys.argv) > 1 else "list"

def add_task():
    task_text = ' '.join(sys.argv[2:])
    deadline_parts = task_text.split('@')
    task_desc = deadline_parts[0].strip()
    deadline = datetime.now() + timedelta(hours=1)
    deadline_str = deadline_parts[1].strip() if len(deadline_parts) > 1 else None
    [[deadline := datetime.strptime(f"{datetime.now().date()} {deadline_str}", "%Y-%m-%d %H:%M")] if deadline_str and ':' in deadline_str else None]
    new_task = f"[ ] {datetime.now():%Y-%m-%d %H:%M} {task_desc}"
    aios_db.write("tasks", tasks + [new_task])
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)",
                    (f"Task: {task_desc} (Due: {deadline.strftime('%I:%M %p')})" if deadline_str else f"Task: {task_desc}",
                     deadline.isoformat() if deadline_str else datetime.now().isoformat(), "todo"))

def done_task():
    task_id = int(sys.argv[2]) - 1
    task = tasks[task_id]
    task_text = ' '.join(task.split()[3:])
    aios_db.write("tasks", [t.replace("[ ]", "[x]") if i == task_id else t for i, t in enumerate(tasks)])
    aios_db.execute("feed", "INSERT INTO messages(content, timestamp, source) VALUES (?, ?, ?)",
                    (f"Completed: {task_text}", datetime.now().isoformat(), "todo"))

actions = {
    "list": lambda: [print(f"{i+1}. {t}") for i, t in enumerate(tasks)],
    "add": add_task,
    "done": done_task,
    "clear": lambda: aios_db.write("tasks", [t for t in tasks if not t.startswith("[x]")])
}

aios_db.execute("feed", "CREATE TABLE IF NOT EXISTS messages(id INTEGER PRIMARY KEY, content TEXT, timestamp TEXT, source TEXT, priority INTEGER DEFAULT 0)")
actions.get(command, actions["list"])()

programs/autollm/autollm.py:
#!/usr/bin/env python3
"""Claude Auto - Simplified automation tool for Claude CLI"""

import os, sys, json, time, subprocess, tempfile, shutil, threading, queue, select
from pathlib import Path
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

__version__ = "6.1.0"

WORKFLOWS = {
    'standard': [
        ('Build', 'Before you begin read the files in this directory for context. Write all logic and functionality into a single .py file unless explicitly stated otherwise, no functionality is reliant on anything but this and it should run alone without any supporting files except if needed environmental setup.Set an aggressive target for low line count and stick to it if not given one.'),
        ('Debug', 'Run the existing code, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it.'),
        ('Finalize', 'Run it, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it. Then update/create the readme and simplify it aggressively. Everything must go except that which would make the user unable to use the script.')
    ],
    'simplify': [
        ('Build', 'Before you begin read the files in this directory for context. Write all logic and functionality into a single .py file unless explicitly stated otherwise, no functionality is reliant on anything but this and it should run alone without any supporting files except if needed environmental setup.Set an aggressive target for low line count and stick to it if not given one.'),
        ('Debug', 'Run the existing code, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it.'),
        ('Simplify', 'We are going to do a significant simplification. We will be deleting more than half of the lines of the single logical file without harming functionality, simplicity, following conventions, maintaining readability.'),
        ('Finalize', 'Run it, debug it, and make it work well. Any changes should be extremely minimal just to fix problems and if it works don\'t change it. Then update/create the readme and simplify it aggressively. Everything must go except that which would make the user unable to use the script.')
    ]
}

class ClaudeAuto:
    def __init__(self, output_dir="./claude_output", working_dir=None):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.working_dir = Path(working_dir) if working_dir else Path.cwd()
        if not self.working_dir.exists():
            print(f"⚠️  Working directory doesn't exist: {self.working_dir}")
            if input("Create it? (y/n): ").strip().lower() == 'y':
                self.working_dir.mkdir(parents=True, exist_ok=True)
            else:
                self.working_dir = Path.cwd()
        self.results = []
        self.active_tasks = {}
        self.task_lock = threading.Lock()
        self.completed_queue = queue.Queue()
        self.notification_thread = None
    

    def start_monitoring(self):
        """Start background monitoring"""
        # Clear screen
        print('\033[2J\033[H')

    def execute_claude(self, prompt, cwd=None, output_file=None, prefix="", task_id=None):
        """Execute Claude CLI with prompt"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as tmp:
            tmp.write(prompt)
            temp_file = tmp.name
        
        try:
            task_name = prefix.strip('[]').strip() if prefix else 'Task'
            if task_id:
                with self.task_lock:
                    self.active_tasks[task_id] = {'name': task_name, 'start': time.time()}

            cmd = f"claude --dangerously-skip-permissions < {temp_file} 2>&1 | head -c 500000"
            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                     stderr=subprocess.STDOUT, text=True,
                                     cwd=str(cwd or self.working_dir), errors='replace')

            output_lines = []
            for line in process.stdout:
                # Don't print to console for background tasks
                output_lines.append(line)
                if output_file:
                    with open(output_file, 'a') as f:
                        f.write(line)
                        f.flush()
            
            exit_code = process.wait(timeout=300)
            os.unlink(temp_file)

            if task_id:
                with self.task_lock:
                    if task_id in self.active_tasks:
                        del self.active_tasks[task_id]

            return exit_code == 0, ''.join(output_lines)
        except Exception as e:
            print(f"❌ Error: {e}")
            if task_id:
                with self.task_lock:
                    if task_id in self.active_tasks:
                        del self.active_tasks[task_id]
            return False, str(e)
    
    def run_task(self, name, prompt, task_id=None, future=None):
        """Run a single task"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        task_dir = self.output_dir / f"{name}_{timestamp}"
        task_dir.mkdir(exist_ok=True)
        output_file = task_dir / "output.txt"

        prefix = f"[{task_id}] " if task_id else ""

        with open(output_file, 'w') as f:
            f.write(f"=== {name} ===\n{datetime.now()}\n\n--- Prompt ---\n{prompt}\n{'='*60}\n\n")

        success, _ = self.execute_claude(prompt, cwd=task_dir, output_file=output_file, prefix=prefix, task_id=task_id)

        # Remove from active tasks and add to completed queue
        if task_id:
            with self.task_lock:
                if task_id in self.active_tasks:
                    del self.active_tasks[task_id]
            self.completed_queue.put((task_id, name, time.time()))

        result = {'name': name, 'success': success, 'output': str(output_file)}
        self.results.append(result)
        return result
    
    def run_workflow(self, workflow_type, initial_task, version_num=None, num_versions=1):
        """Run a complete workflow"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        version_suffix = f"_v{version_num}" if version_num else ""
        # Use working_dir instead of output_dir when a custom directory is specified
        base_dir = self.working_dir if self.working_dir != Path.cwd() else self.output_dir
        workflow_dir = base_dir / f"workflow_{timestamp}{version_suffix}"
        workflow_dir.mkdir(parents=True, exist_ok=True)
        
        # Copy files from working directory to workflow directory if needed
        if self.working_dir != Path.cwd() and self.working_dir.exists():
            print(f"\n📂 Copying files from {self.working_dir}...")
            for item in self.working_dir.iterdir():
                if item.name.startswith('.') or item.name in ['__pycache__', 'node_modules', '.git', 'claude_output']:
                    continue
                dest = workflow_dir / item.name
                if item.is_file():
                    shutil.copy2(item, dest)
                elif item.is_dir():
                    shutil.copytree(item, dest, dirs_exist_ok=True)
        
        # Always work in the workflow directory so files are saved there
        working_dir = workflow_dir
        
        output_file = workflow_dir / "output.txt"
        with open(output_file, 'w') as f:
            f.write(f"{'='*80}\nWORKFLOW EXECUTION - {datetime.now()}\n")
            if version_num:
                f.write(f"Version: {version_num}/{num_versions}\n")
            f.write(f"Initial Task: {initial_task[:100]}{'...' if len(initial_task) > 100 else ''}\n{'='*80}\n\n")
        
        results = []
        steps = WORKFLOWS[workflow_type]
        
        for i, (step_name, step_prompt) in enumerate(steps, 1):
            full_prompt = f"Working in: {working_dir}\n\n{initial_task if step_name == 'Build' else step_prompt}"
            
            with open(output_file, 'a') as f:
                f.write(f"\n{'#'*80}\nSTEP {i}/{len(steps)}: {step_name.upper()}\n{'#'*80}\n")
                f.write(f"\n--- Prompt for {step_name} ---\n{full_prompt}\n\n--- Claude Response ---\n")
            
            prefix = f"[V{version_num}] " if version_num else ""
            task_id = f"BGV{version_num}S{i}" if version_num else f"BGS{i}"
            # Don't print step messages for background workflows
            success, _ = self.execute_claude(full_prompt, cwd=working_dir, output_file=output_file, prefix=prefix, task_id=task_id)
            
            # Don't print step completion for background workflows
            results.append({'name': step_name, 'success': success})
            
            if not success:
                print(f"⚠️  {prefix}Step failed, stopping workflow")
                break
        
        return {'version': version_num or 'single', 'directory': str(workflow_dir),
                'output': str(output_file), 'success': all(r['success'] for r in results)}

def get_dir_size(path):
    """Get directory size in MB"""
    total = sum(os.path.getsize(os.path.join(dp, f)) 
                for dp, _, fns in os.walk(path) 
                for f in fns if os.path.exists(os.path.join(dp, f)))
    return total / (1024 * 1024)

def main():
    """Main interactive loop"""
    import argparse
    parser = argparse.ArgumentParser(description='Claude Auto - Automation tool')
    parser.add_argument('-d', '--dir', dest='working_dir', help='Working directory')
    parser.add_argument('-o', '--output', default='./claude_output', help='Output directory')
    args = parser.parse_args()

    auto = ClaudeAuto(output_dir=args.output, working_dir=args.working_dir)
    auto.start_monitoring()
    
    # Check Claude CLI
    if subprocess.run(['which', 'claude'], capture_output=True).returncode != 0:
        print("❌ Claude CLI not found! Install with: npm install -g @anthropic/claude-cli")
        sys.exit(1)
    
    print(f"\n{'='*60}\nClaude Auto v{__version__}\nWorking: {auto.working_dir}\nOutput: {auto.output_dir}\n{'='*60}")

    executor = ThreadPoolExecutor(max_workers=10)
    background_futures = []

    # Store recent notifications
    recent_notifications = []
    notification_lock = threading.Lock()

    def status_updater():
        """Background thread to update status and collect notifications"""
        while True:
            try:
                time.sleep(1)
                # Check for new completions
                while not auto.completed_queue.empty():
                    try:
                        task_id, name, completion_time = auto.completed_queue.get_nowait()
                        with notification_lock:
                            recent_notifications.append({
                                'msg': f"🔔 {name} completed [{task_id}]",
                                'time': time.time()
                            })
                            # Keep only last 10 notifications
                            if len(recent_notifications) > 10:
                                recent_notifications.pop(0)
                        # Print notification immediately
                        print(f"\n\033[93m🔔 {name} completed [{task_id}]\033[0m")
                        print("Choice: ", end='', flush=True)  # Re-show prompt
                    except:
                        break
            except:
                break

    # Start status updater thread
    status_thread = threading.Thread(target=status_updater, daemon=True)
    status_thread.start()

    def print_status():
        """Print current status with notifications"""
        # Clean old notifications (older than 30 seconds)
        with notification_lock:
            current_time = time.time()
            for notif in recent_notifications[:]:
                if current_time - notif['time'] > 30:
                    recent_notifications.remove(notif)

            # Show recent notifications
            if recent_notifications:
                for notif in recent_notifications[-3:]:  # Show last 3 notifications
                    print(f"\033[93m{notif['msg']}\033[0m")

        # Display status
        active_count = len(auto.active_tasks)
        if active_count > 0:
            active_list = ", ".join([f"{tid}" for tid in list(auto.active_tasks.keys())[:5]])
            print(f"\n\033[92m⚡ Active: {active_count} tasks [{active_list}]\033[0m")

    while True:
        # Clean up completed background tasks
        background_futures = [f for f in background_futures if not f.done()]

        print_status()

        print("\n🎯 Options:\n1. Quick prompt\n2. Multiple tasks (parallel)\n3. Multiple tasks (sequential)")
        print(f"4. Workflow\n5. Exit")

        try:
            choice = input("\nChoice: ").strip()
        except (EOFError, KeyboardInterrupt):
            break
        
        if choice == '1':
            print("Enter prompt (Ctrl+D to finish):")
            try:
                lines = []
                while True:
                    lines.append(input())
            except EOFError:
                prompt = '\n'.join(lines).strip()
                if prompt:
                    task_id = f"BG{len(background_futures)+1}"
                    # Pre-register the task
                    with auto.task_lock:
                        auto.active_tasks[task_id] = {'name': 'Task', 'start': time.time()}
                    future = executor.submit(auto.run_task, 'Task', prompt, task_id, None)
                    with auto.task_lock:
                        if task_id in auto.active_tasks:
                            auto.active_tasks[task_id]['future'] = future
                    background_futures.append(future)
                    print(f"\n⚡ Task launched in background as {task_id}")
        
        elif choice in ['2', '3']:
            tasks = []
            print("\nEnter tasks (empty name to finish):")
            while True:
                name = input(f"Task {len(tasks)+1} name: ").strip()
                if not name:
                    break
                print("Prompt (Ctrl+D to finish):")
                try:
                    lines = []
                    while True:
                        lines.append(input())
                except EOFError:
                    prompt = '\n'.join(lines).strip()
                    if prompt:
                        tasks.append({'name': name, 'prompt': prompt})
            
            if tasks:
                base_id = len(background_futures)
                if choice == '2' and len(tasks) > 1:
                    # Parallel execution
                    futures = []
                    for i, t in enumerate(tasks):
                        task_id = f"BG{base_id+i+1}"
                        with auto.task_lock:
                            auto.active_tasks[task_id] = {'name': t['name'], 'start': time.time()}
                        future = executor.submit(auto.run_task, t['name'], t['prompt'], task_id, None)
                        with auto.task_lock:
                            if task_id in auto.active_tasks:
                                auto.active_tasks[task_id]['future'] = future
                        futures.append(future)
                    background_futures.extend(futures)
                    print(f"\n⚡ {len(tasks)} tasks launched in parallel")
                else:
                    # Sequential execution in background
                    def run_sequential():
                        for i, task in enumerate(tasks):
                            task_id = f"BG{base_id+i+1}"
                            with auto.task_lock:
                                auto.active_tasks[task_id] = {'name': task['name'], 'start': time.time()}
                            auto.run_task(task['name'], task['prompt'], task_id)
                    future = executor.submit(run_sequential)
                    background_futures.append(future)
                    print(f"\n⚡ {len(tasks)} tasks launched sequentially in background")
        
        elif choice == '4':
            print("\n🔧 WORKFLOW MODE")
            print(f"📂 Working: {auto.working_dir}")
            
            # Workflow type
            print("\n1. Standard (3 steps)\n2. With simplification (4 steps)")
            wf_type = 'simplify' if input("Choice [1-2]: ").strip() == '2' else 'standard'
            
            # Number of versions
            num_versions = 1
            exec_mode = 'single'
            print("\n1. Single version\n2. Multiple versions")
            if input("Choice [1-2]: ").strip() == '2':
                try:
                    num_versions = max(1, min(10, int(input("Number of versions (2-10): ").strip())))
                    if num_versions > 1:
                        print("\n1. Parallel\n2. Sequential")
                        exec_mode = 'parallel' if input("Choice [1-2]: ").strip() == '1' else 'sequential'
                except:
                    num_versions = 2
            
            # Working directory
            if input("\n📁 Change working directory? (y/n): ").strip().lower() == 'y':
                new_dir = input("Path: ").strip()
                if new_dir:
                    auto.working_dir = Path(new_dir)
                    if not auto.working_dir.exists():
                        auto.working_dir.mkdir(parents=True, exist_ok=True)
            
            # Check size for parallel copy
            if num_versions > 1 and exec_mode == 'parallel' and auto.working_dir != Path.cwd():
                size_mb = get_dir_size(auto.working_dir)
                if size_mb > 100:
                    print(f"\n⚠️  Will copy {size_mb:.1f}MB. Continue in 10s (Ctrl+C to abort)...")
                    try:
                        for i in range(10, 0, -1):
                            print(f"\r{i}... ", end='', flush=True)
                            time.sleep(1)
                    except KeyboardInterrupt:
                        continue
            
            # Get task
            print("\n📝 Enter task (Ctrl+D to finish):")
            try:
                lines = []
                while True:
                    lines.append(input())
            except EOFError:
                initial_task = '\n'.join(lines).strip()
            
            if not initial_task:
                continue
            
            print(f"\n🚀 Starting {num_versions} workflow(s)...")
            
            # Execute workflows in background
            if num_versions == 1:
                future = executor.submit(auto.run_workflow, wf_type, initial_task)
                background_futures.append(future)
                print(f"⚡ Workflow launched in background")
            elif exec_mode == 'parallel':
                futures = [executor.submit(auto.run_workflow, wf_type, initial_task, i+1, num_versions)
                         for i in range(num_versions)]
                background_futures.extend(futures)
                print(f"⚡ {num_versions} workflows launched in parallel")
            else:
                def run_sequential_workflows():
                    for i in range(num_versions):
                        auto.run_workflow(wf_type, initial_task, i+1, num_versions)
                future = executor.submit(run_sequential_workflows)
                background_futures.append(future)
                print(f"⚡ {num_versions} workflows launched sequentially")
        
        if choice == '5':
            break
        
        # Show results summary
        if auto.results:
            print(f"\n{'='*60}\nSUMMARY\n{'='*60}")
            print(f"✅ Successful: {sum(1 for r in auto.results if r.get('success'))}")
            print(f"❌ Failed: {sum(1 for r in auto.results if not r.get('success'))}")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\033[?25h")  # Show cursor
        print("\n\n⚠️ Interrupted")
        sys.exit(130)

programs/aios_start/aios_start.py:
#!/usr/bin/env python3
import sys
sys.path.append('/home/seanpatten/projects/AIOS')
import subprocess
import time
import aios_db
from pathlib import Path
import webbrowser
import os
import signal

aios_path = Path.home() / ".aios"
command = sys.argv[1] if len(sys.argv) > 1 else "start"

def kill_existing():
    subprocess.run(["pkill", "-f", "aios_api.py"], stderr=subprocess.DEVNULL)
    subprocess.run(["pkill", "-f", "programs/web/web.py"], stderr=subprocess.DEVNULL)
    pids = aios_db.read("aios_pids") or {}
    for pid in pids.values():
        if pid:
            try:
                os.kill(pid, signal.SIGTERM)
            except ProcessLookupError:
                pass

def start():
    start_time = time.time()
    kill_existing()
    aios_path.mkdir(exist_ok=True)
    api_proc = subprocess.Popen(["python3", "aios_api.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    web_proc = subprocess.Popen(["python3", "programs/web/web.py", "start"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    aios_db.write("aios_pids", {"api": api_proc.pid, "web": web_proc.pid})
    time.sleep(0.1)
    info = aios_db.read("web_server") or {}
    url = f"http://localhost:{info.get('port', 8080)}"
    elapsed = time.time() - start_time
    print(f"AIOS started in {elapsed:.3f}s: {url}")
    webbrowser.open(url)
    [[time.sleep(1)] for _ in iter(int, 1)]

def stop():
    kill_existing()
    aios_db.write("aios_pids", {})
    print("AIOS stopped")

actions = {
    "start": start,
    "stop": stop,
    "status": lambda: print(f"PIDs: {aios_db.read('aios_pids')}")
}

actions.get(command, start)()

README.md:
python aios_start.py start - start system
python aios_start.py stop - stop system
python aios_start.py status - show processes
python core/test_all.py - run tests
python programs/todo/todo.py list - show tasks
python programs/todo/todo.py add - create task
python programs/todo/todo.py done - complete task
python programs/todo/todo.py clear - remove done
python services/service.py list - show services
python services/service.py start - start service
python services/service.py stop - stop service
python services/service.py status - check status
python services/backup.py - backup files
python programs/schedule/scheduler.py - run scheduler
python programs/planner/planner.py - plan tasks
python programs/ranker/ranker.py add - add idea
python programs/ranker/ranker.py rank - score ideas
python programs/ranker/ranker.py pick - best idea
python programs/ranker/ranker.py list - show ideas
python programs/builder/builder.py - build components
python services/scraper.py - scrape urls
python programs/swarm/swarm.py ask - query llm
python programs/swarm/swarm.py stats - cache info
python services/gdrive.py sync - upload files
python services/gdrive.py list - show files
python services/web.py start - web interface
python services/web.py kill - stop server
python services/web.py status - server info
python programs/autollm/autollm.py - auto llm
python services/feed.py add - add message
python services/feed.py view - view feed
python services/feed.py list - list messages
python services/feed.py clear - clear old
