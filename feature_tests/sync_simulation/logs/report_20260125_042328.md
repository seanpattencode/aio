# Sync Strategy Simulation Report

Log: /home/seanpatten/projects/aio/feature_tests/sync_simulation/logs/monte_carlo_20260125_042306.jsonl

## Summary

| Strategy | Consistency % | Avg Data Loss | Avg Events |
|----------|--------------|---------------|------------|
| last_write_wins | 100% | 56.6 | 71 |
| append_only | 12% | -9.6 | 71 |
| vector_clock | 20% | -0.5 | 70 |
| crdt_lww | 20% | -0.5 | 70 |

## Strategy Analysis


### last_write_wins (Current aio)
- Simple but lossy. Later sync overwrites earlier data.
- **Problem**: Concurrent edits = guaranteed data loss.

### append_only (Recommended)
- Events immutable, replayed to build state.
- **Advantage**: No conflicts possible, full history preserved.
- **Used by**: Datomic, Event Sourcing systems, Kafka.

### vector_clock
- Detects concurrent modifications.
- **Advantage**: Can surface conflicts for manual resolution.
- **Used by**: Dynamo, Riak, distributed databases.

### crdt_lww (CRDT Last-Writer-Wins)
- Deterministic merge, no coordination needed.
- **Advantage**: Always converges, works offline.
- **Used by**: Figma, Linear, collaborative editors.

## Recommendation

For aio's use case (personal multi-device sync):
1. **append_only** is simplest and sufficient
2. Archive instead of delete/modify
3. Replay events to build state
4. Git merges cleanly (text append)

## References
- Shapiro et al. "Conflict-free Replicated Data Types" (2011)
- Kleppmann "Designing Data-Intensive Applications" Ch. 5
- Fowler "Event Sourcing" pattern
- Lamport "Time, Clocks, and the Ordering of Events" (1978)
