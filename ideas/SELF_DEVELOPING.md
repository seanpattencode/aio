# Self-Developing System

The project develops itself indirectly. The direct code changes are the visible output, but the system that produces them is shaped by everything around it:

- **ideas/** — crystallizes principles that become coding rules
- **tasks** — prioritizes what gets built next
- **notes** — captures raw signal before it's lost
- **a diff** — enforces the ratchet on every commit
- **conversations** — generate code fixes AND formalize the theory behind why they matter

The project is a feedback loop that includes its own design philosophy as input. A doc like TOKEN_EFFICIENCY influences how the next agent session writes code. The workcycle rules exist because previous sessions extracted them from practice. None of that is "writing code" but all of it determines what code gets written and how.

Self-developing in the evolutionary sense — the environment (ideas, tasks, notes) shapes the selection pressure on the code.

## Current Work Sets the Standard for Future Work

This also means past and current work needs to be excellent — not just functional for today, but forming the standard that future sessions inherit. Every idea doc, every commit message, every task description becomes training data for the next cycle. Sloppy work now propagates sloppiness forward. Tight work now raises the floor permanently. The system doesn't just use its history, it learns from it.
